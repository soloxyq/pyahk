# 04 配置与条件系统

## 概述

配置系统是pyahk的核心基础设施，提供灵活的JSON配置管理和强大的条件逻辑系统。支持热重载、配置验证和多配置文件管理，为复杂的游戏自动化需求提供精确的控制能力。

---

## 📋 配置管理架构

### ConfigManager 核心功能
```python
class ConfigManager:
    """统一配置管理器"""
    def __init__(self):
        self._configs = {}
        self._watchers = {}
        self._schema_validator = None
    
    def load_config(self, config_file: str) -> dict:
        """加载并验证配置文件"""
        
    def save_config(self, config_file: str, config_data: dict):
        """保存配置到文件"""
        
    def hot_reload(self, config_file: str):
        """热重载配置，无需重启程序"""
```

### 配置文件结构
```json
{
  "version": "1.0",
  "global": {
    "debug_mode": false,
    "capture_interval": 100,
    "log_level": "INFO"
  },
  "skills": [
    {
      "name": "主要技能",
      "key": "1",
      "trigger_mode": 1,
      "execute_condition": 2,
      "priority": "high",
      "enabled": true
    }
  ],
  "resource_management": {
    "hp_config": {
      "enabled": true,
      "key": "1",
      "threshold": 50,
      "detection_mode": "circle",
      "center_x": 175,
      "center_y": 957,
      "radius": 39,
      "colors": [
        {
          "name": "HP Normal",
          "target_h": 157,
          "target_s": 75,
          "target_v": 29,
          "tolerance_h": 5,
          "tolerance_s": 20,
          "tolerance_v": 20
        }
      ]
    },
    "mp_config": {
      "enabled": true,
      "key": "2",
      "threshold": 50,
      "detection_mode": "text_ocr",
      "text_x1": 1552,
      "text_y1": 910,
      "text_x2": 1560,
      "text_y2": 1004,
      "match_threshold": 0.70
    },
    "check_interval": 200
  },
  "priority_keys": {
    "enabled": true,
    "special_keys": ["space"],
    "managed_keys": {
      "right_mouse": { "target": "right_mouse", "delay": 50 },
      "e": { "target": "0", "delay": 30 }
    }
  },
  "stationary_mode_config": {
    "hotkey": "xbutton1",
    "mode_type": "shift_modifier",
    "force_move_hotkey": "x"
  },
  "pathfinding_config": {
    "hotkey": "f9",
    "enabled": false,
    "minimap_region": [1670, 50, 200, 200]
  },
  "affix_reroll": {
    "enabled": false,
    "target_affixes": ["暴击率", "暴击伤害"],
    "max_attempts": 100
  }
}
```

### 配置验证与类型检查
```python
from pydantic import BaseModel, Field
from typing import List, Optional, Tuple

class SkillConfig(BaseModel):
    name: str
    key: str                          # 主要按键 - 支持序列格式
    alt_key: Optional[str] = None     # 辅助按键 - 支持序列格式
    trigger_mode: int = Field(ge=0, le=2)
    execute_condition: int = Field(ge=0, le=2)
    priority: bool = False
    enabled: bool = True
    interval: Optional[int] = Field(None, ge=50)
    cooldown_coords: Optional[List[int]] = None

class PriorityKeysConfig(BaseModel):
    enabled: bool = True
    keys: List[str] = []
    delay_ms: int = Field(50, ge=0, le=500)  # 优先级延迟保护（0-500ms）

class GlobalConfig(BaseModel):
    debug_mode: bool = False
    capture_interval: int = Field(100, ge=50, le=1000)
    log_level: str = Field("INFO", regex="^(DEBUG|INFO|WARNING|ERROR)$")
```

### 🚀 按键序列配置

#### 序列格式支持
```json
{
  "name": "火球连击",
  "key": "delay50,q",              // 延迟50ms后按q键
  "alt_key": "delay100,shift+q",   // 延迟100ms后按组合键
  "trigger_mode": 0,
  "interval": 2000
}
```

#### 复杂序列示例
```json
{
  "name": "三连击技能",
  "key": "1,delay200,2,delay150,3",    // 连续技能释放
  "alt_key": "delay100,ctrl+1",        // 强化版本
  "trigger_mode": 1,                   // 冷却触发
  "cooldown_coords": [100, 50, 20, 20]
}
```

#### 序列验证规则
```python
def validate_key_sequence(key_sequence: str) -> bool:
    """验证按键序列格式"""
    if not key_sequence:
        return False
    
    # 支持单个按键或逗号分隔的序列
    if ',' not in key_sequence:
        return validate_single_key(key_sequence)
    
    # 验证序列中的每个元素
    for key_part in key_sequence.split(','):
        key_part = key_part.strip()
        if key_part.startswith('delay'):
            # 验证延迟格式：delay50, delay100, etc.
            try:
                delay_ms = int(key_part[5:])
                if delay_ms < 0 or delay_ms > 10000:
                    return False
            except ValueError:
                return False
        else:
            if not validate_single_key(key_part):
                return False
    return True
```

#### 延迟指令最佳实践

**推荐范围**：
- **最佳范围**：50-500ms（适合大多数游戏场景）
- **最小值**：理论上支持0ms，但无实际意义
- **最大值**：虽然代码支持10000ms，但不推荐超过1000ms
- **性能考虑**：过长的延迟会影响响应速度

**常用延迟值**：
```json
{
  "delay50": "技能前摇保护，确保游戏响应",
  "delay100": "短暂等待，适合快速连招",
  "delay200": "中等延迟，适合普通技能间隔",
  "delay500": "长动画等待，适合大招释放"
}
```

**序列格式规范**：
1. **分隔符**：必须使用英文逗号 `,`
2. **空格处理**：逗号前后的空格会被自动trim（但不推荐添加）
3. **延迟格式**：`delay` + 数字，无等号，无空格
   - ✅ 正确：`delay50`
   - ❌ 错误：`delay=50`, `delay 50`, `delay_50`
4. **组合键**：使用 `+` 连接，如 `shift+q`, `ctrl+alt+tab`
5. **序列长度**：理论上无限制，但建议不超过10个元素

**错误处理机制**：
- **格式错误**：无效的delay格式会被记录到日志，该指令被跳过
- **队列满**：序列部分元素可能被丢弃，日志会记录警告
- **中断处理**：系统停止时，未完成的序列会被自动清理
- **去重保护**：重复的序列请求会被智能过滤

---

## 🎮 原地模式配置

### 功能说明
原地模式是ARPG游戏中的核心战斗辅助功能，允许角色在不移动的情况下释放技能。pyahk提供两种实现方式，适配不同游戏和玩家习惯。

### 配置参数

**hotkey**：原地模式切换键
- 通常使用鼠标侧键（xbutton1/xbutton2）或键盘按键（如X键）
- 按一次进入原地模式，再按一次退出
- OSD会实时显示当前状态
- **如果留空或不设置，原地模式功能将不会启用**

**mode_type**：模式类型，决定原地模式的实现方式
- `shift_modifier`（推荐）：自动为所有技能键添加Shift修饰符，利用游戏原生的"Shift+技能=原地释放"机制。优点是完全兼容游戏机制，不影响鼠标移动；缺点是需要游戏支持Shift修饰符。适用于D4、POE2等标准ARPG游戏。
- `block_mouse`（特殊场景）：直接屏蔽鼠标左右键，防止角色移动。优点是不依赖游戏机制；缺点是完全阻止鼠标攻击和交互。适用于不支持Shift修饰符的游戏。

**force_move_hotkey**：强制移动/交互键
- 在原地模式激活时，此按键不受影响，保持正常功能
- 典型用途：D4/POE2的强制移动键（X键）、捡装备、开门交互等
- 允许玩家在不退出原地模式的情况下临时移动或交互
- **如果留空或不设置，交互键功能将不会启用**

### 配置示例

**D4德鲁伊配置**：使用侧键切换原地模式，X键保持强制移动功能
```json
{
  "stationary_mode_config": {
    "hotkey": "xbutton1",
    "mode_type": "shift_modifier",
    "force_move_hotkey": "x"
  }
}
```

**POE2配置**：X键切换原地模式，A键用于强制移动
```json
{
  "stationary_mode_config": {
    "hotkey": "x",
    "mode_type": "shift_modifier",
    "force_move_hotkey": "a"
  }
}
```

### 配置切换注意事项

当切换不同配置文件时，如果同一个按键在不同配置中扮演不同角色（例如X键在配置A中是force_move_hotkey，在配置B中是stationary hotkey），系统会自动处理热键重新注册。从v2025.01.11版本开始，加载新配置时会先取消所有可配置热键，再重新注册，避免角色转换冲突。

如果遇到切换配置后热键失效的问题，可以查看日志确认：
- `[热键管理] 取消注册所有可配置热键`
- `[热键管理] 成功注册热键 'stationary': x`
- `[输入处理器] 原地模式类型已更新: shift_modifier`

---

## 🗺️ 自动寻路配置

### 功能说明
自动寻路系统基于小地图识别和A*算法，实现智能路径规划和障碍物绕行。适用于地图探索、自动跑图等场景。

### 配置参数

**hotkey**：寻路功能开关键
- 默认为F9键
- 按一次启动寻路，再按一次停止
- 与原地模式、强制移动键一样支持动态配置更新
- **如果留空或不设置，寻路功能将不会启用**

**enabled**：是否启用寻路功能
- 默认为false（关闭状态）
- 寻路功能较消耗CPU资源，建议按需启用
- 即使enabled为false，hotkey仍会注册，方便临时启用

**minimap_region**：小地图截图区域
- 格式：[x, y, width, height]
- 需要根据游戏分辨率和UI缩放进行调整
- 1920x1080分辨率参考值：[1670, 50, 200, 200]
- 2560x1440分辨率参考值：[2230, 67, 267, 267]

### 配置示例

**基础配置**：禁用寻路，但保留热键
```json
{
  "pathfinding_config": {
    "hotkey": "f9",
    "enabled": false
  }
}
```

**1080P分辨率配置**：启用寻路
```json
{
  "pathfinding_config": {
    "hotkey": "f9",
    "enabled": true,
    "minimap_region": [1670, 50, 200, 200]
  }
}
```

**2K分辨率配置**：调整小地图区域
```json
{
  "pathfinding_config": {
    "hotkey": "f9",
    "enabled": true,
    "minimap_region": [2230, 67, 267, 267]
  }
}
```

### 使用建议

1. **小地图区域调整**：首次配置时，建议使用截图工具测量游戏中小地图的实际位置和尺寸，确保配置准确。
2. **热键冲突避免**：寻路热键不应与技能键、原地模式键、强制移动键冲突。
3. **性能考虑**：寻路涉及图像识别和路径计算，如果电脑配置较低，建议仅在需要时启用。
4. **配置切换**：不同配置文件可以使用不同的寻路热键，系统会在切换配置时自动重新注册。

---

### 配置热重载机制
```python
class ConfigWatcher:
    """配置文件变化监控"""
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.file_watchers = {}
    
    def watch_config_file(self, config_file: str):
        """监控配置文件变化，自动重载"""
        from watchdog.observers import Observer
        from watchdog.events import FileSystemEventHandler
        
        class ConfigFileHandler(FileSystemEventHandler):
            def on_modified(self, event):
                if event.src_path.endswith('.json'):
                    self.config_manager.hot_reload(event.src_path)
```

---

## 🎯 条件系统详解

### 设计目标
- **简单可枚举**：使用整型枚举值 0/1/2 控制分支
- **扩展友好**：新增条件时只需增加枚举 + `_evaluate_condition` 分支
- **稳定防抖**：资源条件加入连续窗口，避免边界抖动

### 条件枚举概览

| 值 | 名称 | 语义 | 适用场景 |
|----|------|------|----------|
| 0 | 无条件 | 直接允许执行 | 普通循环技能 |
| 1 | BUFF 限制 | 仅当指定 Buff 不存在/失效时执行 | 维持类技能、需刷新状态 |
| 2 | 资源条件 | 资源达到阈值且在连续窗口内稳定 | 资源驱动爆发/消耗类 |

### 执行调用栈
```python
def _try_execute_skill(skill):
    """技能执行入口"""
    if not skill.enabled:
        return False
    
    if not self._check_execution_conditions(skill):
        return False
    
    return self._execute_skill_action(skill)

def _check_execution_conditions(skill):
    """条件检查分发器"""
    condition = skill.execute_condition
    
    if condition == 0:
        return True  # 无条件
    elif condition == 1:
        return self._evaluate_condition_buff(skill)
    elif condition == 2:
        return self._evaluate_condition_resource(skill)
    else:
        LOG_ERROR(f"未知的执行条件: {condition}")
        return False
```

### 无条件模式 (ExecuteCondition = 0)
```json
{
  "name": "基础攻击",
  "key": "1",
  "trigger_mode": 1,
  "execute_condition": 0,
  "cooldown_coords": [100, 50, 20, 20]
}
```
- **行为**：冷却就绪时直接执行主按键
- **适用**：无特殊限制的常规技能
- **优势**：简单直接，性能最高

### Buff限制模式 (ExecuteCondition = 1)
```json
{
  "name": "护盾技能",
  "key": "e",
  "trigger_mode": 1,
  "execute_condition": 1,
  "buff_coords": [200, 100, 30, 30],
  "buff_color": [100, 150, 200],
  "buff_tolerance": 20
}
```

#### 检测逻辑
```python
def _evaluate_condition_buff(self, skill):
    """Buff存在性检测"""
    if not skill.buff_coords:
        return True
    
    frame = self.border_manager.get_current_frame()
    if frame is None:
        return False
    
    x, y, w, h = skill.buff_coords
    roi = frame[y:y+h, x:x+w]
    
    # RGB颜色匹配检测Buff图标
    target_color = skill.buff_color
    tolerance = skill.buff_tolerance or 20
    
    similarity = self._calculate_color_similarity(roi, target_color)
    buff_exists = similarity > 0.8  # 80%相似度阈值
    
    # Buff存在时不执行，不存在时执行
    return not buff_exists
```

#### 应用场景
- **护盾技能**：护盾消失时自动重新施放
- **增益BUFF**：BUFF到期时自动刷新
- **状态维持**：确保关键状态持续存在

### 资源条件模式 (ExecuteCondition = 2)
```json
{
  "name": "消耗技能",
  "key": "r",
  "trigger_mode": 1,
  "execute_condition": 2,
  "condition_coord_x": 50,
  "condition_coord_y": 950,
  "condition_color": 0,  // 0=资源检测, 1=HP检测, 其他=RGB颜色匹配
  "color_tolerance": 12,
  "alt_key": "t"
}
```

#### 🚀 二次确认机制 (最新架构)
  资源条件检测采用智能的连续性验证机制，确保检测结果的稳定性和可靠性。实际代码中实现了滑动窗口检测，避免边界抖动：

```python
def _check_resource_continuity(self, skill_name: str, current_result: bool) -> bool:
    """
    资源条件连续性检查 - 智能二次确认机制
    - 如果当前结果为True（资源充足），需要连续多次True才执行主按键
    - 如果当前结果为False（资源不足），立即执行备用按键
    """
    history = self._resource_condition_history.setdefault(skill_name, [])
    history.append(current_result)
    if len(history) > self._required_consecutive_checks:  # 默认为2
        history.pop(0)

    # 如果当前结果为False（资源不足），立即返回False执行AltKey
    if not current_result:
        return False

    # 如果当前结果为True（资源充足），需要连续多次True才返回True
    if all(history) and len(history) == self._required_consecutive_checks:
        return True

    return False
```

**核心设计原理**：
- **资源不足（False）**：立即响应，执行 `alt_key`，避免补给延迟
- **资源充足（True）**：需要连续2次确认，执行 `key`，防止误判浪费资源
- **滑动窗口**：使用滑动窗口机制，保持连续性检测的实时性
- **独立历史**：每个技能维护独立的检测历史记录

**配置参数**：
- `_required_consecutive_checks = 2`：默认需要连续2次True确认
- 每个技能独立跟踪：`_resource_condition_history = {skill_name: [历史结果]}`

#### 资源检测类型
| condition_color | 检测类型 | 说明 |
|-----------------|----------|------|
| 0 | 资源充足性 | 通用资源条检测（MP、怒气、能量等） |
| 1 | HP充足性 | 专用HP检测，适配生命球特殊形状 |
| 其他RGB值 | 颜色匹配 | 精确的RGB颜色相似度检测 |

#### 双按键策略
- **主按键（key）**：资源充足且连续确认时使用的高消耗技能
- **备用按键（alt_key）**：资源不足时立即执行的低消耗替代技能  
- **智能切换**：根据实时资源状态和二次确认结果自动选择

#### 检测逻辑流程
```
1. 获取缓存帧数据
   ↓
2. 根据condition_color类型执行相应检测
   ↓
3. 调用_check_resource_continuity()进行二次确认
   ↓
4. 资源不足 → 立即返回False → 执行alt_key
   ↓
5. 资源充足 → 检查连续确认 → 满足条件执行key
```

---

## 🔧 高级配置技巧

### 1. 技能优先级配置
```json
{
  "skills": [
    {
      "name": "紧急治疗",
      "priority": "emergency",
      "execute_condition": 2,
      "resource_type": "hp",
      "resource_threshold": 30
    },
    {
      "name": "主要输出",
      "priority": "high",
      "execute_condition": 1,
      "buff_coords": [300, 100, 40, 40]
    },
    {
      "name": "辅助技能",
      "priority": "normal",
      "execute_condition": 0
    },
    {
      "name": "拾取物品",
      "priority": "low",
      "execute_condition": 0
    }
  ]
}
```

#### 优先级等级说明
- **emergency**：紧急优先级，用于HP/MP药剂等关键操作
- **high**：高优先级，用于核心输出和重要BUFF技能
- **normal**：普通优先级，用于常规攻击技能
- **low**：低优先级，用于辅助功能和界面操作

### 2. 条件组合策略
```json
{
  "name": "复合条件技能",
  "key": "q",
  "execute_condition": 2,
  "resource_coords": [50, 950, 200, 20],
  "resource_threshold": 80,
  "additional_conditions": {
    "buff_check": {
      "coords": [200, 100, 30, 30],
      "required": false
    },
    "enemy_presence": {
      "coords": [500, 400, 100, 100],
      "required": true
    }
  }
}
```

### 3. 环境适配配置
```json
{
  "profiles": {
    "1920x1080": {
      "hp_region": [136, 910, 213, 1004],
      "mp_region": [136, 870, 213, 894],
      "skill_size": 20
    },
    "2560x1440": {
      "hp_region": [181, 1213, 284, 1339],
      "mp_region": [181, 1160, 284, 1192],
      "skill_size": 27
    }
  }
}
```

### 4. 优先级按键配置（选择性事件拦截）
```json
{
  "priority_keys": {
    "enabled": true,
    "special_keys": ["space"],
    "managed_keys": {
      "right_mouse": { "target": "right_mouse", "delay": 50 },
      "e": { "target": "0", "delay": 30 }
    },
    "description": "special_keys 仅监控不拦截；managed_keys 采用对象格式，支持映射与前置延迟"
  }
}
```

#### 配置说明（新格式）
- special_keys：仅用于状态监控与暂停，不拦截系统事件，不需要 target/delay
- managed_keys：对象格式，键为被“管理”的物理按键名，值为对象：
  - target：最终发送到游戏的按键（为避免自拦截，拦截 E → 发送 0 等映射更稳健）
  - delay：前置延迟（毫秒），用于“暂停→状态同步→发送”可靠时序

#### 配置说明
- **enabled**：是否启用优先级按键系统
- **keys**：优先级按键列表，支持多种按键名称变体
- **description**：配置描述（可选）

#### 支持的按键类型
- **键盘按键**：`space`, `ctrl`, `shift`, `alt`, `tab`, `enter`, `esc`, `a-z`, `0-9`, `f1-f12`
- **鼠标按键**：`left_mouse`, `right_mouse`, `middle_mouse`
- **按键标准化**：自动处理变体（如 `spacebar` → `space`）

#### 验证规则补充（建议）
- managed_keys 的值须形如 {"target": string, "delay": int>=0}
- 若 target 与被拦截键相同，底层 Hook 可能自拦截导致无效，建议在 GUI 中给出提示并引导映射

### 5. 智能药剂检测配置

#### 圆形检测配置（推荐）
```json
{
  "resource_management": {
    "hp_config": {
      "enabled": true,
      "key": "1",
      "threshold": 50,
      "detection_mode": "circle",
      "center_x": 175,
      "center_y": 957,
      "radius": 39,
      "colors": [
        {
          "name": "HP Normal",
          "target_h": 157,
          "target_s": 75,
          "target_v": 29,
          "tolerance_h": 5,
          "tolerance_s": 20,
          "tolerance_v": 20
        }
      ]
    }
  }
}
```

#### 文本OCR检测配置（最新功能）
```json
{
  "resource_management": {
    "mp_config": {
      "enabled": true,
      "key": "2",
      "threshold": 50,
      "detection_mode": "text_ocr",
      "text_x1": 1552,
      "text_y1": 910,
      "text_x2": 1560,
      "text_y2": 1004,
      "match_threshold": 0.70
    }
  }
}
```

#### 检测模式对比

| 检测模式 | 适用场景 | 优势 | 劣势 |
|----------|----------|------|------|
| **circle** | HP/MP球体检测 | 精确、抗干扰强、自动识别 | 需要球体坐标 |
| **text_ocr** | 数字文本识别 | 直接读数、最高准确性 | 需要文本区域、计算量大 |
| **rectangle** | 传统条形检测 | 兼容性好、配置简单 | 易受干扰、精度较低 |

#### 圆形检测优势
- **精确度更高**：只检测球体区域，排除背景干扰
- **自动识别**：支持"Detect Orbs"按钮自动识别球体位置
- **抗干扰强**：圆形蒙版确保只计算球体内的像素

#### 文本OCR检测优势
- **直接读数**：识别实际的HP/MP数值，无需估算
- **最高准确性**：不受UI主题、光照、特效影响
- **智能模板**：支持真实游戏字体和数字模板

#### 矩形检测配置（向后兼容）
```json
{
  "resource_management": {
    "hp_config": {
      "enabled": true,
      "key": "1",
      "threshold": 50,
      "detection_mode": "rectangle",
      "region_x1": 136,
      "region_y1": 910,
      "region_x2": 213,
      "region_y2": 1004,
      "colors": [...]
    }
  }
}
```

### 6. 调试配置
```json
{
  "debug": {
    "enabled": true,
    "log_conditions": true,
    "log_resource_detection": true,
    "log_priority_keys": true,
    "log_event_interception": true,
    "save_detection_frames": false,
    "condition_log_interval": 1000
  }
}
```

---

## 🔄 配置最佳实践

### 1. 渐进式配置
```python
# 第一阶段：基础技能配置
basic_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 0, "execute_condition": 0}
]

# 第二阶段：添加冷却检测
advanced_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 1, "execute_condition": 0,
     "cooldown_coords": [100, 50, 20, 20]}
]

# 第三阶段：添加复杂条件
expert_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 1, "execute_condition": 2,
     "cooldown_coords": [100, 50, 20, 20],
     "resource_coords": [50, 950, 200, 20],
     "resource_threshold": 70}
]
```

### 2. 配置模板
```json
{
  "templates": {
    "basic_skill": {
      "trigger_mode": 1,
      "execute_condition": 0,
      "priority": "normal",
      "enabled": true
    },
    "high_priority_skill": {
      "trigger_mode": 1,
      "execute_condition": 0,
      "priority": "high",
      "enabled": true
    },
    "emergency_skill": {
      "trigger_mode": 1,
      "execute_condition": 0,
      "priority": "emergency",
      "enabled": true
    },
    "resource_skill": {
      "trigger_mode": 1,
      "execute_condition": 2,
      "resource_threshold": 70,
      "continuity_window": 3,
      "continuity_threshold": 2,
      "priority": "normal"
    },
    "buff_skill": {
      "trigger_mode": 1,
      "execute_condition": 1,
      "buff_tolerance": 20,
      "priority": "high"
    },
    "circular_hp_potion": {
      "enabled": true,
      "threshold": 50,
      "center_x": 175,
      "center_y": 957,
      "radius": 39,
      "colors": [
        {
          "name": "HP Normal",
          "target_h": 157,
          "target_s": 75,
          "target_v": 29,
          "tolerance_h": 5,
          "tolerance_s": 20,
          "tolerance_v": 20
        }
      ]
    },
    "rectangular_mp_potion": {
      "enabled": true,
      "threshold": 50,
      "region_x1": 1552,
      "region_y1": 910,
      "region_x2": 1560,
      "region_y2": 1004,
      "colors": [
        {
          "name": "MP Normal",
          "target_h": 104,
          "target_s": 80,
          "target_v": 58,
          "tolerance_h": 4,
          "tolerance_s": 5,
          "tolerance_v": 5
        }
      ]
    }
  }
}
```

### 3. 配置验证
```python
def validate_skill_config(skill_config):
    """配置验证函数"""
    errors = []

    # 必需字段检查
    required_fields = ["name", "key", "trigger_mode"]
    for field in required_fields:
        if field not in skill_config:
            errors.append(f"缺少必需字段: {field}")

    # 优先级验证
    priority = skill_config.get("priority", "normal")
    valid_priorities = ["emergency", "high", "normal", "low"]
    if priority not in valid_priorities:
        errors.append(f"无效的优先级: {priority}，应为: {valid_priorities}")

    # 条件特定验证
    execute_condition = skill_config.get("execute_condition", 0)
    if execute_condition == 1:  # BUFF条件
        if not skill_config.get("buff_coords"):
            errors.append("BUFF条件模式需要配置buff_coords")
    elif execute_condition == 2:  # 资源条件
        if not skill_config.get("resource_coords"):
            errors.append("资源条件模式需要配置resource_coords")

    return errors

def validate_resource_config(resource_config):
    """智能药剂配置验证"""
    errors = []

    # 检查是否至少配置了矩形或圆形检测方式
    has_rect_config = all(k in resource_config for k in ["region_x1", "region_y1", "region_x2", "region_y2"])
    has_circle_config = all(k in resource_config for k in ["center_x", "center_y", "radius"])

    if not has_rect_config and not has_circle_config:
        errors.append("需要配置矩形检测区域或圆形检测参数")

    # 颜色配置验证
    colors = resource_config.get("colors", [])
    if not colors:
        errors.append("至少需要配置一种颜色用于检测")

    for i, color in enumerate(colors):
        required_fields = ["target_h", "target_s", "target_v", "tolerance_h", "tolerance_s", "tolerance_v"]
        for field in required_fields:
            if field not in color:
                errors.append(f"颜色{i+1}缺少字段: {field}")

    return errors

def validate_priority_keys_config(config):
    """优先级按键配置验证（支持选择性事件拦截）"""
    errors = []

    if not isinstance(config.get("enabled"), bool):
        errors.append("enabled字段必须为布尔值")

    keys = config.get("keys", [])
    if not isinstance(keys, list):
        errors.append("keys字段必须为数组")

    # 验证delay_ms配置
    delay_ms = config.get("delay_ms", 50)
    if not isinstance(delay_ms, int) or delay_ms < 0 or delay_ms > 1000:
        errors.append("delay_ms必须为0-1000之间的整数")

    # 验证special_keys配置
    special_keys = config.get("special_keys", [])
    if not isinstance(special_keys, list):
        errors.append("special_keys字段必须为数组")
    
    # 确保special_keys都在keys中
    for special_key in special_keys:
        if special_key not in keys:
            errors.append(f"special_key '{special_key}' 必须在keys列表中")

    # 标准化按键名称检查
    valid_key_patterns = [
        r'^[a-zA-Z0-9]$',  # 单字母数字
        r'^f[0-9]{1,2}$',  # F1-F12
        r'^(ctrl|shift|alt|space|tab|enter|esc)$',  # 特殊键
        r'^(left_mouse|right_mouse|middle_mouse)$'  # 鼠标键
    ]

    import re
    for key in keys:
        if not any(re.match(pattern, key) for pattern in valid_key_patterns):
            errors.append(f"无效的按键名称: {key}")

    return errors
```

通过这套完整的配置和条件系统，pyahk能够适应各种复杂的游戏场景和用户需求，提供精确的自动化控制能力。