# 优先级按键暂停/恢复架构说明

## 概述

本架构实现了一个高效的"暂停/恢复"机制，当用户按下优先级按键（如空格键、右键等）时，系统会自动暂停 `SkillManager` 的所有调度任务，以避免不必要的 CPU 资源浪费。当优先级按键释放后，系统自动恢复正常调度。

## 核心原理

### 问题背景
- 之前的实现中，当优先级按键被按下时，虽然技能执行被阻塞，但 `UnifiedScheduler` 仍然继续运行
- 这导致 `check_cooldowns`、帧检测、资源检查等耗费 CPU 的任务仍在执行，但结果完全被丢弃
- 造成了"零功效的资源浪费"

### 解决方案
实现了一个基于事件总线的双向通信机制：

1. **InputHandler** 监控优先级按键状态变化
2. 当第一个优先级按键按下时，通过事件总线通知 **SkillManager** 暂停调度
3. 当所有优先级按键释放时，通过事件总线通知 **SkillManager** 恢复调度

## 架构组件

### 1. InputHandler (优先级按键监控)

**文件**: `torchlight_assistant/core/input_handler.py`

**关键方法**:
```python
def _pause_skill_scheduler(self):
    """暂停技能调度器以节省CPU资源"""
    event_bus.publish('scheduler_pause_requested', {
        'reason': 'priority_key_pressed',
        'active_keys': list(self._priority_keys_pressed)
    })

def _resume_skill_scheduler(self):
    """恢复技能调度器"""
    event_bus.publish('scheduler_resume_requested', {
        'reason': 'priority_key_released'
    })
```

**触发时机**:
- `_on_key_press`: 第一个优先级按键按下时触发暂停
- `_on_key_release`: 最后一个优先级按键释放时触发恢复
- `_on_mouse_click`: 鼠标优先级按键的按下/释放

### 2. SkillManager (调度器控制)

**文件**: `torchlight_assistant/core/skill_manager.py`

**事件订阅**:
```python
event_bus.subscribe("scheduler_pause_requested", self._on_scheduler_pause_requested)
event_bus.subscribe("scheduler_resume_requested", self._on_scheduler_resume_requested)
```

**回调方法**:
```python
def _on_scheduler_pause_requested(self, event_data):
    """响应优先级按键按下 - 暂停调度器以节省CPU资源"""
    if self.unified_scheduler.get_status()["running"]:
        self.unified_scheduler.pause()

def _on_scheduler_resume_requested(self, event_data):
    """响应优先级按键释放 - 恢复调度器"""
    if self._is_running and not self._is_paused:
        self.unified_scheduler.resume()
```

### 3. UnifiedScheduler (核心调度器)

**文件**: `torchlight_assistant/core/unified_scheduler.py`

**修复的方法**:
```python
def pause(self) -> bool:
    """暂停所有任务执行"""
    with self._condition:
        if not self._running or self._paused:
            return False
        self._paused = True
        return True

def resume(self) -> bool:
    """恢复所有任务执行，智能重算时间"""
    with self._condition:
        if not self._running or not self._paused:
            return False
        self._paused = False
        # 恢复时重新计算所有任务的执行时间
        current_time = self._now()
        for task in self._tasks.values():
            if task.enabled:
                task.next_run_time = current_time + task.interval
        self._rebuild_heap()
        self._condition.notify()
        return True
```

**线程安全保证**:
- 使用 `threading.Condition` 对象协调多线程访问
- 所有状态修改都在锁保护下进行
- 避免竞态条件，确保暂停/恢复操作的原子性

## 可靠性增强：前置延迟机制

### 问题背景
在纯事件驱动的暂停机制中，存在一个理论上的竞态条件：
1. `InputHandler` 监听到优先级按键，发布“暂停”事件。
2. `InputHandler` 立即将该优先级按键（如`space`）推入队列等待执行。
3. 在 `SkillManager` 响应暂停事件并实际暂停调度器之前，游戏可能处于繁忙状态，导致`space`按键的执行时机早于游戏真正“闲置”的时刻，从而使得该按键被“吞掉”或无效。

### 解决方案：前置延迟
为了确保优先级按键的绝对可靠，我们引入了“前置延迟”机制。

**架构流程**:
1. `InputHandler` 监听到优先级按键被按下。
2. **立即**通过事件总线发布`scheduler_pause_requested`事件。
3. **【关键】** `InputHandler`向**紧急(emergency)队列**的队首插入一个短暂的、可配置的`delay`指令（如50ms）。
4. 随后，将优先级按键本身（如`space`）插入**高优先级(high)队列**。
5. 输入处理线程在执行时，会优先处理紧急队列中的`delay`指令，强制等待50ms。这个延迟给予了 `SkillManager` 和游戏客户端足够的时间来响应暂停请求，确保后续的`space`指令是在一个“干净”的状态下被执行。

这个机制以一个极小的性能代价（几十毫秒的延迟），换取了手动操作的绝对可靠性。

## 性能优化效果

### CPU 使用优化
- **暂停期间**: 所有调度任务停止执行，CPU 使用率显著降低
- **恢复机制**: 智能重新计算任务执行时间，避免堆积执行

### 资源节约
- 避免无效的帧捕获和像素分析
- 停止冷却时间检查和资源状态更新
- 减少不必要的内存分配和网络访问

### 响应性提升
- 优先级按键响应更加即时
- 系统整体响应性得到改善

## 状态管理

### 暂停状态层级
1. **用户手动暂停** (`_is_paused = True`): 通过 UI 或热键暂停整个系统
2. **优先级按键暂停** (`unified_scheduler.pause()`): 临时性能优化暂停
3. **系统停止** (`_is_running = False`): 完全停止运行

### 恢复逻辑
- 只有在系统运行中（`_is_running = True`）且未被用户手动暂停（`_is_paused = False`）时才会自动恢复
- 确保用户的手动暂停不会被优先级按键的自动恢复机制覆盖

## 事件流程图

```
用户按下空格键
      ↓
InputHandler._on_key_press()
      ↓
_pause_skill_scheduler()
      ↓
event_bus.publish('scheduler_pause_requested')
      ↓
SkillManager._on_scheduler_pause_requested()
      ↓
unified_scheduler.pause()
      ↓
🛑 所有调度任务暂停执行

      ↓ (用户释放空格键)

InputHandler._on_key_release()
      ↓
_resume_skill_scheduler()
      ↓
event_bus.publish('scheduler_resume_requested')
      ↓
SkillManager._on_scheduler_resume_requested()
      ↓
unified_scheduler.resume()
      ↓
▶️ 所有调度任务恢复执行
```

## 测试验证

架构已通过以下测试验证：

1. **调度器暂停/恢复功能测试**: ✅ 通过
2. **事件总线通信测试**: ✅ 通过
3. **多优先级按键处理测试**: ✅ 通过
4. **状态管理逻辑测试**: ✅ 通过

## 优势总结

1. **零资源浪费**: 优先级按键激活期间完全停止不必要的计算
2. **即时响应**: 按键按下后立即暂停，释放后立即恢复
3. **智能状态管理**: 尊重用户的手动暂停状态
4. **线程安全**: 使用事件总线和条件变量确保线程安全
5. **可扩展性**: 架构支持未来添加更多暂停/恢复触发条件

这个架构实现了真正的"按需计算"，只在实际需要时消耗 CPU 资源，显著提升了系统的整体效率。