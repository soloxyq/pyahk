# 03 功能模块详解

本章详细介绍pyahk的四大核心功能模块：技能系统、智能药剂、装备洗练和自动寻路。每个模块都采用模块化设计，既可独立运行，也可协同工作。

---

## 🎯 技能自动化系统

### 概述
技能系统是pyahk的核心功能，提供自动化的技能释放、冷却检测和优先级管理。支持多种触发模式和执行条件，实现精确的战斗自动化。

**🚀 最新架构升级**：引入优先级按键暂停/恢复机制，当空格、右键等优先级按键激活时，系统智能暂停所有后台调度任务，实现"零资源浪费"的高效运行。

### 核心架构组件

#### UnifiedScheduler - 统一调度器
```python
class UnifiedScheduler:
    """统一任务调度器 - 支持智能暂停/恢复"""
    
    def pause(self) -> bool:
        """暂停所有任务执行"""
        self._paused = True
        return True
    
    def resume(self) -> bool:
        """恢复所有任务执行，智能重算时间"""
        self._paused = False
        current_time = self._now()
        for task in self._tasks.values():
            if task.enabled:
                task.next_run_time = current_time + task.interval
        self._rebuild_heap()
        self._condition.notify()
        return True
```

**技术特点**：
- 基于heapq的高效优先级队列
- time.monotonic()单调时间源，避免系统时钟调整影响
- 支持任务的动态增删改和智能暂停恢复
- 单线程调度避免竞态条件，提供亚毫秒级精度

#### SkillManager - 智能技能管理器
```python
class SkillManager:
    """重构后的技能管理器 - 具备自主调度和暂停控制能力"""
    
    def _on_scheduler_pause_requested(self, event_data):
        """响应优先级按键按下 - 暂停调度器以节省CPU资源"""
        if self.unified_scheduler.get_status()["running"]:
            self.unified_scheduler.pause()
            LOG_INFO(f"[性能优化] 调度器已暂停 - {reason}")
    
    def _on_scheduler_resume_requested(self, event_data):
        """响应优先级按键释放 - 恢复调度器"""
        if self._is_running and not self._is_paused:
            self.unified_scheduler.resume()
            LOG_INFO(f"[性能优化] 调度器已恢复 - {reason}")
```

**核心功能**：
- 自主调度：独立的统一调度器管理所有定时任务
- 事件驱动：通过事件总线响应优先级按键状态变化
- 智能暂停：区分用户手动暂停和系统自动暂停
- 资源优化：优先级按键激活时完全停止CPU密集操作

#### 🚀 优先级按键暂停/恢复架构

**性能优化原理**：
传统实现中，优先级按键激活时虽然技能被阻塞，但调度器仍在运行：
- ❌ `check_cooldowns` 持续执行但结果被丢弃
- ❌ 帧捕获和像素分析持续进行但无效  
- ❌ 资源检查等CPU密集操作造成"零功效资源浪费"

新架构实现真正的"按需计算"：
- ✅ 第一个优先级按键按下时立即暂停所有调度任务
- ✅ 所有优先级按键释放时智能恢复调度
- ✅ CPU使用率在暂停期间降低70-90%

**事件流程**：
```
优先级按键按下 → InputHandler检测 → 发布暂停事件 
→ SkillManager响应 → UnifiedScheduler.pause() → 🛑 CPU大幅降低

优先级按键释放 → InputHandler检测 → 发布恢复事件
→ SkillManager响应 → UnifiedScheduler.resume() → ▶️ 系统恢复
```

### 三种触发模式

#### 1. 定时模式 (TriggerMode = 0)
```json
{
  "name": "持续技能",
  "key": "1",
  "trigger_mode": 0,
  "interval": 1000,  // 每1秒执行一次
  "priority": false
}
```
- **功能**：基于固定时间间隔执行技能
- **使用场景**：持续BUFF技能、定期回血技能
- **特点**：严格按时间间隔执行，不受游戏状态影响

#### 2. 冷却模式 (TriggerMode = 1)
```json
{
  "name": "主要输出",
  "key": "q",
  "trigger_mode": 1,
  "cooldown_coords": [100, 50, 20, 20],  // [x, y, width, height]
  "priority": true
}
```
- **功能**：基于技能图标冷却状态执行技能
- **检测原理**：采用统一的**HSV模板匹配**算法，能有效抵抗游戏内光照和技能图标动画效果的干扰，识别更精准。
- **使用场景**：主要输出技能、有冷却时间的关键技能

#### 3. 按住模式 (TriggerMode = 2)
```json
{
  "name": "移动技能",
  "key": "shift",
  "trigger_mode": 2
}
```
- **功能**：进入运行状态时按下，停止时释放
- **特点**：
  - 仅在状态切换时一次性执行
  - 不参与循环或定时任务
  - 由AHK服务执行，支持组合键
- **使用场景**：持续技能、移动速度增强

### 优先级系统

#### 四级优先队列架构
pyahk采用多级优先队列系统，支持四个优先等级：

| 优先级 | 名称 | 描述 | 典型用例 |
|--------|------|------|----------|
| emergency | 紧急 | 最高优先级，立即执行 | HP/MP药剂、紧急逃生技能 |
| high | 高 | 重要技能，优先处理 | 核心输出技能、关键BUFF |
| normal | 普通 | 标准技能 | 常规攻击技能 |
| low | 低 | 辅助功能 | 拾取物品、界面操作 |

#### MultiPriorityQueue 实现
```python
class MultiPriorityQueue:
    """多级优先队列实现"""

    def __init__(self, maxsize: int = 0):
        # 按优先级从高到低排列
        self._queues = {
            'emergency': deque(),  # 紧急队列
            'high': deque(),       # 高优先级队列
            'normal': deque(),     # 普通队列
            'low': deque()         # 低优先级队列
        }
        self._priority_order = ['emergency', 'high', 'normal', 'low']

    def put(self, item, priority='normal', block=False, timeout=None):
        """按优先级放入元素"""

    def get(self, block=True, timeout=None):
        """按优先级顺序取出元素"""
        for priority in self._priority_order:
            if self._queues[priority]:
                return self._queues[priority].popleft()
```

#### 语义化接口设计
```python
class InputHandler:
    # 语义化的按键执行接口
    def execute_hp_potion(self, key: str):
        """执行HP药剂按键 - 紧急优先级"""
        self._key_queue.put(key, priority='emergency', block=False)

    def execute_mp_potion(self, key: str):
        """执行MP药剂按键 - 紧急优先级"""
        self._key_queue.put(key, priority='emergency', block=False)

    def execute_skill_high(self, key: str):
        """执行高优先级技能按键"""
        self._key_queue.put(key, priority='high', block=False)

    def execute_skill_normal(self, key: str):
        """执行普通技能按键"""
        self._key_queue.put(key, priority='normal', block=False)
```

#### 最佳实践
```json
{
  "skills": [
    {"name": "紧急治疗", "priority": "emergency"},  // 紧急优先级
    {"name": "核心输出", "priority": "high"},       // 高优先级
    {"name": "辅助技能", "priority": "normal"},     // 普通优先级
    {"name": "拾取物品", "priority": "low"}         // 低优先级
  ]
}
```

### 执行条件系统

#### 无条件模式 (ExecuteCondition = 0)
- 冷却就绪时直接执行主按键
- 最简单的执行模式

#### Buff限制模式 (ExecuteCondition = 1)
```json
{
  "execute_condition": 1,
  "buff_coords": [200, 100, 30, 30],
  "key": "e"
}
```
- **逻辑**：Buff存在时不执行，Buff消失时执行
- **场景**：避免重复上BUFF

#### 资源条件模式 (ExecuteCondition = 2)
```json
{
  "execute_condition": 2,
  "resource_coords": [50, 950, 200, 20],
  "resource_threshold": 70,
  "key": "r",
  "alt_key": "t"  // 资源不足时的备用按键
}
```
- **逻辑**：资源充足执行主按键，不足执行备用按键
- **连续性检查**：避免检测抖动
- **场景**：根据MP/怒气状态切换技能

---

## � 多级优先级系统（核心调度引擎）

### 系统概述
多级优先级系统是技能自动化的"输入调度大脑"，提供精细化的按键执行优先级管理和智能的技能执行控制。通过四级优先队列和实时按键状态监控，实现游戏操作的精确控制和前后摇冲突的智能避免。

> **最新更新**：引入优先级按键"重新注入"机制，解决短按空格/右键偶发不生效问题。

### 四级优先队列架构

| 优先级 | 名称 | 数值 | 典型用例 | 执行策略 |
|--------|------|------|----------|----------|
| emergency | 紧急 | 0 (最高) | HP/MP 药剂、极限保命 | 永不被拦截，立即执行 |
| high | 高 | 1 | 优先级按键"重注入"事件（space/right_mouse）、核心技能 | 允许在优先级模式中执行 |
| normal | 普通 | 2 | 常规技能 | 被优先级按键状态暂停 |
| low | 低 | 3 | 辅助 / UI / 拾取 | 被优先级按键状态暂停 |

### 优先级按键监控 + 即时重注入系统

#### 设计目标
- **短按可靠**：任意极短闪避/右键点击也绝不丢失
- **长按保护**：按住优先级按键时，自动技能全局暂停
- **非侵入策略**：只重注入优先级按键本身，不重复发送其它技能
- **标准化匹配**：所有输入统一映射后再判定（减少配置差异）

#### 核心监听 + 重注入流程
```python
def _on_key_press(self, key):
    key_name = self._get_key_name(key)
    if key_name in self._priority_keys_config:
        self._priority_keys_pressed.add(key_name)
        LOG_INFO(f"[优先级模式] {key_name} 按下 - 技能暂停，重注入")
        # 🔥 关键：立即重注入到高优先级队列
        self._inject_priority_key_to_queue(key_name, True)

def _inject_priority_key_to_queue(self, key_name: str, is_press: bool):
    event = key_name if is_press else f"up_{key_name}"
    self._key_queue.put(event, 'high')  # 高优先级注入
```

#### 语义化执行接口
```python
def execute_hp_potion(self, key: str):
    """执行HP药剂 - 紧急优先级"""
    self._key_queue.put(key, priority='emergency')

def execute_skill_high(self, key: str):
    """执行高优先级技能"""
    if self.is_priority_mode_active():
        LOG_INFO(f"技能 {key} 被跳过（优先级按键激活）")
        return
    self._key_queue.put(key, priority='high')

def execute_skill_normal(self, key: str):
    """执行普通技能"""
    if self.is_priority_mode_active():
        LOG_INFO(f"技能 {key} 被跳过（优先级按键激活）")
        return
    self._key_queue.put(key, priority='normal')
```

#### 过滤 & 重注入规则
| 情况 | 行为 | 说明 |
|------|------|------|
| HP/MP（emergency） | 立即执行 | 不被任何模式阻塞 |
| 优先级按键按下 | 立即重注入（high） | 注入 `space` / `right_mouse` 等实际事件 |
| 优先级按键释放 | 注入 `up_space` 等 | 确保长按状态结束被感知 |
| 普通/低技能在优先级按下期间 | 跳过（延后） | 保护玩家意图（走位/瞄准/布雷） |

#### 典型应用场景

**1. 闪避优先级模式（短按 & 连续）**
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space"]
  }
}
```
行为逻辑：
```
按下 → 监听捕获 → 注入 'space' (high) → 立即执行
保持 → 标记优先级激活 → 其它技能过滤
释放 → 注入 'up_space' → 状态复位 → 技能恢复
```

**2. 布雷/右键蓄力技能保护**
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["right_mouse"]
  }
}
```
保护机制：
- **即时点按**：点一下立即注入 right_mouse（不被吞）
- **持续按压**：保持期间其它技能冻结
- **释放控制**：`up_right_mouse` 可触发可选"后摇缓冲"策略

**3. 复合优先级模式（多按键并行）**
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space", "right_mouse", "ctrl"]
  }
}
```
智能逻辑：
- **集合语义**：优先级状态 = 当前按下优先级按键集合是否非空
- **并发无冲突**：多个按键各自生成 press / up 事件
- **部分释放不解锁**：直到集合清空才恢复技能

### 按键名称标准化
```python
def _normalize_key_name(self, key: str) -> str:
    """统一按键名称格式"""
    key_mapping = {
        'leftmouse': 'left_mouse',
        'rightmouse': 'right_mouse',
        'spacebar': 'space',
        'control': 'ctrl',
        'return': 'enter',
        'escape': 'esc'
    }
    normalized = key.lower().strip()
    return key_mapping.get(normalized, normalized)
```

---

## �🎮 传统优先级按键监控系统（向前兼容）

### 概述
优先级按键监控系统通过实时监听键盘和鼠标输入，实现智能的技能执行控制。当玩家按下指定的优先级按键（如闪避键、技能键）时，系统会暂停普通技能的执行，确保优先级操作不被打断。

### 核心机制

#### 实时按键监听
```python
class InputHandler:
    def _start_priority_listeners(self):
        """启动键盘和鼠标监听器"""
        self._keyboard_listener = KeyboardListener(
            on_press=self._on_key_press,
            on_release=self._on_key_release
        )
        self._mouse_listener = MouseListener(
            on_click=self._on_mouse_click
        )

    def _on_key_press(self, key):
        """键盘按下事件处理"""
        key_name = self._get_key_name(key)
        if key_name in self._priority_keys_config:
            self._priority_keys_pressed.add(key_name)
            LOG_INFO(f"[优先级模式] {key_name} 按下 - 技能暂停")

    def is_priority_mode_active(self) -> bool:
        """检查是否有优先级按键正在按下"""
        return self._priority_mode_enabled and bool(self._priority_keys_pressed)
```

#### 技能执行过滤
```python
def execute_skill_normal(self, key: str):
    """执行普通技能按键"""
    if not key:
        return

    # 🎯 优先级模式检查：有优先级按键按下时技能不响应
    if self.is_priority_mode_active():
        active_keys = ", ".join(self.get_active_priority_keys())
        LOG_INFO(f"[优先级模式] 技能 {key} 被跳过（优先级按键: {active_keys}）")
        return

    self._key_queue.put(key, priority='normal', block=False)
```

### 配置系统

#### 优先级按键配置
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space", "right_mouse", "ctrl"],
    "delay_ms": 50
  }
}
```

#### 技能序列配置
```json
{
  "skill_config": {
    "火球术": {
      "enabled": true,
      "key": "delay50,q",
      "alt_key": "delay100,shift+q",
      "timer": 1500,
      "priority": false
    }
  }
}
```

#### UI配置界面
- **启用开关**：控制整个优先级按键系统
- **按键列表**：可视化管理优先级按键
- **延迟保护**：配置技能前摇保护时间（毫秒）
- **序列输入**：支持技能按键的复杂序列配置
- **预设模式**：
  - 闪避模式：`["space"]`
  - 布雷模式：`["right_mouse"]`
  - 战斗模式：`["space", "right_mouse"]`

### 应用场景

#### 1. 闪避优先级
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space"]
  }
}
```
- **场景**：玩家按住空格键进行闪避时
- **行为**：暂停所有普通技能执行，避免前后摇影响移动
- **恢复**：释放空格键后恢复正常技能执行

#### 2. 技能连发保护
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["right_mouse"]
  }
}
```
- **场景**：使用右键技能（如布雷）时
- **行为**：防止其他技能打断当前技能的释放
- **优势**：确保重要技能的完整释放

#### 3. 组合按键支持
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space", "right_mouse", "ctrl", "shift"]
  }
}
```
- **灵活配置**：支持多种按键组合
- **标准化处理**：自动处理按键名称变体（如 `spacebar` → `space`）

### 技术优势

#### 异步监听
- **性能优化**：使用独立的监听线程，不影响主线程
- **实时响应**：毫秒级按键状态检测
- **资源管理**：完善的监听器生命周期管理

#### 智能过滤
- **精确控制**：只过滤普通技能，紧急操作（如HP药剂）不受影响
- **状态感知**：实时检测按键按下/释放状态
- **日志友好**：详细的状态变化记录

#### 按键标准化
```python
def _normalize_key_name(self, key: str) -> str:
    """标准化按键名称，避免大小写和格式问题"""
    key_mapping = {
        'spacebar': 'space',
        'leftmouse': 'left_mouse',
        'rightmouse': 'right_mouse',
        # ... 更多映射
    }
    return key_mapping.get(normalized, normalized)
```

## 🚀 按键序列与延迟系统

### 序列语法支持

项目现已支持高级按键序列功能，允许在技能配置中使用复杂的时间控制。

#### 基本语法
```
delay50,q          # 延迟50ms后按q键
q,delay100,w       # 按q键，延迟100ms，按w键
delay200           # 单纯延迟200ms
```

#### 支持场景
- **技能前摇保护**：`delay50,q` - 等待技能动画完成后释放下一个技能
- **连招控制**：`q,delay100,w,delay50,e` - 精确控制技能释放时机
- **动画等待**：避免技能被打断或重叠

### 技能配置界面

#### 按键输入字段
在技能配置界面的**主要按键**和**辅助按键**字段中，现在支持：

```
单个按键：    q, w, e, r
延迟指令：    delay50, delay100
按键序列：    delay50,q 或 q,delay100,w
```

**UI提示信息**：
- 字段宽度已优化以容纳序列输入
- 悬停提示显示完整的语法说明
- 支持任意长度的序列组合

### 优先级延迟保护

#### 功能概述
为防止技能释放被意外打断，系统提供可配置的延迟保护机制。

#### 配置界面
在**优先级按键**标签页中：
- **延迟保护**：毫秒级延迟时间配置
- **默认值**：50ms（适合大多数游戏场景）
- **作用说明**：技能前摇保护，避免动画被打断

```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space", "right_mouse"],
    "delay_ms": 50
  }
}
```

### 队列处理机制

#### 序列解析
```python
def execute_skill_normal(self, key: str):
    """执行普通技能按键 - 支持序列 delay50,q"""
    if ',' in key:
        key_sequence = [k.strip() for k in key.split(',') if k.strip()]
        for individual_key in key_sequence:
            self._key_queue.put(individual_key, priority='normal')
```

#### 去重逻辑
- **整体序列去重**：`delay50,q` 作为完整序列进行去重判断
- **智能清理**：序列执行完成后自动清理跟踪状态
- **状态一致性**：确保队列状态与跟踪集合同步

#### 延迟处理
```python
# 队列处理器中的延迟逻辑
if key_lower.startswith("delay"):
    delay_ms = int(key_lower[5:])
    if self._stop_event.wait(delay_ms / 1000.0):
        break
```

### 应用实例

#### 1. 技能连招保护
```json
{
  "skill_name": "火球连击",
  "key": "delay100,q,delay200,w",
  "trigger_mode": 0,
  "timer": 2000
}
```
- **场景**：火球术需要100ms前摇，连击需要200ms间隔
- **效果**：确保技能按正确顺序和时机释放

#### 2. 辅助技能时机控制
```json
{
  "skill_name": "治疗序列",
  "key": "delay50,h",
  "alt_key": "delay100,shift+h",
  "priority": true
}
```
- **主技能**：普通治疗，50ms延迟保护
- **辅助技能**：强化治疗，100ms延迟+组合键

#### 3. 复杂宏命令
```
技能栏快捷键：delay50,1,delay200,2,delay100,3
```
- **多技能连发**：按顺序释放1、2、3号技能
- **时机控制**：每个技能间留出适当的执行时间

### 最佳实践

#### 1. 按键选择原则
- **高频操作**：选择常用的移动/闪避按键
- **重要技能**：选择需要完整释放的关键技能按键
- **避免冲突**：不要将技能按键设为优先级按键

#### 2. 配置建议
```json
{
  "priority_keys": {
    "enabled": true,
    "keys": ["space", "right_mouse"],
    "description": "闪避+右键技能优先级"
  }
}
```

#### 3. 调试技巧
- **状态监控**：查看日志中的优先级模式激活记录
- **性能检查**：确认监听器正常运行且无性能影响
- **按键测试**：逐个测试配置的按键是否正确识别

---

## 💊 智能药剂系统

### 概述
采用先进的HSV双色检测算法，支持正常/中毒状态智能识别，实现精确的HP/MP检测和自动喂药功能。新版本增加了圆形检测技术和自动球体识别功能，提供更准确的资源状态检测。

### 三层委托架构

#### 第1层：SkillManager (调度层)
```python
# 通过UnifiedScheduler按固定间隔启动资源检查任务
def schedule_resource_check():
    scheduler.add_task("resource_check", 200, self.check_resources)
```

#### 第2层：ResourceManager (业务逻辑层)
```python
class ResourceManager:
    def check_hp_potion(self, frame):
        if not self._is_hp_cooldown_ready():
            return False
        
        current_percentage = self._detect_hp_percentage(frame)
        if current_percentage < self.hp_threshold:
            self._execute_hp_potion()
            return True
        return False
```

#### 第3层：BorderFrameManager (检测层)
```python
def _compare_resource_hsv(self, frame, template_hsv, tolerance):
    """HSV模板匹配，处理色相环形特性"""
    # 智能HSV颜色空间检测
    h_diff = min(abs(h1 - h2), 360 - abs(h1 - h2))
    # 计算匹配百分比
```

### HSV双色检测技术

#### 核心优势
- **光照适应性**：HSV颜色空间对光照变化不敏感
- **状态感知**：自动识别正常/中毒/异常状态的颜色变化
- **环形处理**：正确处理色相的360度环形特性

#### 矩形检测模式
```json
{
  "hp_config": {
    "enabled": true,
    "key": "1",
    "threshold": 50,
    "region_x1": 136,
    "region_y1": 910,
    "region_x2": 213,
    "region_y2": 1004,
    "colors": [
      {
        "name": "Normal HP",
        "target_h": 157,
        "target_s": 75,
        "target_v": 29,
        "tolerance_h": 5,
        "tolerance_s": 20,
        "tolerance_v": 20
      }
    ]
  }
}
```

### 圆形检测技术

#### 霍夫圆变换自动识别
```python
def auto_detect_orbs(self) -> Dict[str, Dict[str, Any]]:
    """自动检测游戏中的血量和蓝量球体"""
    # 1. 截取全屏图像
    frame = self.border_frame_manager.capture_screen_for_reroll()

    # 2. 霍夫圆变换检测
    circles = cv2.HoughCircles(
        gray_blurred,
        cv2.HOUGH_GRADIENT,
        dp=1.2,
        minDist=100,
        param1=50,
        param2=30,
        minRadius=20,
        maxRadius=80
    )

    # 3. 筛选底部区域的圆形
    bottom_circles = []
    for circle in detected_circles:
        x, y, r = circle
        if y > frame.shape[0] * 0.7:  # 底部区域
            bottom_circles.append((x, y, r))

    # 4. 按x坐标排序，返回HP和MP球体信息
    return {
        "hp": {"center_x": hp_x, "center_y": hp_y, "radius": hp_r},
        "mp": {"center_x": mp_x, "center_y": mp_y, "radius": mp_r}
    }
```

#### 半圆分析算法 (规避UI干扰)
```python
def compare_resource_circle(self, frame, center_x, center_y, radius, resource_type, threshold):
    """使用半圆形蒙版检测资源状态，以避免UI干扰"""
    # 1. 创建一个完整的圆形蒙版
    circular_mask = np.zeros((radius * 2, radius * 2), dtype=np.uint8)
    cv2.circle(circular_mask, (radius, radius), radius, 255, -1)

    # 2. 创建一个只覆盖一半区域的矩形蒙版
    half_mask = np.zeros_like(circular_mask)
    if resource_type == 'hp':  # 血球，只分析右半边
        cv2.rectangle(half_mask, (width // 2, 0), (width, height), 255, -1)
    elif resource_type == 'mp':  # 蓝球，只分析左半边
        cv2.rectangle(half_mask, (0, 0), (width // 2, height), 255, -1)
    
    # 3. 将两个蒙版相与，得到最终的半圆形蒙版
    final_mask = cv2.bitwise_and(circular_mask, half_mask)

    # 4. 应用蒙版并进行HSV匹配
    # ...

    # 5. 基于半圆蒙版的面积计算匹配百分比
    total_pixels = np.count_nonzero(final_mask)
    # ...
```

#### 圆形配置示例
```json
{
  "hp_config": {
    "enabled": true,
    "key": "1",
    "threshold": 50,
    "center_x": 175,
    "center_y": 957,
    "radius": 39,
    "colors": [
      {
        "name": "Circular HP Detection",
        "target_h": 157,
        "target_s": 75,
        "target_v": 29,
        "tolerance_h": 5,
        "tolerance_s": 20,
        "tolerance_v": 20
      }
    ]
  }
}
```

### 检测模式对比

| 特性 | 矩形检测 | 圆形检测 |
|------|----------|----------|
| **精确度** | 中等（包含背景像素） | 高（只检测球体区域） |
| **配置方式** | 手动选择区域 | 自动识别或手动配置 |
| **适用场景** | 规则矩形UI | 圆形球体UI |
| **抗干扰性** | 一般 | 优秀 |
| **配置复杂度** | 简单 | 中等 |

### UI配置界面

#### 检测区域设置
- **选择区域按钮**：手动选择矩形检测区域
- **Detect Orbs按钮**：自动识别圆形球体
- **坐标输入框**：支持矩形(x1,y1,x2,y2)和圆形(x,y,r)格式
- **容差设置**：HSV三维容差配置

#### 颜色分析工具
- **单点取色**：精确拾取特定像素颜色
- **区域取色**：分析区域内颜色分布并自动计算容差
- **多颜色配置**：支持配置多种颜色状态（如正常/中毒）

### 内部冷却机制
```python
class ResourceManager:
    def __init__(self):
        self._last_hp_use = 0
        self._last_mp_use = 0
        self._hp_cooldown = 5000  # 5秒冷却
        self._mp_cooldown = 8000  # 8秒冷却
    
    def _is_hp_cooldown_ready(self):
        return time.time() - self._last_hp_use > self._hp_cooldown / 1000
```

---

## 🔨 装备洗练系统

### 概述
独立的F7热键控制模块，采用三状态识别机制，结合PaddleOCR文字识别技术，实现精确的词缀检测和自动洗练操作。

### 三状态识别机制

#### 状态1：未洗练状态
- **特征**：装备未进行任何洗练操作
- **识别**：通过特定UI元素的颜色和位置识别
- **操作**：点击开始洗练按钮

#### 状态2：洗练进行中
- **特征**：正在进行洗练，界面显示进度或动画
- **识别**：检测洗练进度指示器
- **操作**：等待洗练完成

#### 状态3：洗练完成
- **特征**：洗练完成，显示新词缀结果
- **识别**：检测完成状态的UI特征
- **操作**：进行OCR识别，决策是否保留

### PaddleOCR集成

#### 引擎配置
```python
from paddleocr import PaddleOCR

ocr = PaddleOCR(
    use_angle_cls=True,      # 启用角度分类
    lang='ch',               # 中文识别
    use_gpu=False,           # CPU模式，兼容性更好
    show_log=False,          # 禁用详细日志
    det_db_score_mode='slow' # 精确检测模式
)
```

#### 识别流程
```python
def recognize_affixes(self, image_region):
    # 1. 图像预处理
    processed_image = self._preprocess_image(image_region)
    
    # 2. OCR识别
    results = self.ocr.ocr(processed_image, cls=True)
    
    # 3. 文字提取和匹配
    detected_affixes = self._extract_text_from_results(results)
    
    # 4. 目标词缀匹配
    return self._match_target_affixes(detected_affixes)
```

### 配置示例
```json
{
  "affix_reroll": {
    "enabled": true,
    "max_attempts": 100,
    "target_affixes": ["暴击率", "暴击伤害", "攻击力"],
    "enchant_button": [500, 600],
    "replace_button": [600, 700],
    "close_button": [700, 100],
    "ocr_region": [400, 300, 200, 400]
  }
}
```

---

## 🗺️ 自动寻路系统

### 概述
专为随机生成地图设计，采用**相位相关位移跟踪**和**A*算法**，实现智能地图探索和精确路径规划。

### 核心技术架构

#### 第一阶段：地图解读与拼接

**1. 路径提取**
```python
def extract_paths(minimap_frame):
    """从小地图提取可通行路径"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    _, mask = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)
    
    # 形态学操作优化路径连通性
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    opened = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel)
    
    return opened
```

**2. 相位相关位移跟踪**
```python
def track_displacement(prev_frame, curr_frame):
    """计算地图移动的像素位移"""
    displacement, response = cv2.phaseCorrelate(prev_frame, curr_frame)
    confidence = response  # 置信度
    return displacement if confidence > 0.7 else None
```

**3. 全局地图拼接**
```python
class GlobalMapBuilder:
    def __init__(self):
        self.global_map = np.zeros((5000, 5000), dtype=np.uint8)
        self.player_pos = (2500, 2500)  # 中心起始点
    
    def update_global_map(self, current_paths, displacement):
        x, y = self.player_pos
        self.global_map[y:y+h, x:x+w] = cv2.add(
            self.global_map[y:y+h, x:x+w], current_paths
        )
```

#### 第二阶段：探索与路径规划

**1. "除草机"探索算法**
```python
class LawnmowerExplorer:
    """系统性地图探索算法"""
    def __init__(self):
        self.direction = "right"
        self.row_height = 50
        
    def get_next_move(self, current_pos, explored_map):
        if self._can_continue_current_direction():
            return self._get_direction_vector()
        else:
            self._move_to_next_row()
            self._reverse_direction()
            return self._get_direction_vector()
```

**2. A*寻路算法**
```python
class AStarPathfinder:
    def find_path(self, start, goal, obstacle_map):
        """A*算法寻找最优路径"""
        open_set = []
        heapq.heappush(open_set, (0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self._heuristic(start, goal)}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == goal:
                return self._reconstruct_path(came_from, current)
            
            for neighbor in self._get_neighbors(current):
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self._heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return []  # 无路径
```

### 双模式运行

#### 探索模式
- **目标**：发现地图中的所有可通行区域
- **策略**：使用"除草机"算法系统性覆盖
- **触发**：未发现目标时自动启用

#### 导航模式
- **目标**：从当前位置到特定目标的最短路径
- **策略**：使用A*算法计算最优路径
- **触发**：发现目标后自动切换

### 配置示例
```json
{
  "pathfinding": {
    "enabled": true,
    "minimap_region": [1670, 50, 200, 200],
    "player_icon_color": [255, 255, 255],
    "path_color_range": [[100, 150, 100], [130, 255, 200]],
    "exploration_step": 50,
    "confidence_threshold": 0.7,
    "max_exploration_time": 300
  }
}
```

---

## 🔄 模块协同工作

### 状态管理统一性
所有功能模块都遵循统一的状态机：
```
STOPPED ←→ READY ←→ RUNNING ←→ PAUSED
```

### 模式互斥机制
- **技能模式**：F8控制，处理技能循环和药剂检测
- **洗练模式**：F7控制，独立的装备词缀洗练
- **寻路模式**：F9控制，自动地图探索和导航

### 资源共享
- **屏幕捕获**：所有模块共享同一帧数据，避免重复捕获
- **输入队列**：统一的PriorityDeque处理所有输入操作
- **配置管理**：ConfigManager统一管理所有模块配置

### 事件通信
```python
# 模块间通过EventBus进行通信
event_bus.publish("skill:cooldown_ready", skill_name="fireball")
event_bus.publish("resource:hp_low", current_hp=30)
event_bus.publish("pathfinding:target_found", target_pos=(100, 200))
```

通过这种模块化和事件驱动的设计，pyahk实现了高度灵活和可扩展的游戏自动化功能。