# 04 配置与条件系统

## 概述

配置系统是pyahk的核心基础设施，提供灵活的JSON配置管理和强大的条件逻辑系统。支持热重载、配置验证和多配置文件管理，为复杂的游戏自动化需求提供精确的控制能力。

---

## 📋 配置管理架构

### ConfigManager 核心功能
```python
class ConfigManager:
    """统一配置管理器"""
    def __init__(self):
        self._configs = {}
        self._watchers = {}
        self._schema_validator = None
    
    def load_config(self, config_file: str) -> dict:
        """加载并验证配置文件"""
        
    def save_config(self, config_file: str, config_data: dict):
        """保存配置到文件"""
        
    def hot_reload(self, config_file: str):
        """热重载配置，无需重启程序"""
```

### 配置文件结构
```json
{
  "version": "1.0",
  "global": {
    "debug_mode": false,
    "capture_interval": 100,
    "log_level": "INFO"
  },
  "skills": [
    {
      "name": "主要技能",
      "key": "1",
      "trigger_mode": 1,
      "execute_condition": 2,
      "priority": true,
      "enabled": true
    }
  ],
  "potions": [
    {
      "name": "生命药剂",
      "key": "2",
      "hp_threshold": 70,
      "region": [136, 910, 213, 1004],
      "hsv_range": [[314, 65, 19], [324, 85, 39]],
      "cooldown": 5000,
      "enabled": true
    }
  ],
  "pathfinding": {
    "enabled": false,
    "minimap_region": [1670, 50, 200, 200],
    "exploration_mode": "systematic"
  },
  "affix_reroll": {
    "enabled": false,
    "target_affixes": ["暴击率", "暴击伤害"],
    "max_attempts": 100
  }
}
```

### 配置验证与类型检查
```python
from pydantic import BaseModel, Field
from typing import List, Optional, Tuple

class SkillConfig(BaseModel):
    name: str
    key: str
    trigger_mode: int = Field(ge=0, le=2)
    execute_condition: int = Field(ge=0, le=2)
    priority: bool = False
    enabled: bool = True
    interval: Optional[int] = Field(None, ge=50)
    cooldown_coords: Optional[List[int]] = None

class GlobalConfig(BaseModel):
    debug_mode: bool = False
    capture_interval: int = Field(100, ge=50, le=1000)
    log_level: str = Field("INFO", regex="^(DEBUG|INFO|WARNING|ERROR)$")
```

### 配置热重载机制
```python
class ConfigWatcher:
    """配置文件变化监控"""
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.file_watchers = {}
    
    def watch_config_file(self, config_file: str):
        """监控配置文件变化，自动重载"""
        from watchdog.observers import Observer
        from watchdog.events import FileSystemEventHandler
        
        class ConfigFileHandler(FileSystemEventHandler):
            def on_modified(self, event):
                if event.src_path.endswith('.json'):
                    self.config_manager.hot_reload(event.src_path)
```

---

## 🎯 条件系统详解

### 设计目标
- **简单可枚举**：使用整型枚举值 0/1/2 控制分支
- **扩展友好**：新增条件时只需增加枚举 + `_evaluate_condition` 分支
- **稳定防抖**：资源条件加入连续窗口，避免边界抖动

### 条件枚举概览

| 值 | 名称 | 语义 | 适用场景 |
|----|------|------|----------|
| 0 | 无条件 | 直接允许执行 | 普通循环技能 |
| 1 | BUFF 限制 | 仅当指定 Buff 不存在/失效时执行 | 维持类技能、需刷新状态 |
| 2 | 资源条件 | 资源达到阈值且在连续窗口内稳定 | 资源驱动爆发/消耗类 |

### 执行调用栈
```python
def _try_execute_skill(skill):
    """技能执行入口"""
    if not skill.enabled:
        return False
    
    if not self._check_execution_conditions(skill):
        return False
    
    return self._execute_skill_action(skill)

def _check_execution_conditions(skill):
    """条件检查分发器"""
    condition = skill.execute_condition
    
    if condition == 0:
        return True  # 无条件
    elif condition == 1:
        return self._evaluate_condition_buff(skill)
    elif condition == 2:
        return self._evaluate_condition_resource(skill)
    else:
        LOG_ERROR(f"未知的执行条件: {condition}")
        return False
```

### 无条件模式 (ExecuteCondition = 0)
```json
{
  "name": "基础攻击",
  "key": "1",
  "trigger_mode": 1,
  "execute_condition": 0,
  "cooldown_coords": [100, 50, 20, 20]
}
```
- **行为**：冷却就绪时直接执行主按键
- **适用**：无特殊限制的常规技能
- **优势**：简单直接，性能最高

### Buff限制模式 (ExecuteCondition = 1)
```json
{
  "name": "护盾技能",
  "key": "e",
  "trigger_mode": 1,
  "execute_condition": 1,
  "buff_coords": [200, 100, 30, 30],
  "buff_color": [100, 150, 200],
  "buff_tolerance": 20
}
```

#### 检测逻辑
```python
def _evaluate_condition_buff(self, skill):
    """Buff存在性检测"""
    if not skill.buff_coords:
        return True
    
    frame = self.border_manager.get_current_frame()
    if frame is None:
        return False
    
    x, y, w, h = skill.buff_coords
    roi = frame[y:y+h, x:x+w]
    
    # RGB颜色匹配检测Buff图标
    target_color = skill.buff_color
    tolerance = skill.buff_tolerance or 20
    
    similarity = self._calculate_color_similarity(roi, target_color)
    buff_exists = similarity > 0.8  # 80%相似度阈值
    
    # Buff存在时不执行，不存在时执行
    return not buff_exists
```

#### 应用场景
- **护盾技能**：护盾消失时自动重新施放
- **增益BUFF**：BUFF到期时自动刷新
- **状态维持**：确保关键状态持续存在

### 资源条件模式 (ExecuteCondition = 2)
```json
{
  "name": "消耗技能",
  "key": "r",
  "trigger_mode": 1,
  "execute_condition": 2,
  "resource_coords": [50, 950, 200, 20],
  "resource_threshold": 70,
  "resource_type": "mp",
  "alt_key": "t",
  "continuity_window": 3,
  "continuity_threshold": 2
}
```

#### 连续性检测机制
```python
class ResourceContinuityChecker:
    """资源条件连续性检测器"""
    def __init__(self):
        self._resource_history = {}  # skill_name -> deque
    
    def check_resource_continuity(self, skill_name, is_sufficient, window_size=3, threshold_count=2):
        """检查资源条件是否在连续窗口内稳定满足"""
        history = self._resource_history.setdefault(skill_name, deque(maxlen=window_size))
        history.append(is_sufficient)
        
        # 要求最近N次检查中有M次满足条件
        satisfied_count = sum(history)
        return satisfied_count >= threshold_count and len(history) >= window_size
```

#### 资源检测逻辑
```python
def _evaluate_condition_resource(self, skill):
    """资源充足性检测"""
    if not skill.resource_coords:
        return True
    
    # 1. 检测当前资源百分比
    current_percentage = self._detect_resource_percentage(skill)
    if current_percentage is None:
        return False
    
    # 2. 判断是否满足阈值
    threshold = skill.resource_threshold or 50
    is_sufficient = current_percentage >= threshold
    
    # 3. 连续性检查
    window_size = skill.continuity_window or 3
    threshold_count = skill.continuity_threshold or 2
    
    is_stable = self.continuity_checker.check_resource_continuity(
        skill.name, is_sufficient, window_size, threshold_count
    )
    
    if is_stable:
        # 资源充足且稳定，执行主按键
        self._execute_key(skill.key)
        return True
    elif skill.alt_key:
        # 资源不足，执行备用按键
        self._execute_key(skill.alt_key)
        return True
    
    return False
```

#### 双按键策略
- **主按键**：资源充足时使用的高消耗技能
- **备用按键**：资源不足时使用的低消耗替代技能
- **智能切换**：根据实时资源状态自动选择合适的技能

---

## 🔧 高级配置技巧

### 1. 技能优先级配置
```json
{
  "skills": [
    {
      "name": "紧急治疗",
      "priority": true,
      "execute_condition": 2,
      "resource_type": "hp",
      "resource_threshold": 30
    },
    {
      "name": "主要输出",
      "priority": true,
      "execute_condition": 1,
      "buff_coords": [300, 100, 40, 40]
    },
    {
      "name": "辅助技能",
      "priority": false,
      "execute_condition": 0
    }
  ]
}
```

### 2. 条件组合策略
```json
{
  "name": "复合条件技能",
  "key": "q",
  "execute_condition": 2,
  "resource_coords": [50, 950, 200, 20],
  "resource_threshold": 80,
  "additional_conditions": {
    "buff_check": {
      "coords": [200, 100, 30, 30],
      "required": false
    },
    "enemy_presence": {
      "coords": [500, 400, 100, 100],
      "required": true
    }
  }
}
```

### 3. 环境适配配置
```json
{
  "profiles": {
    "1920x1080": {
      "hp_region": [136, 910, 213, 1004],
      "mp_region": [136, 870, 213, 894],
      "skill_size": 20
    },
    "2560x1440": {
      "hp_region": [181, 1213, 284, 1339],
      "mp_region": [181, 1160, 284, 1192],
      "skill_size": 27
    }
  }
}
```

### 4. 调试配置
```json
{
  "debug": {
    "enabled": true,
    "log_conditions": true,
    "log_resource_detection": true,
    "save_detection_frames": false,
    "condition_log_interval": 1000
  }
}
```

---

## 🔄 配置最佳实践

### 1. 渐进式配置
```python
# 第一阶段：基础技能配置
basic_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 0, "execute_condition": 0}
]

# 第二阶段：添加冷却检测
advanced_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 1, "execute_condition": 0,
     "cooldown_coords": [100, 50, 20, 20]}
]

# 第三阶段：添加复杂条件
expert_skills = [
    {"name": "攻击", "key": "1", "trigger_mode": 1, "execute_condition": 2,
     "cooldown_coords": [100, 50, 20, 20],
     "resource_coords": [50, 950, 200, 20],
     "resource_threshold": 70}
]
```

### 2. 配置模板
```json
{
  "templates": {
    "basic_skill": {
      "trigger_mode": 1,
      "execute_condition": 0,
      "priority": false,
      "enabled": true
    },
    "resource_skill": {
      "trigger_mode": 1,
      "execute_condition": 2,
      "resource_threshold": 70,
      "continuity_window": 3,
      "continuity_threshold": 2
    },
    "buff_skill": {
      "trigger_mode": 1,
      "execute_condition": 1,
      "buff_tolerance": 20
    }
  }
}
```

### 3. 配置验证
```python
def validate_skill_config(skill_config):
    """配置验证函数"""
    errors = []
    
    # 必需字段检查
    required_fields = ["name", "key", "trigger_mode"]
    for field in required_fields:
        if field not in skill_config:
            errors.append(f"缺少必需字段: {field}")
    
    # 条件特定验证
    if skill_config.get("execute_condition") == 2:
        if not skill_config.get("resource_coords"):
            errors.append("资源条件模式需要配置resource_coords")
    
    return errors
```

通过这套完整的配置和条件系统，pyahk能够适应各种复杂的游戏场景和用户需求，提供精确的自动化控制能力。