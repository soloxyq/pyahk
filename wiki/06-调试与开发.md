# 06 è°ƒè¯•ä¸å¼€å‘

## æ¦‚è¿°

æœ¬ç« ä¸ºå¼€å‘è€…æä¾›å®Œæ•´çš„è°ƒè¯•å·¥å…·ã€å¼€å‘ç¯å¢ƒé…ç½®å’Œä»£ç è´¡çŒ®æŒ‡å—ã€‚æ¶µç›–è°ƒè¯•æ¨¡å¼ä½¿ç”¨ã€æ€§èƒ½åˆ†æå·¥å…·ã€ä»£ç æ¶æ„ç†è§£å’Œæ‰©å±•å¼€å‘è§„èŒƒã€‚

---

## ğŸ” è°ƒè¯•æ¨¡å¼è¯¦è§£

### è°ƒè¯•æ¨¡å¼æ¿€æ´»

#### é€šè¿‡é…ç½®æ–‡ä»¶æ¿€æ´»
```json
{
  "debug": {
    "enabled": true,
    "show_fps": true,
    "show_detection_overlay": true,
    "show_target_regions": true,
    "save_debug_frames": false,
    "log_level": "DEBUG"
  }
}
```

#### é€šè¿‡çƒ­é”®æ¿€æ´»
- **F7**: åˆ‡æ¢è°ƒè¯•æ˜¾ç¤ºå¼€å…³
- **Ctrl+F7**: ä¿å­˜å½“å‰è°ƒè¯•å¸§
- **Shift+F7**: åˆ‡æ¢æ€§èƒ½ç»Ÿè®¡æ˜¾ç¤º

### è°ƒè¯•OSDçª—å£

#### åŸºç¡€ä¿¡æ¯æ˜¾ç¤º
```python
# è°ƒè¯•ä¿¡æ¯å†…å®¹
{
    "çŠ¶æ€": "RUNNING/STOPPED/PAUSED",
    "FPS": "60.2",
    "æ£€æµ‹å»¶è¿Ÿ": "12.5ms", 
    "é˜Ÿåˆ—é•¿åº¦": "3",
    "å†…å­˜ä½¿ç”¨": "245MB",
    "æ´»è·ƒçº¿ç¨‹": "8"
}
```

#### é«˜çº§è¯Šæ–­ä¿¡æ¯
```python
# æ€§èƒ½åˆ†ææ•°æ®
{
    "å›¾åƒæ•è·": {
        "æ•è·é—´éš”": "16.7ms",
        "å¤„ç†æ—¶é—´": "2.1ms",
        "ç¼“å­˜å‘½ä¸­ç‡": "92%"
    },
    "æ¨¡æ¿åŒ¹é…": {
        "HPæ£€æµ‹": "0.8ms",
        "æŠ€èƒ½æ£€æµ‹": "1.2ms", 
        "å¯»è·¯æ£€æµ‹": "3.5ms"
    },
    "è¾“å…¥é˜Ÿåˆ—": {
        "å¾…å¤„ç†": 2,
        "é«˜ä¼˜å…ˆçº§": 0,
        "å¹³å‡å»¶è¿Ÿ": "5ms"
    }
}
```

### å¯è§†åŒ–è°ƒè¯•

#### æ£€æµ‹åŒºåŸŸè¦†ç›–å±‚
```python
# æŠ€èƒ½æ£€æµ‹åŒºåŸŸæ˜¾ç¤º
skill_regions = {
    "æŠ€èƒ½1": [778, 1018, 34, 34],    # ç»¿è‰²æ¡†
    "æŠ€èƒ½2": [826, 1018, 34, 34],    # è“è‰²æ¡†
    "å†·å´æ£€æµ‹": [778, 1000, 34, 18]  # çº¢è‰²æ¡†
}

# HP/MPæ¡æ˜¾ç¤º
resource_regions = {
    "HPæ¡": [136, 910, 213, 1004],   # çº¢è‰²è¦†ç›–
    "MPæ¡": [136, 870, 213, 894]     # è“è‰²è¦†ç›–
}
```

#### å¯»è·¯è·¯å¾„å¯è§†åŒ–
```python
# è·¯å¾„æ˜¾ç¤º
pathfinding_debug = {
    "èµ·ç‚¹": (current_x, current_y),      # ç»¿è‰²åœ†åœˆ
    "ç»ˆç‚¹": (target_x, target_y),        # çº¢è‰²åœ†åœˆ
    "è·¯å¾„": [(x1, y1), (x2, y2), ...],   # é»„è‰²çº¿æ¡
    "éšœç¢ç‰©": [rect1, rect2, ...],       # ç°è‰²çŸ©å½¢
    "ä¸‹ä¸€æ­¥": (next_x, next_y)           # æ©™è‰²ç®­å¤´
}
```

### è°ƒè¯•æ—¥å¿—ç³»ç»Ÿ

#### æ—¥å¿—çº§åˆ«é…ç½®
```python
import logging

# æ—¥å¿—çº§åˆ«å±‚æ¬¡
LOGGING_LEVELS = {
    "TRACE": 5,     # æœ€è¯¦ç»†ï¼ŒåŒ…å«æ‰€æœ‰æ“ä½œ
    "DEBUG": 10,    # è°ƒè¯•ä¿¡æ¯ï¼ŒåŒ…å«å‡½æ•°è°ƒç”¨
    "INFO": 20,     # ä¸€èˆ¬ä¿¡æ¯ï¼ŒçŠ¶æ€å˜åŒ–
    "WARNING": 30,  # è­¦å‘Šä¿¡æ¯ï¼Œæ½œåœ¨é—®é¢˜
    "ERROR": 40,    # é”™è¯¯ä¿¡æ¯ï¼ŒåŠŸèƒ½å¼‚å¸¸
    "CRITICAL": 50  # ä¸¥é‡é”™è¯¯ï¼Œç³»ç»Ÿå´©æºƒ
}
```

#### æ¨¡å—åŒ–æ—¥å¿—è®°å½•
```python
# å„æ¨¡å—ç‹¬ç«‹æ—¥å¿—
loggers = {
    "core.event_bus": logging.getLogger("pyahk.core.event_bus"),
    "core.scheduler": logging.getLogger("pyahk.core.scheduler"),
    "core.input_handler": logging.getLogger("pyahk.core.input_handler"),
    "utils.capture": logging.getLogger("pyahk.utils.capture"),
    "skill_manager": logging.getLogger("pyahk.skill_manager"),
    "resource_manager": logging.getLogger("pyahk.resource_manager")
}

# ä½¿ç”¨ç¤ºä¾‹
skill_logger = logging.getLogger("pyahk.skill_manager")
skill_logger.debug(f"æ£€æµ‹æŠ€èƒ½å†·å´: {skill_name}, ç»“æœ: {is_ready}")
```

#### é«˜é¢‘æ—¥å¿—æŠ‘åˆ¶
```python
class ThrottledLogger:
    """é¢‘ç‡é™åˆ¶çš„æ—¥å¿—è®°å½•å™¨"""
    
    def __init__(self, logger, min_interval=1.0):
        self.logger = logger
        self.min_interval = min_interval
        self.last_log_time = {}
    
    def throttled_log(self, level, msg, throttle_key=None):
        """é™é¢‘æ—¥å¿—è®°å½•"""
        key = throttle_key or msg
        current_time = time.time()
        
        if key not in self.last_log_time or \
           current_time - self.last_log_time[key] >= self.min_interval:
            self.logger.log(level, msg)
            self.last_log_time[key] = current_time

# ä½¿ç”¨ç¤ºä¾‹
throttled_logger = ThrottledLogger(skill_logger, min_interval=5.0)
throttled_logger.throttled_log(logging.DEBUG, "æŠ€èƒ½æ£€æµ‹å¾ªç¯", "skill_detection")
```

---

## ğŸ› ï¸ å¼€å‘ç¯å¢ƒé…ç½®

### Pythonç¯å¢ƒè¦æ±‚

#### ç‰ˆæœ¬è¦æ±‚
```bash
# Pythonç‰ˆæœ¬
Python >= 3.8

# æ ¸å¿ƒä¾èµ–
opencv-python >= 4.8.0
numpy >= 1.21.0
Pillow >= 9.0.0
PyQt5 >= 5.15.0
psutil >= 5.8.0
```

#### å¼€å‘ä¾èµ–å®‰è£…
```bash
# åŸºç¡€å¼€å‘ç¯å¢ƒ
pip install -r requirements.txt

# å¼€å‘å·¥å…·
pip install pytest pytest-cov black isort flake8 mypy

# æ–‡æ¡£å·¥å…·
pip install sphinx sphinx-rtd-theme

# è°ƒè¯•å·¥å…·
pip install memory-profiler line-profiler py-spy
```

### C++æ‰©å±•ç¼–è¯‘

#### Windowsç¯å¢ƒï¼ˆæ¨èï¼‰
```bash
# å®‰è£… Visual Studio Build Tools
# æˆ– Visual Studio Community 2019/2022

# å®‰è£… CMake
winget install Kitware.CMake

# ç¼–è¯‘C++æ‰©å±•
cd native_capture
mkdir build
cd build
cmake ..
cmake --build . --config Release

# éªŒè¯ç¼–è¯‘ç»“æœ
ls Release/capture_lib.dll
```

#### äº¤å‰ç¼–è¯‘è®¾ç½®
```cmake
# CMakeLists.txt é…ç½®
cmake_minimum_required(VERSION 3.16)

# å¹³å°ç‰¹å®šé…ç½®
if(WIN32)
    # Windows DXGI æ”¯æŒ
    target_link_libraries(capture_lib dxgi d3d11)
elseif(UNIX)
    # Linux X11 æ”¯æŒ (å¤‡ç”¨æ–¹æ¡ˆ)
    find_package(X11 REQUIRED)
    target_link_libraries(capture_lib ${X11_LIBRARIES})
endif()
```

### IDEé…ç½®å»ºè®®

#### VS Codeé…ç½®
```json
// .vscode/settings.json
{
    "python.defaultInterpreterPath": "./venv/Scripts/python.exe",
    "python.linting.enabled": true,
    "python.linting.flake8Enabled": true,
    "python.formatting.provider": "black",
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": ["tests/"],
    "files.exclude": {
        "**/__pycache__": true,
        "**/build": true,
        "**/*.pyc": true
    }
}
```

#### PyCharmé…ç½®
```python
# Run/Debug Configuration
# Script: main.py
# Parameters: --debug --config=dev_config.json
# Working directory: /path/to/pyahk
# Environment variables:
#   PYTHONPATH=/path/to/pyahk
#   PYAHK_LOG_LEVEL=DEBUG
```

---

## ğŸ§ª æµ‹è¯•æ¡†æ¶

### å•å…ƒæµ‹è¯•ç»“æ„

#### æµ‹è¯•ç›®å½•ç»„ç»‡
```
tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py                 # pytesté…ç½®
â”œâ”€â”€ fixtures/                   # æµ‹è¯•æ•°æ®
â”‚   â”œâ”€â”€ test_images/
â”‚   â”œâ”€â”€ mock_configs/
â”‚   â””â”€â”€ sample_frames/
â”œâ”€â”€ unit/                       # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ test_event_bus.py
â”‚   â”œâ”€â”€ test_scheduler.py
â”‚   â”œâ”€â”€ test_input_handler.py
â”‚   â””â”€â”€ test_border_manager.py
â”œâ”€â”€ integration/                # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ test_skill_system.py
â”‚   â”œâ”€â”€ test_resource_system.py
â”‚   â””â”€â”€ test_full_workflow.py
â””â”€â”€ performance/                # æ€§èƒ½æµ‹è¯•
    â”œâ”€â”€ test_capture_performance.py
    â””â”€â”€ test_memory_usage.py
```

#### æ ¸å¿ƒæµ‹è¯•ç¤ºä¾‹
```python
# tests/unit/test_event_bus.py
import pytest
from torchlight_assistant.core.event_bus import EventBus

class TestEventBus:
    def setup_method(self):
        """æ¯ä¸ªæµ‹è¯•å‰é‡ç½®EventBus"""
        self.event_bus = EventBus()
    
    def test_subscribe_and_publish(self):
        """æµ‹è¯•åŸºç¡€è®¢é˜…å‘å¸ƒåŠŸèƒ½"""
        received_data = []
        
        def handler(data):
            received_data.append(data)
        
        self.event_bus.subscribe("test:event", handler)
        self.event_bus.publish("test:event", "test_data")
        
        assert len(received_data) == 1
        assert received_data[0] == "test_data"
    
    def test_unsubscribe(self):
        """æµ‹è¯•å–æ¶ˆè®¢é˜…"""
        call_count = 0
        
        def handler(data):
            nonlocal call_count
            call_count += 1
        
        self.event_bus.subscribe("test:event", handler)
        self.event_bus.publish("test:event", "data1")
        
        self.event_bus.unsubscribe("test:event", handler)
        self.event_bus.publish("test:event", "data2")
        
        assert call_count == 1

# tests/integration/test_skill_system.py
class TestSkillSystem:
    @pytest.fixture
    def mock_game_frame(self):
        """æ¨¡æ‹Ÿæ¸¸æˆç”»é¢"""
        import numpy as np
        frame = np.zeros((1080, 1920, 3), dtype=np.uint8)
        # æ¨¡æ‹ŸæŠ€èƒ½å›¾æ ‡
        frame[1018:1052, 778:812] = [100, 100, 255]  # è“è‰²æŠ€èƒ½å›¾æ ‡
        return frame
    
    def test_skill_detection(self, mock_game_frame):
        """æµ‹è¯•æŠ€èƒ½æ£€æµ‹åŠŸèƒ½"""
        from torchlight_assistant.core.skill_manager import SkillManager
        
        skill_manager = SkillManager()
        skill_config = {
            "name": "æµ‹è¯•æŠ€èƒ½",
            "key": "1",
            "coords": [778, 1018, 34, 34],
            "template_coords": [778, 1018, 20, 20]
        }
        
        result = skill_manager.check_skill_ready(mock_game_frame, skill_config)
        assert isinstance(result, bool)
```

### æ¨¡æ‹Ÿæµ‹è¯•ç¯å¢ƒ

#### å›¾åƒæ•°æ®æ¨¡æ‹Ÿ
```python
# tests/fixtures/image_generator.py
import numpy as np
import cv2

class MockImageGenerator:
    """æ¨¡æ‹Ÿå›¾åƒç”Ÿæˆå™¨"""
    
    @staticmethod
    def create_skill_icon(size=(34, 34), color=(100, 100, 255), ready=True):
        """åˆ›å»ºæ¨¡æ‹ŸæŠ€èƒ½å›¾æ ‡"""
        icon = np.full((*size, 3), color, dtype=np.uint8)
        
        if not ready:
            # æ·»åŠ ç°è‰²è’™ç‰ˆè¡¨ç¤ºå†·å´ä¸­
            overlay = np.full((*size, 3), (128, 128, 128), dtype=np.uint8)
            icon = cv2.addWeighted(icon, 0.3, overlay, 0.7, 0)
        
        return icon
    
    @staticmethod
    def create_hp_bar(width=213, height=94, percentage=80):
        """åˆ›å»ºæ¨¡æ‹ŸHPæ¡"""
        bar = np.zeros((height, width, 3), dtype=np.uint8)
        
        # ç»¿è‰²éƒ¨åˆ†è¡¨ç¤ºå½“å‰HP
        fill_width = int(width * percentage / 100)
        bar[:, :fill_width] = [0, 255, 0]  # ç»¿è‰²
        
        # çº¢è‰²éƒ¨åˆ†è¡¨ç¤ºæŸå¤±HP
        bar[:, fill_width:] = [0, 0, 255]  # çº¢è‰²
        
        return bar
```

### æ€§èƒ½æµ‹è¯•

#### æ•è·æ€§èƒ½æµ‹è¯•
```python
# tests/performance/test_capture_performance.py
import time
import pytest
from torchlight_assistant.utils.native_graphics_capture_manager import NativeGraphicsCaptureManager

class TestCapturePerformance:
    def test_capture_fps(self):
        """æµ‹è¯•æ•è·å¸§ç‡"""
        capture_manager = NativeGraphicsCaptureManager()
        capture_manager.initialize()
        
        frame_count = 0
        start_time = time.time()
        test_duration = 5.0  # æµ‹è¯•5ç§’
        
        while time.time() - start_time < test_duration:
            frame = capture_manager.get_latest_frame()
            if frame is not None:
                frame_count += 1
            time.sleep(0.001)  # 1msé—´éš”
        
        elapsed_time = time.time() - start_time
        fps = frame_count / elapsed_time
        
        print(f"æ•è·FPS: {fps:.2f}")
        assert fps >= 30  # è‡³å°‘30FPS
    
    def test_memory_usage(self):
        """æµ‹è¯•å†…å­˜ä½¿ç”¨"""
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        capture_manager = NativeGraphicsCaptureManager()
        capture_manager.initialize()
        
        # æ•è·1000å¸§
        for _ in range(1000):
            frame = capture_manager.get_latest_frame()
            if frame is not None:
                # æ¨¡æ‹Ÿå¤„ç†
                processed = frame[100:200, 100:200]
        
        gc.collect()
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory
        
        print(f"å†…å­˜å¢é•¿: {memory_increase:.2f}MB")
        assert memory_increase < 50  # å†…å­˜å¢é•¿ä¸è¶…è¿‡50MB
```

---

## ğŸ“Š æ€§èƒ½åˆ†æå·¥å…·

### å†…ç½®æ€§èƒ½ç›‘æ§

#### å®æ—¶æ€§èƒ½ç»Ÿè®¡
```python
class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""
    
    def __init__(self):
        self.metrics = {
            "capture_times": deque(maxlen=100),
            "process_times": deque(maxlen=100),
            "memory_usage": deque(maxlen=50),
            "cpu_usage": deque(maxlen=50)
        }
        self.last_update = time.time()
    
    def record_capture_time(self, duration):
        """è®°å½•æ•è·è€—æ—¶"""
        self.metrics["capture_times"].append(duration)
    
    def record_process_time(self, duration):
        """è®°å½•å¤„ç†è€—æ—¶"""
        self.metrics["process_times"].append(duration)
    
    def update_system_metrics(self):
        """æ›´æ–°ç³»ç»ŸæŒ‡æ ‡"""
        current_time = time.time()
        if current_time - self.last_update < 1.0:  # 1ç§’æ›´æ–°ä¸€æ¬¡
            return
        
        import psutil
        process = psutil.Process()
        
        # è®°å½•å†…å­˜ä½¿ç”¨
        memory_mb = process.memory_info().rss / 1024 / 1024
        self.metrics["memory_usage"].append(memory_mb)
        
        # è®°å½•CPUä½¿ç”¨ç‡
        cpu_percent = process.cpu_percent()
        self.metrics["cpu_usage"].append(cpu_percent)
        
        self.last_update = current_time
    
    def get_statistics(self):
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        stats = {}
        
        if self.metrics["capture_times"]:
            capture_times = list(self.metrics["capture_times"])
            stats["capture"] = {
                "avg_ms": np.mean(capture_times) * 1000,
                "max_ms": np.max(capture_times) * 1000,
                "fps": 1.0 / np.mean(capture_times) if capture_times else 0
            }
        
        if self.metrics["memory_usage"]:
            memory_usage = list(self.metrics["memory_usage"])
            stats["memory"] = {
                "current_mb": memory_usage[-1],
                "avg_mb": np.mean(memory_usage),
                "max_mb": np.max(memory_usage)
            }
        
        return stats
```

### å¤–éƒ¨åˆ†æå·¥å…·

#### ä½¿ç”¨py-spyè¿›è¡Œæ€§èƒ½åˆ†æ
```bash
# å®‰è£…py-spy
pip install py-spy

# å®æ—¶åˆ†æè¿è¡Œä¸­çš„pyahk
py-spy top --pid <pyahk_process_id>

# ç”Ÿæˆç«ç„°å›¾
py-spy record -o profile.svg --pid <pyahk_process_id> --duration 60

# åˆ†æç‰¹å®šå‡½æ•°
py-spy record -o profile.svg --pid <pyahk_process_id> --function
```

#### ä½¿ç”¨line_profilerè¯¦ç»†åˆ†æ
```python
# åœ¨éœ€è¦åˆ†æçš„å‡½æ•°ä¸Šæ·»åŠ è£…é¥°å™¨
@profile
def process_frame(self, frame):
    """å¤„ç†å¸§æ•°æ®"""
    # å‡½æ•°å®ç°
    pass

# è¿è¡Œåˆ†æ
kernprof -l -v main.py
```

#### å†…å­˜æ³„æ¼æ£€æµ‹
```python
# ä½¿ç”¨memory_profiler
from memory_profiler import profile

@profile
def capture_loop(self):
    """æ•è·å¾ªç¯å†…å­˜åˆ†æ"""
    for i in range(1000):
        frame = self.get_frame()
        self.process_frame(frame)

# ä½¿ç”¨tracemalloc
import tracemalloc

def start_memory_trace():
    """å¼€å§‹å†…å­˜è¿½è¸ª"""
    tracemalloc.start()

def take_memory_snapshot():
    """è·å–å†…å­˜å¿«ç…§"""
    snapshot = tracemalloc.take_snapshot()
    top_stats = snapshot.statistics('lineno')
    
    print("Top 10 memory consumers:")
    for stat in top_stats[:10]:
        print(stat)
```

---

## ğŸ”§ ä»£ç è´¡çŒ®æŒ‡å—

### å¼€å‘å·¥ä½œæµ

#### åˆ†æ”¯ç®¡ç†ç­–ç•¥
```bash
# ä¸»åˆ†æ”¯
main                    # ç¨³å®šå‘å¸ƒç‰ˆæœ¬
develop                 # å¼€å‘ä¸»åˆ†æ”¯

# åŠŸèƒ½åˆ†æ”¯
feature/new-skill-ai    # æ–°åŠŸèƒ½å¼€å‘
feature/performance-opt # æ€§èƒ½ä¼˜åŒ–
bugfix/memory-leak     # é—®é¢˜ä¿®å¤
hotfix/critical-crash  # ç´§æ€¥ä¿®å¤
```

#### æäº¤è§„èŒƒ
```bash
# æäº¤æ¶ˆæ¯æ ¼å¼
<type>(<scope>): <description>

# ç±»å‹è¯´æ˜
feat:     æ–°åŠŸèƒ½
fix:      é—®é¢˜ä¿®å¤
docs:     æ–‡æ¡£æ›´æ–°
style:    ä»£ç æ ¼å¼åŒ–
refactor: ä»£ç é‡æ„
test:     æµ‹è¯•ç›¸å…³
chore:    æ„å»º/å·¥å…·ç›¸å…³

# ç¤ºä¾‹
feat(skill): add AI-based skill timing optimization
fix(capture): resolve DXGI memory leak in long sessions
docs(api): update event bus documentation
```

### ä»£ç è§„èŒƒ

#### Pythonä»£ç é£æ ¼
```python
# ä½¿ç”¨Blackè¿›è¡Œæ ¼å¼åŒ–
black --line-length 88 torchlight_assistant/

# ä½¿ç”¨isortæ•´ç†å¯¼å…¥
isort torchlight_assistant/ --profile black

# ä½¿ç”¨flake8æ£€æŸ¥ä»£ç è´¨é‡
flake8 torchlight_assistant/ --max-line-length 88

# ä½¿ç”¨mypyè¿›è¡Œç±»å‹æ£€æŸ¥
mypy torchlight_assistant/ --ignore-missing-imports
```

#### æ–‡æ¡£å­—ç¬¦ä¸²è§„èŒƒ
```python
def process_skill_detection(
    self, 
    frame: np.ndarray, 
    skill_config: dict
) -> tuple[bool, float]:
    """æ£€æµ‹æŠ€èƒ½æ˜¯å¦å°±ç»ª
    
    Args:
        frame: æ¸¸æˆç”»é¢å¸§ï¼Œshapeä¸º(H, W, 3)çš„BGRå›¾åƒ
        skill_config: æŠ€èƒ½é…ç½®å­—å…¸ï¼ŒåŒ…å«åæ ‡å’Œæ¨¡æ¿ä¿¡æ¯
        
    Returns:
        tuple: (æ˜¯å¦å°±ç»ª, ç›¸ä¼¼åº¦åˆ†æ•°)
            - æ˜¯å¦å°±ç»ª: Trueè¡¨ç¤ºæŠ€èƒ½å¯ä»¥ä½¿ç”¨
            - ç›¸ä¼¼åº¦åˆ†æ•°: 0.0-1.0ä¹‹é—´çš„æ¨¡æ¿åŒ¹é…ç›¸ä¼¼åº¦
    
    Raises:
        ValueError: å½“frameä¸ºNoneæˆ–shapeä¸æ­£ç¡®æ—¶
        KeyError: å½“skill_configç¼ºå°‘å¿…è¦å­—æ®µæ—¶
        
    Example:
        >>> frame = capture_manager.get_latest_frame()
        >>> config = {"coords": [100, 100, 50, 50], "template": template}
        >>> ready, score = self.process_skill_detection(frame, config)
        >>> if ready and score > 0.8:
        ...     self.use_skill(config["key"])
    """
```

### æµ‹è¯•è¦æ±‚

#### æµ‹è¯•è¦†ç›–ç‡è¦æ±‚
```bash
# è¿è¡Œæµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
pytest --cov=torchlight_assistant --cov-report=html --cov-report=term

# è¦†ç›–ç‡è¦æ±‚
# æ–°åŠŸèƒ½: >= 90%
# æ ¸å¿ƒæ¨¡å—: >= 95%
# å·¥å…·å‡½æ•°: >= 85%
```

#### Pull Requestæ£€æŸ¥æ¸…å•
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] ä»£ç è¦†ç›–ç‡è¾¾æ ‡
- [ ] ä»£ç é£æ ¼æ£€æŸ¥é€šè¿‡
- [ ] æ–‡æ¡£å­—ç¬¦ä¸²å®Œæ•´
- [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
- [ ] å‘åå…¼å®¹æ€§éªŒè¯
- [ ] æ›´æ–°ç›¸å…³æ–‡æ¡£

é€šè¿‡å®Œå–„çš„è°ƒè¯•å·¥å…·å’Œå¼€å‘ç¯å¢ƒï¼Œå¼€å‘è€…å¯ä»¥é«˜æ•ˆåœ°è¿›è¡ŒåŠŸèƒ½å¼€å‘ã€é—®é¢˜è¯Šæ–­å’Œæ€§èƒ½ä¼˜åŒ–ï¼Œç¡®ä¿pyahké¡¹ç›®çš„æŒç»­å‘å±•å’Œç¨³å®šè¿è¡Œã€‚