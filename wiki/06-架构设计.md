# 架构设计

## 概述

pyahk采用现代化的分层架构和模块化设计，基于事件驱动模式构建。整个系统围绕**事件总线**进行组件间通信，通过**统一调度器**管理定时任务，使用**零拷贝屏幕捕获**技术实现高性能图像处理。

## 核心架构原则

### 1. 事件驱动架构
- **中央事件总线**：所有组件通过EventBus进行松耦合通信
- **发布/订阅模式**：支持异步事件处理和模块解耦
- **递归事件检测**：防止事件循环和死锁
- **线程安全**：支持多线程环境下的事件传递

### 2. 统一状态管理
- **标准状态机**：STOPPED → READY → RUNNING → PAUSED
- **状态转换控制**：严格的状态转换规则和权限检查
- **模式互斥**：技能模式、洗练模式、寻路模式的互斥执行
- **一致性保证**：所有功能模块遵循统一的状态流转

### 3. 模块化设计
- **单一职责**：每个模块只负责特定功能领域
- **接口标准化**：统一的模块接口和通信协议
- **可插拔架构**：支持模块的动态加载和卸载
- **依赖注入**：通过构造函数注入依赖关系

## 核心组件架构

### MacroEngine - 系统协调中心
```python
class MacroEngine:
    """
    职责：状态管理、资源调度、模式协调
    """
    def __init__(self):
        self._state = MacroState.STOPPED
        self._state_lock = threading.Lock()
        self._transition_lock = threading.Lock()
        
        # 功能模块管理
        self.skill_manager = None
        self.pathfinding_manager = None
        self.reroll_manager = None
        
        # 资源管理
        self.border_manager = None
        self.input_handler = None
        self.resource_manager = None
```

**核心职责**：
- 系统状态管理和转换控制
- 功能模块的生命周期管理
- 根据当前模式调度底层资源
- 热键处理和用户交互响应

### EventBus - 通信中枢
```python
class EventBus:
    """
    职责：事件分发、异步通信、模块解耦
    """
    def __init__(self):
        self._listeners = defaultdict(list)
        self._executor = ThreadPoolExecutor(max_workers=4)
        self._event_lock = threading.Lock()
        
    def publish(self, event_name, *args, **kwargs):
        # 异步事件分发
        
    def subscribe(self, event_name, callback):
        # 事件订阅注册
```

**技术特性**：
- 支持同步和异步事件处理
- 线程池优化的事件执行
- 递归事件检测和防护
- 性能监控和统计

### UnifiedScheduler - 任务调度核心
```python
class UnifiedScheduler:
    """
    职责：定时任务管理、精确调度、资源控制
    """
    def __init__(self):
        self._tasks = {}  # 任务注册表
        self._task_queue = []  # 基于heapq的优先级队列
        self._scheduler_thread = None
        self._running = False
        
    def add_task(self, task_id, interval, callback, **kwargs):
        # 动态任务添加
        
    def _scheduler_loop(self):
        # 高精度调度循环
```

**技术优势**：
- 基于heapq的高效优先级队列
- 毫秒级精度的任务调度
- 支持任务的动态增删改
- 单线程调度避免竞态条件

## 数据流架构

### 屏幕捕获数据流
```
Windows Graphics Capture API (C++)
    ↓ 零拷贝传输
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发
SkillManager/ResourceManager/PathfindingManager
```

### 用户输入数据流
```
用户操作 (GUI/热键)
    ↓ 事件发布
EventBus (事件分发)
    ↓ 状态更新
MacroEngine (状态管理)
    ↓ 模块调度
具体功能模块 (执行操作)
    ↓ 输入执行
InputHandler (队列管理)
```

### 配置数据流
```
JSON配置文件
    ↓ 加载解析
ConfigManager (配置管理)
    ↓ 事件通知
EventBus (配置更新事件)
    ↓ 配置同步
各功能模块 (热更新)
```

## 线程模型设计

### 主线程 (GUI线程)
- **职责**：用户界面更新、事件处理
- **特点**：Qt主事件循环，线程安全的UI更新
- **通信**：通过QTimer和信号槽与后台线程通信

### 调度线程 (UnifiedScheduler)
- **职责**：定时任务的精确调度和执行
- **特点**：单线程串行执行，避免竞态条件
- **性能**：高精度计时，低延迟任务分发

### 功能线程 (独立模块)
```python
# 洗练管理器 - 独立线程
class SimpleAffixRerollManager(threading.Thread):
    def run(self):
        # 独立的洗练逻辑循环
        
# 寻路管理器 - 独立线程  
class PathfindingManager(threading.Thread):
    def run(self):
        # 独立的寻路计算循环
```

### 输入处理线程
```python
class InputHandler:
    def __init__(self):
        self._input_queue = queue.Queue()
        self._processor_thread = threading.Thread(
            target=self._process_input_queue
        )
```

## 内存管理架构

### 图像数据管理
```python
class BorderFrameManager:
    def __init__(self):
        # 统一的图像缓存管理
        self._frame_cache = {}
        self._template_cache = {}
        self._cache_lock = threading.Lock()
        
    def get_cached_frame(self, cache_key):
        # 带过期时间的帧缓存
        
    def update_template_cache(self, region_name, template_data):
        # HSV模板缓存管理
```

### 对象生命周期管理
- **懒加载**：按需创建重资源对象（如OCR引擎）
- **对象池**：复用频繁创建的对象
- **引用计数**：自动清理不再使用的资源
- **内存监控**：实时监控内存使用情况

## 错误处理架构

### 分层错误处理
```python
# 业务层错误处理
class SkillManager:
    def execute_skill(self, skill_name):
        try:
            # 业务逻辑
        except SkillExecutionError as e:
            LOG_ERROR(f"技能执行失败: {e}")
            self.handle_skill_error(e)
        except Exception as e:
            LOG_ERROR(f"未预期错误: {e}")
            self.handle_unexpected_error(e)

# 系统层错误处理
class MacroEngine:
    def _set_state(self, new_state):
        try:
            # 状态转换逻辑
        except Exception as e:
            LOG_ERROR(f"状态转换异常: {e}")
            # 系统级错误恢复
```

### 错误恢复机制
- **自动重试**：临时性错误的自动重试机制
- **状态回滚**：错误发生时回滚到安全状态
- **降级服务**：关键功能失效时的降级处理
- **用户通知**：及时向用户报告错误状态

## 配置管理架构

### 分层配置系统
```python
class ConfigManager:
    """
    三层配置架构：
    1. 默认配置 - 系统内置
    2. 用户配置 - JSON文件
    3. 运行时配置 - 动态调整
    """
    def __init__(self):
        self.default_config = self._load_default_config()
        self.user_config = self._load_user_config()
        self.runtime_config = {}
        
    def get_config(self, key_path):
        # 优先级：运行时 > 用户 > 默认
```

### 热更新机制
```python
# 配置热更新事件
event_bus.subscribe("config:updated", self._on_config_updated)

def _on_config_updated(self, config_section, config_data):
    # 动态更新模块配置，无需重启
```

## 插件架构设计

### 插件接口定义
```python
class PluginInterface:
    """插件基础接口"""
    def initialize(self, context):
        """插件初始化"""
        pass
        
    def activate(self):
        """插件激活"""
        pass
        
    def deactivate(self):
        """插件停用"""
        pass
        
    def cleanup(self):
        """插件清理"""
        pass
```

### 插件管理器
```python
class PluginManager:
    def __init__(self):
        self._plugins = {}
        self._plugin_contexts = {}
        
    def load_plugin(self, plugin_path):
        # 动态加载插件
        
    def register_plugin(self, plugin_name, plugin_instance):
        # 注册插件实例
```

## 性能优化架构

### 计算优化
- **缓存策略**：多级缓存减少重复计算
- **批处理**：批量处理减少系统调用
- **预计算**：提前计算常用数据
- **算法优化**：选择最优算法和数据结构

### I/O优化
- **异步I/O**：非阻塞的文件和网络操作
- **内存映射**：大文件的内存映射访问
- **缓冲区管理**：智能缓冲区大小调整
- **批量写入**：减少磁盘写入次数

### 内存优化
```python
class MemoryOptimizer:
    def __init__(self):
        self._memory_pools = {}
        self._gc_threshold = 100 * 1024 * 1024  # 100MB
        
    def get_buffer(self, size):
        # 内存池分配
        
    def check_memory_usage(self):
        # 内存使用监控
        if self.get_memory_usage() > self._gc_threshold:
            self.trigger_garbage_collection()
```

## 扩展性设计

### 水平扩展
- **模块化架构**：新功能通过新模块实现
- **插件系统**：第三方扩展支持
- **API接口**：标准化的扩展接口
- **配置驱动**：通过配置控制功能行为

### 垂直扩展
- **性能调优**：可配置的性能参数
- **资源管理**：动态资源分配和调整
- **负载均衡**：任务分发和负载控制
- **缓存策略**：可配置的缓存策略

## 安全性架构

### 权限控制
```python
class SecurityManager:
    def __init__(self):
        self._permissions = {}
        self._access_log = []
        
    def check_permission(self, operation, context):
        # 权限检查
        
    def log_access(self, operation, user, result):
        # 访问日志记录
```

### 输入验证
- **参数验证**：所有外部输入的严格验证
- **类型检查**：运行时类型安全检查
- **边界检查**：数组和缓冲区边界保护
- **注入防护**：防止代码注入攻击

### 错误信息安全
- **敏感信息过滤**：错误日志中的敏感信息过滤
- **错误码映射**：内部错误码到用户友好信息的映射
- **日志分级**：不同级别的日志安全控制