# 02 架构与核心概念

## 概述

pyahk 采用事件驱动与模块化分层设计，围绕 EventBus 进行解耦通信，使用统一调度器（UnifiedScheduler）驱动各功能模块，并通过零拷贝图像捕获实现高效 I/O。在输入侧，引入“选择性事件拦截 + 分层优先级输入”新架构，兼顾游戏原生手感与程序化精确控制。

- 通信中枢：EventBus（发布/订阅、线程安全、递归检测防护）
- 运行协调：MacroEngine（四状态机、模式互斥、依赖注入）
- 定时调度：UnifiedScheduler（单调时钟、优先队列、暂停/恢复）
- 输入系统：InputHandler + CtypesHotkeyManager（Windows Hook、选择性拦截、四级队列、按键序列）
- 图像捕获：DXGI Desktop Duplication（C++ 双缓冲 + 原子指针，Python 零拷贝映射）

---

## 事件驱动与状态机

### EventBus（通信中枢）
- 全局单例、线程安全订阅/发布，异步回调使用线程池。
- 递归事件检测避免环路，保证在复杂联动下的稳定性。

### MacroEngine（系统协调中心）
- 四状态机：STOPPED → READY → RUNNING → PAUSED；严格的状态转换与权限检查。
- 模式互斥：技能模式、洗练模式、寻路模式的互斥执行管理。
- 统一发布状态：对 UI/OSD/日志输出提供一致的状态快照。

### UnifiedScheduler（统一调度器）
- 基于 heapq 的时间优先队列，time.monotonic() 精确计时。
- 支持任务的新增/移除/更新、一次性任务与周期任务、暂停/恢复。
- 智能恢复：恢复时重算 next_run_time，避免“雪崩式追执行”。

---

## 选择性事件拦截与分层优先级输入

新架构基于 Windows 低级 Hook（CtypesHotkeyManager），替代 pynput 监听器，彻底修复 suppress 导致的全局输入“卡死”问题；并引入“按键分层 + 选择性拦截 + 前置延迟”的组合策略，实现手感与可靠性的平衡。

### 按键分层与拦截策略
- 特殊按键（如 space）：suppress="never"，保持游戏原生响应；程序仅监控物理状态用于调度器暂停与技能抑制。
- 管理按键（如 e、right_mouse）：suppress="always"，程序完全接管；可在程序侧精确控制前后摇与时序。

典型配置（新推荐格式）：
```json
{
  "priority_keys": {
    "enabled": true,
    "special_keys": ["space"],
    "managed_keys": {
      "right_mouse": { "target": "right_mouse", "delay": 50 },
      "e": { "target": "0", "delay": 30 }
    }
  }
}
```

说明：
- special_keys 仅用于“监控+暂停”，不拦截系统事件，不需要 target/delay。
- managed_keys 使用对象格式：必须包含 target（发送目标键）与 delay（前置延迟，毫秒）。
- 为避免 Hook 自拦截，管理按键如需“自发自收”，需改用映射（例如拦截 E → 发送 0）。

### 四级优先队列

| 优先级 | 名称 | 数值 | 用例 | 执行策略 |
|--------|------|------|------|----------|
| emergency | 紧急 | 0 | 前置延迟、HP/MP 药剂 | 永不被暂停，立即执行 |
| high      | 高   | 1 | 优先级按键本体、核心输出 | 非优先级模式下执行 |
| normal    | 普通 | 2 | 常规技能、Buff | 被优先级按键状态暂停 |
| low       | 低   | 3 | UI/拾取/辅助 | 被优先级按键状态暂停 |

### 前置延迟（关键可靠性策略）

问题：发布“暂停”事件与游戏状态切换存在竞态，直接发送优先级按键可能被“吞掉”。

策略：当捕获优先级按键按下时，先向 emergency 队列插入 delayX，再向 high/emergency 插入按键本体，确保“暂停→状态同步→按键”的严格时序。

流程：
```
按下优先级按键（如 space/e/right_mouse）
  1) 发布 scheduler_pause_requested
  2) enqueue(emergency, delay50)
  3) enqueue(high/emergency, 按键本体或映射目标)
执行顺序：先 delay50 → 再按键
```

### 按键序列与智能去重
- key/alt_key 支持逗号分割序列：如 "delay50,q"、"q,delay100,w"。
- 去重原则：整体序列作为单元；delay/药剂等关键不去重；序列末尾自动推入清理标记以解锁再次触发。

---

## 数据流与线程模型

### 图像数据流
```
DXGI Duplication (C++) → 零拷贝共享内存 → NativeGraphicsCaptureManager（ctypes）
  → BorderFrameManager（缓存/模板） → Skill/Resource/Pathfinding 等模块
```

### 用户输入流（2025.10最新架构）
```
用户按键 → AHK Hook拦截 → AHK队列处理 → SendInput/事件发送
                      ↓ WM_COPYDATA
Python: MainWindow/OSD → SignalBridge → AHK InputHandler → EventBus → MacroEngine
```

### WM_COPYDATA双向通信

**Python → AHK（命令发送）**
```
Python: AHKCommandSender → hold_client.py → WM_COPYDATA → AHK服务器
命令类型：CMD_ENQUEUE, CMD_HOOK_REGISTER, CMD_SET_PYTHON_WINDOW_STATE等
```

**AHK → Python（事件接收）**
```
AHK: SendEventToPython() → WM_COPYDATA → Python窗口 → SignalBridge → EventBus
支持窗口：MainWindow (TorchLightAssistant_MainWindow_12345)
         OSD窗口 (TorchLightAssistant_OSD_12345)
```

### 智能窗口句柄缓存

**AHK端缓存策略**:
```ahk
// 全局状态变量
global CurrentPythonWindow := "TorchLightAssistant_MainWindow_12345"  // 默认主窗口
global CachedPythonHwnd := 0  // 缓存的窗口句柄

// 发送事件时的优化逻辑
SendEventToPython(event) {
    if (CachedPythonHwnd != 0) {
        if (SendWMCopyDataToPython(CachedPythonHwnd, event)) {
            return  // 使用缓存成功
        }
        CachedPythonHwnd := 0  // 缓存失效，清除
    }
    
    // 重新查找当前目标窗口
    CachedPythonHwnd := WinExist(CurrentPythonWindow)
    if (CachedPythonHwnd) {
        SendWMCopyDataToPython(CachedPythonHwnd, event)
    }
}
```

**Python端状态同步**:
- F8切换到READY/RUNNING/PAUSED → `set_python_window_state("osd")`
- F8切换到STOPPED → `set_python_window_state("main")`
- AHK收到CMD_SET_PYTHON_WINDOW_STATE后立即更新CurrentPythonWindow和清除缓存

### 线程布局
- **GUI 主线程**：UI/OSD 与交互，WM_COPYDATA消息处理
- **AHK 进程**：独立进程，10ms定时器处理队列
- **UnifiedScheduler 线程**：定时调度串行执行
- **功能模块线程**：寻路、洗练等独立线程
- **事件总线线程池**：异步回调

---

## 架构质量与近期变更

### 2025.01：输入架构升级
- 从 pynput 迁移到 CtypesHotkeyManager（Windows Hook）；修复全局输入无响应。
- 鼠标左中右键 VK 与消息常量补齐，统一处理 L/R/M/X 按键生命周期。

### 2025.10：AHK输入系统完全重构
- **进程分离**：AHK独立进程 + WM_COPYDATA双向通信，完全替代Python Hook
- **异步delay**：DelayUntil状态机，完全非阻塞，消除所有Sleep()调用
- **零硬编码**：所有按键配置由Python传入，AHK端无业务逻辑硬编码
- **智能缓存**：窗口句柄缓存机制，支持主窗口/OSD窗口自动切换
- **统一队列**：所有按键操作都走四级优先队列，逻辑清晰可控
- **双窗口支持**：MainWindow和OSD都能接收AHK事件，无缝切换

### 2025.10.17-18：紧急按键处理与序列去重增强
- **紧急按键缓存**：智能缓存HP/MP按键配置，确保生存技能在任何情况下都能优先执行
- **序列去重机制**：实现IsSequenceActive函数，防止快速重复按键造成的序列冲突
- **批量配置更新**：新增CMD_BATCH_UPDATE_CONFIG(19)命令，优化配置同步效率
- **ProcessQueue增强**：支持暂停状态下紧急操作的执行，确保HP/MP药剂不受影响
- **IsEmergencyAction函数**：智能识别紧急操作，确保关键动作不被系统暂停机制阻止

---

## 成功标准（小结）
- 特殊按键：保持原生响应；按下期间自动暂停后台调度，释放即恢复。
- 管理按键：程序接管并可靠执行（必要时通过映射规避自拦截），时序通过前置延迟保证。
- 任意序列：按优先级与防抖策略稳定执行；系统在优先级期间“零无效计算”。


---

## AHK输入系统详解（2025.10最新架构）

### 核心设计理念

**完全非阻塞 + 单一暂停机制 + 零硬编码**

- **异步delay**：DelayUntil状态机，不使用Sleep()
- **统一队列**：所有按键操作都走队列系统
- **单层暂停**：只在AHK层暂停，Python层不参与
- **零硬编码**：所有按键配置由Python传入

### 按键模式详解

| 模式 | AHK符号 | 拦截 | 释放事件 | 用途 | 示例 |
|------|---------|------|---------|------|------|
| **intercept** | `$` | ✅ | ❌ | 技能键、系统热键 | Q/W/E/R、F8/Z |
| **priority** | `$` | ✅ | ❌ | 管理按键（延迟+映射） | E→Shift |
| **special** | `~` | ❌ | ✅ | 特殊按键（暂停系统） | Space |
| **monitor** | `~` | ❌ | ✅ | 监控按键（状态检测） | A键（强制移动） |
| **block** | `$` | ✅ | ❌ | 禁用按键 | - |

### 管理按键执行流程（异步非阻塞）

```
用户按E键（配置：target="+", delay=50）:

时间0ms:
  AHK: HandleManagedKey()
  - 拦截E键（$符号）
  - SendEventToPython("managed_key_down:e")  // 仅日志
  - EmergencyQueue.Push("delay:50")
  - EmergencyQueue.Push("press:+")
  - 立即返回（非阻塞）✅

时间10ms:
  AHK: ProcessQueue()
  - 取出"delay:50"
  - DelayUntil = A_TickCount + 50
  - 立即返回（非阻塞）✅

时间20-50ms:
  AHK: ProcessQueue()
  - 检查DelayUntil > A_TickCount
  - 直接return
  - 所有队列被冻结（等待技能后摇）✅

时间60ms:
  AHK: ProcessQueue()
  - DelayUntil <= A_TickCount
  - DelayUntil = 0（自动重置）
  - 取出"press:+"
  - Send "{+}"（发送Shift键）✅

时间70ms:
  AHK: ProcessQueue()
  - 队列正常处理✅
```

### 四级优先队列

| 优先级 | 名称 | 数值 | 用例 | 执行策略 |
|--------|------|------|------|----------|
| emergency | 紧急 | 0 | 管理按键delay、HP/MP药剂 | 永远执行（即使在delay期间） |
| high      | 高   | 1 | 核心技能、高优先级操作 | 正常执行 |
| normal    | 普通 | 2 | 常规技能、Buff | 正常执行 |
| low       | 低   | 3 | UI/拾取/辅助 | 正常执行 |

### ProcessQueue处理逻辑

```ahk
ProcessQueue() {
    // 1. 检查异步delay
    if (DelayUntil > 0) {
        if (A_TickCount < DelayUntil) {
            return  // 还在延迟中，所有队列冻结
        } else {
            DelayUntil = 0  // 延迟结束，自动恢复
        }
    }
    
    // 2. 优先处理Emergency队列
    if (EmergencyQueue.Length > 0) {
        ExecuteAction(EmergencyQueue.RemoveAt(1))
        return
    }
    
    // 3. 检查暂停标志
    if (IsPaused || SpecialKeysPaused) {
        return
    }
    
    // 4. 按优先级处理其他队列
    // High → Normal → Low
}

SetTimer(ProcessQueue, 10)  // 每10ms调用一次
```

### 动作类型

| 动作类型 | 格式 | 说明 | 示例 |
|---------|------|------|------|
| press | `press:key` | 按下并释放按键 | `press:q` |
| hold | `hold:key` | 按住按键 | `hold:shift` |
| release | `release:key` | 释放按键 | `release:shift` |
| delay | `delay:ms` | 异步延迟（非阻塞） | `delay:50` |
| sequence | `sequence:keys` | 按键序列 | `sequence:delay50,q,delay100,w` |
| mouse_click | `mouse_click:button` | 鼠标点击 | `mouse_click:left` |
| notify | `notify:event` | 发送事件到Python | `notify:managed_key_up:e` |

### AHK命令协议

**Python发送给AHK的命令ID**：
```python
CMD_PING = 1                    # 测试连接
CMD_ENQUEUE = 4                 # 添加按键到队列
CMD_HOOK_REGISTER = 8           # 注册Hook
CMD_HOOK_UNREGISTER = 9         # 取消Hook
CMD_SET_PYTHON_WINDOW_STATE = 18 # 设置Python窗口状态
CMD_SET_MANAGED_KEY_CONFIG = 15  # 设置管理按键配置
CMD_CLEAR_HOOKS = 16            # 清空所有可配置Hook
CMD_BATCH_UPDATE_CONFIG = 19    # 批量更新配置 (新增 2025.10)
```

**AHK发送给Python的事件**：
```
intercept_key_down:f8           # 系统热键被按下
special_key_down:space          # 特殊按键被按下
special_key_pause:start         # 特殊按键引起的系统暂停
managed_key_down:e              # 管理按键被按下
monitor_key_down:a              # 监控按键被按下
```

### 配置示例

```json
{
  "stationary_mode_config": {
    "hotkey": "x",
    "mode_type": "shift_modifier",
    "force_move_hotkey": "a",
    "force_move_replacement_key": "f"
  },
  "priority_keys": {
    "enabled": true,
    "special_keys": ["space"],
    "managed_keys": {
      "e": {
        "target": "shift",     // E键映射为Shift键
        "delay": 50          // 前置延迟50ms
      },
      "right_mouse": {
        "target": "right_mouse",
        "delay": 30
      }
    }
  }
}
```

### 系统启动与运行流程

**1. 程序启动序列**：
```
main.py 启动
  → MacroEngine 初始化
  → AHKInputHandler 初始化
  → 启动 hold_server_extended.ahk 子进程
  → 等待 3 秒 (AHK_STARTUP_WAIT)
  → AHKCommandSender 测试连接 (CMD_PING)
  → 注册 F8 根热键 (CMD_HOOK_REGISTER)
  → 系统就绪，等待用户操作
```

**2. F8 状态切换流程**：
```
用户按 F8
  → AHK: HandleInterceptKey("f8")
  → AHK: SendEventToPython("intercept_key_down:f8")
  → Python: 接收 WM_COPYDATA 消息
  → Python: 触发 _handle_f8_press()
  → Python: 状态转换 STOPPED → READY
  → Python: 注册动态热键 (z/F7/F9/业务按键)
  → Python: 发送 CMD_SET_PYTHON_WINDOW_STATE("osd")
  → AHK: 更新 CurrentPythonWindow 为 OSD 窗口
  → 显示 OSD，隐藏主窗口
```

**3. 管理按键处理流程** (E键示例)：
```
用户按 E 键
  → AHK: HandleManagedKey("e")
  → AHK: 拦截 E 键 (不传递给游戏)
  → AHK: EmergencyQueue.Push("delay:50")
  → AHK: EmergencyQueue.Push("press:shift")
  → AHK: SendEventToPython("managed_key_down:e")  // 仅日志
  → AHK: ProcessQueue() 处理
     → 执行 "delay:50" → DelayUntil = A_TickCount + 50
     → 等待50ms...
     → 执行 "press:shift" → Send "{shift}"
```

### 关键优化点

1. **异步delay**：DelayUntil状态机，完全非阻塞，消除所有Sleep()
2. **双窗口支持**：MainWindow和OSD都能接收AHK事件，自动切换
3. **智能缓存**：窗口句柄缓存机制，失效自动重新查找
4. **零硬编码**：AHK端无业务逻辑，所有配置由Python动态传入
5. **统一队列**：所有按键操作都走四级优先队列，逻辑清晰
6. **状态去重**：monitor按键避免重复发送事件，提升性能
7. **容错恢复**：缓存失效、窗口关闭等异常情况自动处理
8. **紧急按键缓存**：智能缓存HP/MP按键配置，在ProcessQueue中优先处理生存技能
9. **序列去重防止**：实现活跃序列跟踪机制，避免快速重复触发导致的性能问题

---

## 紧急按键处理系统 (2025.10.17新增)

### 索急按键缓存机制

为确保HP/MP等生存技能在任何情况下都能优先执行，系统实现了智能缓存机制：

**AHK端实现**:
```ahk
; 紧急按键缓存变量
global CachedHPKey := ""
global CachedMPKey := ""

; 索急操作识别函数
IsEmergencyAction(action) {
    if (InStr(action, "press:" . CachedHPKey) = 1) {
        return true
    }
    if (InStr(action, "press:" . CachedMPKey) = 1) {
        return true
    }
    if (InStr(action, "delay:") = 1) {
        return true  ; 延时也被视为索急操作
    }
    return false
}

; 增强的ProcessQueue处理
ProcessQueue() {
    ; 1. 索急队列永远优先处理，即使在暂停状态下
    if (EmergencyQueue.Length > 0) {
        action := EmergencyQueue.RemoveAt(1)
        ExecuteAction(action)
        return
    }
    
    ; 2. 检查系统暂停状态
    if (IsPaused || SpecialKeysPaused) {
        return  ; 普通操作被暂停，但紹急操作仍可执行
    }
    
    ; 3. 处理其他优先级队列...
}
```

**Python端配置同步**:
```python
# 在配置更新时自动同步索急按键
def update_emergency_keys_cache(self):
    config = self.config_manager.get_config()
    hp_key = config.get("global", {}).get("resource_management", {}).get("hp_config", {}).get("key", "")
    mp_key = config.get("global", {}).get("resource_management", {}).get("mp_config", {}).get("key", "")
    
    # 使用新的批量更新命令
    self.command_sender.batch_update_config({
        "emergency_hp_key": hp_key,
        "emergency_mp_key": mp_key
    })
```

### 序列去重与活跃跟踪

为防止快速重复按键导致的序列冲突和性能问题，实现了智能去重机制：

**活跃序列管理**:
```ahk
; 活跃序列映射表
global ActiveSequences := Map()

; 检查序列是否正在执行
IsSequenceActive(sequenceId) {
    return ActiveSequences.Has(sequenceId) && ActiveSequences[sequenceId]
}

; 序列处理增强
ProcessSequence(sequenceStr, priority := 2) {
    sequenceId := "seq_" . sequenceStr  ; 生成唯一ID
    
    ; 去重检查
    if (IsSequenceActive(sequenceId)) {
        return false  ; 序列正在执行，拒绝重复添加
    }
    
    ; 标记序列为活跃状态
    ActiveSequences[sequenceId] := true
    
    ; 解析并添加序列动作
    keys := StrSplit(sequenceStr, ",")
    targetQueue := GetQueueByPriority(priority)
    
    for index, key in keys {
        key := Trim(key)
        if (key) {
            targetQueue.Push("press:" . key)
        }
    }
    
    ; 最后添加清理标记
    targetQueue.Push("cleanup_sequence:" . sequenceId)
    
    return true
}

; 清理序列标记
CleanupSequence(sequenceId) {
    if (ActiveSequences.Has(sequenceId)) {
        ActiveSequences.Delete(sequenceId)
    }
}
```

### 批量配置更新机制

新增CMD_BATCH_UPDATE_CONFIG命令支持一次性更新多个配置项，减少通信开销：

**Python端调用**:
```python
class AHKCommandSender:
    def batch_update_config(self, config_updates: dict):
        """批量更新AHK配置"""
        data = json.dumps(config_updates)
        return self.send_ahk_cmd(CMD_BATCH_UPDATE_CONFIG, data)

# 使用示例
self.command_sender.batch_update_config({
    "emergency_hp_key": "c",
    "emergency_mp_key": "2", 
    "special_keys_config": ["space"],
    "managed_keys_config": {"e": {"target": "shift", "delay": 50}}
})
```

**AHK端处理**:
```ahk
HandleBatchConfigUpdate(jsonData) {
    try {
        configMap := JSON.Load(jsonData)
        
        ; 更新紧急按键缓存
        if (configMap.Has("emergency_hp_key")) {
            CachedHPKey := configMap["emergency_hp_key"]
        }
        if (configMap.Has("emergency_mp_key")) {
            CachedMPKey := configMap["emergency_mp_key"]
        }
        
        ; 批量更新其他配置...
        ; 这比逐个命令更新效率更高
        
    } catch as e {
        ; 错误处理
    }
}
```
