# 02 核心架构设计

## 概述

pyahk采用现代化的分层架构和模块化设计，基于事件驱动模式构建。整个系统围绕**事件总线**进行组件间通信，通过**统一调度器**管理定时任务，使用**零拷贝屏幕捕获**技术实现高性能图像处理。

## 核心架构原则

### 1. 事件驱动架构
- **中央事件总线**：所有组件通过EventBus进行松耦合通信
- **发布/订阅模式**：支持异步事件处理和模块解耦
- **递归事件检测**：防止事件循环和死锁
- **线程安全**：支持多线程环境下的事件传递

### 2. 统一状态管理
- **标准状态机**：STOPPED → READY → RUNNING → PAUSED
- **状态转换控制**：严格的状态转换规则和权限检查
- **模式互斥**：技能模式、洗练模式、寻路模式的互斥执行
- **一致性保证**：所有功能模块遵循统一的状态流转

### 3. 模块化设计
- **单一职责**：每个模块只负责特定功能领域
- **接口标准化**：统一的模块接口和通信协议
- **可插拔架构**：支持模块的动态加载和卸载
- **依赖注入**：通过构造函数注入依赖关系

## 核心组件架构

### MacroEngine - 系统协调中心
```python
class MacroEngine:
    """
    职责：状态管理、资源调度、模式协调
    """
    def __init__(self):
        self._state = MacroState.STOPPED
        self._state_lock = threading.Lock()
        self._transition_lock = threading.Lock()
        
        # 功能模块管理
        self.skill_manager = None
        self.pathfinding_manager = None
        self.reroll_manager = None
        
        # 资源管理
        self.border_manager = None
        self.input_handler = None
        self.resource_manager = None
```

**核心职责**：
- 系统状态管理和转换控制
- 功能模块的生命周期管理
- 根据当前模式调度底层资源
- 热键处理和用户交互响应

### EventBus - 通信中枢
```python
class EventBus:
    """
    职责：事件分发、异步通信、模块解耦
    """
    def __init__(self):
        self.subscribers = defaultdict(list)
        self.subscribers_lock = threading.RLock()
        self._executor = ThreadPoolExecutor(max_workers=6)
        self._call_stack = threading.local()  # 递归检测
        
    def publish(self, event_name, *args, **kwargs):
        # 支持同步/异步事件分发
        
    def subscribe(self, event_name, callback):
        # 事件订阅注册
```

**技术特性**：
- 支持同步和异步事件处理
- 线程池优化的事件执行(6个工作线程)
- 基于threading.local()的递归事件检测和防护
- 性能监控和统计(每120秒记录一次)

### UnifiedScheduler - 任务调度核心
```python
class UnifiedScheduler:
    """
    职责：定时任务管理、精确调度、资源控制
    """
    def __init__(self):
        self._tasks = {}  # task_id -> ScheduledTask
        self._task_heap = []  # 基于heapq的优先级队列
        self._scheduler_thread = None
        self._lock = threading.Lock()
        self._condition = threading.Condition(self._lock)
        
    def _now(self) -> float:
        return time.monotonic()  # 单调时间源
        
    def add_task(self, task_id, interval, callback, **kwargs):
        # 动态任务添加，支持start_immediately参数
```

**技术优势**：
- 基于heapq的高效优先级队列
- time.monotonic()单调时间源，避免系统时钟调整影响
- 支持任务的动态增删改和更新
- 单线程调度避免竞态条件，提供亚毫秒级精度

## 输入系统架构

### 设计目标
- **统一入口**：所有输入通过 `InputHandler` 处理
- **优先级保障**：使用线程安全的PriorityDeque实现紧急操作插队
- **低延迟执行**：最小化阻塞操作，支持节流控制
- **调试友好**：dry_run 模式下完整记录行为轨迹

### 核心组件

| 组件 | 职责 |
|------|------|
| InputHandler | 输入调度与执行；维护MultiPriorityQueue、线程、优先级管理、按键监听 |
| MultiPriorityQueue | 四级优先队列：emergency/high/normal/low，按优先级顺序消费 |
| PriorityKeysWidget | 优先级按键配置UI，支持可视化管理和预设模式 |
| KeyboardListener | 实时键盘按键监听，检测优先级按键状态 |
| MouseListener | 实时鼠标按键监听，检测优先级按键状态 |
| HotkeyManager | 全局热键监听，转换为内部事件 |
| hold_server.ahk | 接收 WM_COPYDATA，执行按住/释放操作 |
| DebugDisplayManager | 接收 dry_run 动作文本，供 OSD 展示 |

### MultiPriorityQueue 架构
```python
class MultiPriorityQueue:
    """四级优先队列系统"""
    def __init__(self, maxsize: int = 0):
        # 按优先级从高到低排列
        self._queues = {
            'emergency': deque(),  # 紧急队列 - HP/MP药剂
            'high': deque(),       # 高优先级队列 - 核心技能
            'normal': deque(),     # 普通队列 - 常规技能
            'low': deque()         # 低优先级队列 - 辅助功能
        }
        self._priority_order = ['emergency', 'high', 'normal', 'low']
        self._maxsize = maxsize
        self._cond = threading.Condition()

    def put(self, item, priority='normal', block=False, timeout=None):
        """按优先级放入元素"""

    def get(self, block=True, timeout=None):
        """按优先级顺序取出元素"""
        for priority in self._priority_order:
            if self._queues[priority]:
                return self._queues[priority].popleft()
```

### 输入处理流程
```
技能逻辑决定输入需求
    ↓
检查优先级按键状态 (space/right_mouse等)
    ↓ (优先级按键按下时跳过普通技能)
InputHandler.execute_skill_*(action, priority_level)
    ↓
MultiPriorityQueue.put(action, priority='emergency'/'high'/'normal'/'low')
    ↓
后台线程: MultiPriorityQueue.get() (按优先级顺序消费)
    ↓
解析动作类型 (key_press/mouse_click/hold_*/etc.)
    ↓
根据dry_run模式决定：真实执行 or 记录调试
    ↓
pynput/AHK服务执行 or DebugDisplayManager记录
```

### 优先级按键监控流程 - 最新架构
```
用户按下优先级按键 (space/right_mouse)
    ↓
KeyboardListener/MouseListener检测到按键事件
    ↓
更新_priority_keys_pressed集合
    ↓
🚀 第一个优先级按键按下时：
InputHandler._pause_skill_scheduler()
    ↓
event_bus.publish('scheduler_pause_requested')
    ↓
SkillManager._on_scheduler_pause_requested()
    ↓
unified_scheduler.pause() - 暂停所有调度任务
    ↓
🛑 CPU使用率大幅降低 - 停止帧捕获、冷却检查等

用户释放优先级按键
    ↓
所有优先级按键释放时：
InputHandler._resume_skill_scheduler()
    ↓
event_bus.publish('scheduler_resume_requested')
    ↓
SkillManager._on_scheduler_resume_requested()
    ↓
unified_scheduler.resume() - 恢复所有调度任务
    ↓
▶️ 系统恢复正常运行
```

### 🚀 优先级按键暂停/恢复架构

#### 核心优化原理
传统实现中，当优先级按键激活时，虽然技能执行被阻塞，但 `UnifiedScheduler` 仍在运行，导致：
- `check_cooldowns` 继续执行但结果被丢弃
- 帧捕获和像素分析持续进行但无效
- 资源检查等CPU密集操作造成"零功效的资源浪费"

新架构通过**事件驱动的暂停/恢复机制**实现真正的"按需计算"：

#### 架构组件

**InputHandler** - 优先级按键状态监控
```python
def _pause_skill_scheduler(self):
    """暂停技能调度器以节省CPU资源"""
    event_bus.publish('scheduler_pause_requested', {
        'reason': 'priority_key_pressed',
        'active_keys': list(self._priority_keys_pressed)
    })

def _resume_skill_scheduler(self):
    """恢复技能调度器"""
    event_bus.publish('scheduler_resume_requested', {
        'reason': 'priority_key_released'
    })
```

**SkillManager** - 调度器控制响应
```python
def _on_scheduler_pause_requested(self, event_data):
    """响应优先级按键按下 - 暂停调度器以节省CPU资源"""
    if self.unified_scheduler.get_status()["running"]:
        self.unified_scheduler.pause()

def _on_scheduler_resume_requested(self, event_data):
    """响应优先级按键释放 - 恢复调度器"""
    if self._is_running and not self._is_paused:
        self.unified_scheduler.resume()
```

**UnifiedScheduler** - 智能暂停/恢复
```python
def pause(self) -> bool:
    """暂停所有任务执行"""
    if not self._running or self._paused:
        return False
    self._paused = True
    return True

def resume(self) -> bool:
    """恢复所有任务执行"""
    if not self._running or not self._paused:
        return False
    self._paused = False
    # 智能重新计算任务执行时间
    current_time = self._now()
    for task in self._tasks.values():
        if task.enabled:
            task.next_run_time = current_time + task.interval
    self._rebuild_heap()
    self._condition.notify()
    return True
```

#### 性能优化效果
- **CPU使用率**：优先级按键激活期间降低70-90%
- **资源节约**：完全停止无效的帧捕获、像素分析、冷却检查
- **响应性**：系统整体响应更加流畅
- **零浪费**：实现真正的"按需计算"，只在实际需要时消耗CPU资源

#### 状态管理层级
1. **用户手动暂停** (`_is_paused = True`): 通过UI或热键暂停整个系统
2. **优先级按键暂停** (`unified_scheduler.pause()`): 临时性能优化暂停
3. **系统停止** (`_is_running = False`): 完全停止运行

恢复逻辑确保只有在系统运行中且未被用户手动暂停时才会自动恢复。

### Hold(按住)模式架构
```python
# Hold模式状态管理
def _handle_hold_skills_on_running():
    for skill in hold_skills:
        send_hold_command(skill.key)

def _handle_hold_skills_on_stop():
    for active_hold in self._active_holds:
        send_release_command(active_hold)
```

**技术优势**：
- 不占用调度器资源
- 简单稳定的状态管理
- 避免误重复按下
- 支持组合键和复杂按键序列
- 序列级去重和清理机制

### 🎯 按键序列处理架构

#### 序列解析与分发
```python
def execute_skill_normal(self, key: str):
    """执行普通技能按键 - 支持序列 delay50,q"""
    if ',' in key:
        key_sequence = [k.strip() for k in key.split(',') if k.strip()]
        for i, individual_key in enumerate(key_sequence):
            self._key_queue.put(individual_key, priority='normal', block=False)
            # 在最后一个元素后添加清理标记
            if i == len(key_sequence) - 1:
                cleanup_marker = f"__cleanup_sequence__{key}"
                self._key_queue.put(cleanup_marker, priority='normal', block=False)
        # 将整个序列字符串加入去重集合
        self._queued_keys_set.add(key)
```

#### 延迟指令处理
```python
def _queue_processor_loop(self):
    """队列处理器循环 - 支持延迟指令"""
    while not self._stop_event.is_set():
        key_to_execute = self._key_queue.get(timeout=0.1)
        
        # 处理延迟指令
        if key_to_execute.lower().startswith("delay"):
            delay_ms = int(key_to_execute[5:])
            if self._stop_event.wait(delay_ms / 1000.0):
                break
            continue
```

#### 序列去重机制
- **整体序列去重**：`delay50,q` 作为完整单元处理
- **清理标记系统**：自动清理已完成序列的跟踪状态
- **状态一致性**：确保 `_queued_keys_set` 与实际队列同步

**架构优势**：
- 精确的时间控制（毫秒级延迟）
- 智能的序列管理（避免重复和冲突）
- 清理机制保证内存效率
- 支持任意复杂的按键组合

## 数据流架构

### 屏幕捕获数据流
```
DXGI Desktop Duplication (C++)
    ↓ 零拷贝共享内存
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发到各检测模块
SkillManager/ResourceManager/PathfindingManager
```

### 用户输入数据流
```
用户操作 (GUI/热键)
    ↓ 事件发布
EventBus (事件分发)
    ↓ 状态更新
MacroEngine (状态管理)
    ↓ 模块调度
具体功能模块 (执行操作)
    ↓ PriorityDeque入队
InputHandler (优先级队列管理)
    ↓ 硬件输出
pynput/AHK服务
```

### 配置数据流
```
JSON配置文件
    ↓ 加载解析
ConfigManager (配置管理)
    ↓ 事件通知
EventBus (配置更新事件)
    ↓ 配置同步
各功能模块 (热更新)
```

## 线程模型设计

### 主线程 (GUI线程)
- **职责**：用户界面更新、事件处理
- **特点**：Qt主事件循环，线程安全的UI更新
- **通信**：通过QTimer和信号槽与后台线程通信

### 调度线程 (UnifiedScheduler)
- **职责**：定时任务的精确调度和执行
- **特点**：单线程串行执行，避免竞态条件
- **性能**：高精度计时，低延迟任务分发

### 输入处理线程 (InputHandler)
```python
class InputHandler:
    def __init__(self):
        self._key_queue = MultiPriorityQueue(maxsize=9)
        self._processing_thread = threading.Thread(
            target=self._process_input_queue
        )
        # 优先级按键监听器
        self._keyboard_listener = None
        self._mouse_listener = None
        self._priority_keys_pressed = set()
```

### 功能线程 (独立模块)
```python
# 洗练管理器 - 独立线程
class SimpleAffixRerollManager(threading.Thread):
    def run(self):
        # 独立的洗练逻辑循环
        
# 寻路管理器 - 独立线程  
class PathfindingManager(threading.Thread):
    def run(self):
        # 独立的寻路计算循环
```

### 事件总线线程池
- **ThreadPoolExecutor**: 6个工作线程
- **异步事件处理**: 非阻塞事件分发
- **递归检测**: per-thread调用栈监控

## 内存管理架构

### 图像数据管理
```python
class BorderFrameManager:
    def __init__(self):
        # 统一的图像缓存管理
        self._frame_cache = {}
        self._template_cache = {}
        self._cache_lock = threading.Lock()
        
    def get_cached_frame(self, cache_key):
        # 带过期时间的帧缓存
        
    def update_template_cache(self, region_name, template_data):
        # HSV模板缓存管理
```

### C++层零拷贝管理
```cpp
class DXGICaptureSession {
    // 双缓冲区设计
    std::vector<uint8_t> buffer_a;
    std::vector<uint8_t> buffer_b;
    
    // 原子指针，指向当前可读缓冲区
    std::atomic<uint8_t*> current_read_buffer;
    
    // 写入缓冲区切换标志
    bool writing_to_a = true;
};
```

### 对象生命周期管理
- **懒加载**：按需创建重资源对象（如OCR引擎）
- **对象池**：复用频繁创建的对象
- **引用计数**：自动清理不再使用的资源
- **内存监控**：实时监控内存使用情况

## 性能优化策略

### 输入系统优化
- **批量处理**: 合并连续的同类型操作
- **智能节流**: 根据系统负载动态调整延迟
- **队列监控**: 防止队列积压导致的延迟

### 调度器优化
- **任务合并**: 相近时间的任务合并执行
- **优先级继承**: 防止低优先级任务饿死
- **负载均衡**: 动态调整任务执行频率

### 事件总线优化
- **事件过滤**: 避免不必要的事件传播
- **批量订阅**: 减少锁竞争
- **智能路由**: 基于事件类型的快速分发

## 扩展点设计

### 新功能模块集成
1. 实现标准接口 (`start()`, `stop()`, `pause()`, `resume()`)
2. 订阅必要的事件 (`engine:state_changed`, `config:updated`)
3. 注册到MacroEngine的模块管理器
4. 添加配置字段到JSON schema

### 自定义输入处理器
```python
class CustomInputProcessor:
    def process_action(self, action: dict) -> bool:
        # 自定义输入处理逻辑
        return True
        
# 注册到InputHandler
input_handler.register_processor(CustomInputProcessor())
```

### 事件扩展
```python
# 定义新事件
event_bus.publish("custom:new_event", data=custom_data)

# 订阅处理
def handle_custom_event(data):
    # 处理自定义事件
    pass
    
event_bus.subscribe("custom:new_event", handle_custom_event)
```

这种架构设计确保了系统的可扩展性、可维护性和高性能，为复杂的游戏自动化需求提供了坚实的技术基础。