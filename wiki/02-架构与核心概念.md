# 02 架构与核心概念

## 概览

pyahk 采用事件驱动与模块化分层设计，围绕 EventBus 进行解耦通信，使用统一调度器（UnifiedScheduler）驱动各功能模块，并通过零拷贝图像捕获实现高效 I/O。在输入侧，引入“选择性事件拦截 + 分层优先级输入”新架构，兼顾游戏原生手感与程序化精确控制。

- 通信中枢：EventBus（发布/订阅、线程安全、递归检测防护）
- 运行协调：MacroEngine（四状态机、模式互斥、依赖注入）
- 定时调度：UnifiedScheduler（单调时钟、优先队列、暂停/恢复）
- 输入系统：InputHandler + CtypesHotkeyManager（Windows Hook、选择性拦截、四级队列、按键序列）
- 图像捕获：DXGI Desktop Duplication（C++ 双缓冲 + 原子指针，Python 零拷贝映射）

---

## 事件驱动与状态机

### EventBus（通信中枢）
- 全局单例、线程安全订阅/发布，异步回调使用线程池。
- 递归事件检测避免环路，保证在复杂联动下的稳定性。

### MacroEngine（系统协调中心）
- 四状态机：STOPPED → READY → RUNNING → PAUSED；严格的状态转换与权限检查。
- 模式互斥：技能、寻路、洗练等独立模块在引擎级互斥管理。
- 统一发布状态：对 UI/OSD/日志输出提供一致的状态快照。

### UnifiedScheduler（统一调度器）
- 基于 heapq 的时间优先队列，time.monotonic() 精确计时。
- 支持任务新增/移除/更新、一次性任务与周期任务、暂停/恢复。
- 智能恢复：恢复时重算 next_run_time，避免“雪崩式追执行”。

---

## 选择性事件拦截与分层优先级输入

新架构基于 Windows 低级 Hook（CtypesHotkeyManager），替代 pynput 监听器，彻底修复 suppress 导致的全局输入“卡死”问题；并引入“按键分层 + 选择性拦截 + 前置延迟”的组合策略，实现手感与可靠性的平衡。

### 按键分层与拦截策略
- 特殊按键（如 space）：suppress="never"，保持游戏原生响应；程序仅监控物理状态用于调度器暂停与技能抑制。
- 管理按键（如 e、right_mouse）：suppress="always"，程序完全接管；可在程序侧精确控制前后摇与时序。

典型配置（新推荐格式）：
```json
{
  "priority_keys": {
    "enabled": true,
    "special_keys": ["space"],
    "managed_keys": {
      "right_mouse": { "target": "right_mouse", "delay": 50 },
      "e": { "target": "0", "delay": 30 }
    }
  }
}
```

说明：
- special_keys 仅用于“监控+暂停”，不截获系统事件，不需要 target/delay。
- managed_keys 使用对象格式：必须包含 target（发送目标键）与 delay（前置延迟，毫秒）。
- 为避免 Hook 自拦截，管理按键如需“自发自收”，需改用映射（例如拦截 E → 发送 0）。

### 四级优先队列

| 优先级 | 名称 | 数值 | 用例 | 执行策略 |
|--------|------|------|------|----------|
| emergency | 紧急 | 0 | 前置延迟、HP/MP 药剂 | 永不被暂停，立即执行 |
| high      | 高   | 1 | 优先级按键本体、核心输出 | 非优先级模式下执行 |
| normal    | 普通 | 2 | 常规技能、Buff | 被优先级按键状态暂停 |
| low       | 低   | 3 | UI/拾取/辅助 | 被优先级按键状态暂停 |

### 前置延迟（关键可靠性策略）

问题：发布“暂停”事件与游戏状态切换存在竞态，直接发送优先级按键可能被“吞掉”。

策略：当捕获优先级按键按下时，先向 emergency 队列插入 delayX，再向 high/emergency 插入按键本体，确保“暂停→状态同步→按键”的严格时序。

流程：
```
按下优先级按键（如 space/e/right_mouse）
  1) 发布 scheduler_pause_requested
  2) enqueue(emergency, delay50)
  3) enqueue(high/emergency, 按键本体或映射目标)
执行顺序：先 delay50 → 再按键
```

### 按键序列与智能去重
- key/alt_key 支持逗号分隔序列：如 "delay50,q"、"q,delay100,w"。
- 去重原则：整体序列作为单元；delay/药剂等关键不去重；序列末尾自动推入清理标记以解锁再次触发。

---

## 数据流与线程模型

### 图像数据流
```
DXGI Duplication (C++) → 零拷贝共享内存 → NativeGraphicsCaptureManager（ctypes）
  → BorderFrameManager（缓存/模板） → Skill/Resource/Pathfinding 等模块
```

### 用户输入流
```
GUI/热键 → EventBus → MacroEngine（状态/模式） → 各模块 → InputHandler（序列解析/四级队列） → Windows Hook/SendInput
```

### 线程布局
- GUI 主线程：UI/OSD 与交互
- UnifiedScheduler 线程：定时调度串行执行
- InputHandler 线程：消费四级队列，执行按键/延迟
- 功能模块线程：寻路、洗练等独立线程
- 事件总线线程池：异步回调

---

## 架构质量与近期变更

### 2025.01：输入架构升级
- 从 pynput 迁移到 CtypesHotkeyManager（Windows Hook）；修复全局输入无响应。
- 鼠标左右中键 VK 与消息常量补齐，统一处理 L/R/M/X 按键生命周期。

### 2025.10：一致性与初始化顺序
- 移除无效的早期监听启动，改为配置加载后启动。
- 统一状态发布 API，始终发布完整状态快照。

---

## 成功标准（小结）
- 特殊按键：保持原生响应；按下期间自动暂停后台调度，释放即恢复。
- 管理按键：程序接管并可靠执行（必要时通过映射规避自拦截），时序通过前置延迟保证。
- 任意序列：按优先级与防抖策略稳定执行；系统在优先级期间“零无效计算”。
