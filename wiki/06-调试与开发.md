# 06 调试与开发

## 概述

本章为开发者提供完整的调试工具、开发环境配置和代码贡献指南。涵盖调试模式使用、性能分析工具、代码架构理解和扩展开发规范。

---

## 🔍 调试模式详解

### 调试模式激活

#### 通过配置文件激活
```json
{
  "debug": {
    "enabled": true,
    "show_fps": true,
    "show_detection_overlay": true,
    "show_target_regions": true,
    "save_debug_frames": false,
    "log_level": "DEBUG"
  }
}
```

#### 通过热键激活
- **F7**: 切换调试显示开关
- **Ctrl+F7**: 保存当前调试帧
- **Shift+F7**: 切换性能统计显示

### 调试OSD窗口

#### 基础信息显示
```python
# 调试信息内容
{
    "状态": "RUNNING/STOPPED/PAUSED",
    "FPS": "60.2",
    "检测延迟": "12.5ms", 
    "队列长度": "3",
    "内存使用": "245MB",
    "活跃线程": "8"
}
```

#### 高级诊断信息
```python
# 性能分析数据
{
    "图像捕获": {
        "捕获间隔": "16.7ms",
        "处理时间": "2.1ms",
        "缓存命中率": "92%"
    },
    "模板匹配": {
        "HP检测": "0.8ms",
        "技能检测": "1.2ms", 
        "寻路检测": "3.5ms"
    },
    "输入队列": {
        "待处理": 2,
        "高优先级": 0,
        "平均延迟": "5ms"
    }
}
```

### 可视化调试

#### 检测区域覆盖层
```python
# 技能检测区域显示
skill_regions = {
    "技能1": [778, 1018, 34, 34],    # 绿色框
    "技能2": [826, 1018, 34, 34],    # 蓝色框
    "冷却检测": [778, 1000, 34, 18]  # 红色框
}

# HP/MP条显示
resource_regions = {
    "HP条": [136, 910, 213, 1004],   # 红色覆盖
    "MP条": [136, 870, 213, 894]     # 蓝色覆盖
}
```

#### 寻路路径可视化
```python
# 路径显示
pathfinding_debug = {
    "起点": (current_x, current_y),      # 绿色圆圈
    "终点": (target_x, target_y),        # 红色圆圈
    "路径": [(x1, y1), (x2, y2), ...],   # 黄色线条
    "障碍物": [rect1, rect2, ...],       # 灰色矩形
    "下一步": (next_x, next_y)           # 橙色箭头
}
```

### 调试日志系统

#### 日志级别配置
```python
import logging

# 日志级别层次
LOGGING_LEVELS = {
    "TRACE": 5,     # 最详细，包含所有操作
    "DEBUG": 10,    # 调试信息，包含函数调用
    "INFO": 20,     # 一般信息，状态变化
    "WARNING": 30,  # 警告信息，潜在问题
    "ERROR": 40,    # 错误信息，功能异常
    "CRITICAL": 50  # 严重错误，系统崩溃
}
```

#### 模块化日志记录
```python
# 各模块独立日志
loggers = {
    "core.event_bus": logging.getLogger("pyahk.core.event_bus"),
    "core.scheduler": logging.getLogger("pyahk.core.scheduler"),
    "core.input_handler": logging.getLogger("pyahk.core.input_handler"),
    "utils.capture": logging.getLogger("pyahk.utils.capture"),
    "skill_manager": logging.getLogger("pyahk.skill_manager"),
    "resource_manager": logging.getLogger("pyahk.resource_manager")
}

# 使用示例
skill_logger = logging.getLogger("pyahk.skill_manager")
skill_logger.debug(f"检测技能冷却: {skill_name}, 结果: {is_ready}")
```

#### 高频日志抑制
```python
class ThrottledLogger:
    """频率限制的日志记录器"""
    
    def __init__(self, logger, min_interval=1.0):
        self.logger = logger
        self.min_interval = min_interval
        self.last_log_time = {}
    
    def throttled_log(self, level, msg, throttle_key=None):
        """限频日志记录"""
        key = throttle_key or msg
        current_time = time.time()
        
        if key not in self.last_log_time or \
           current_time - self.last_log_time[key] >= self.min_interval:
            self.logger.log(level, msg)
            self.last_log_time[key] = current_time

# 使用示例
throttled_logger = ThrottledLogger(skill_logger, min_interval=5.0)
throttled_logger.throttled_log(logging.DEBUG, "技能检测循环", "skill_detection")
```

---

## 🛠️ 开发环境配置

### Python环境要求

#### 版本要求
```bash
# Python版本
Python >= 3.8

# 核心依赖
opencv-python >= 4.8.0
numpy >= 1.21.0
Pillow >= 9.0.0
PyQt5 >= 5.15.0
psutil >= 5.8.0
```

#### 开发依赖安装
```bash
# 基础开发环境
pip install -r requirements.txt

# 开发工具
pip install pytest pytest-cov black isort flake8 mypy

# 文档工具
pip install sphinx sphinx-rtd-theme

# 调试工具
pip install memory-profiler line-profiler py-spy
```

### C++扩展编译

#### Windows环境（推荐）
```bash
# 安装 Visual Studio Build Tools
# 或 Visual Studio Community 2019/2022

# 安装 CMake
winget install Kitware.CMake

# 编译C++扩展
cd native_capture
mkdir build
cd build
cmake ..
cmake --build . --config Release

# 验证编译结果
ls Release/capture_lib.dll
```

#### 交叉编译设置
```cmake
# CMakeLists.txt 配置
cmake_minimum_required(VERSION 3.16)

# 平台特定配置
if(WIN32)
    # Windows DXGI 支持
    target_link_libraries(capture_lib dxgi d3d11)
elseif(UNIX)
    # Linux X11 支持 (备用方案)
    find_package(X11 REQUIRED)
    target_link_libraries(capture_lib ${X11_LIBRARIES})
endif()
```

### IDE配置建议

#### VS Code配置
```json
// .vscode/settings.json
{
    "python.defaultInterpreterPath": "./venv/Scripts/python.exe",
    "python.linting.enabled": true,
    "python.linting.flake8Enabled": true,
    "python.formatting.provider": "black",
    "python.testing.pytestEnabled": true,
    "python.testing.pytestArgs": ["tests/"],
    "files.exclude": {
        "**/__pycache__": true,
        "**/build": true,
        "**/*.pyc": true
    }
}
```

#### PyCharm配置
```python
# Run/Debug Configuration
# Script: main.py
# Parameters: --debug --config=dev_config.json
# Working directory: /path/to/pyahk
# Environment variables:
#   PYTHONPATH=/path/to/pyahk
#   PYAHK_LOG_LEVEL=DEBUG
```

---

## 🧪 测试框架

### 单元测试结构

#### 测试目录组织
```
tests/
├── __init__.py
├── conftest.py                 # pytest配置
├── fixtures/                   # 测试数据
│   ├── test_images/
│   ├── mock_configs/
│   └── sample_frames/
├── unit/                       # 单元测试
│   ├── test_event_bus.py
│   ├── test_scheduler.py
│   ├── test_input_handler.py
│   └── test_border_manager.py
├── integration/                # 集成测试
│   ├── test_skill_system.py
│   ├── test_resource_system.py
│   └── test_full_workflow.py
└── performance/                # 性能测试
    ├── test_capture_performance.py
    └── test_memory_usage.py
```

#### 核心测试示例
```python
# tests/unit/test_event_bus.py
import pytest
from torchlight_assistant.core.event_bus import EventBus

class TestEventBus:
    def setup_method(self):
        """每个测试前重置EventBus"""
        self.event_bus = EventBus()
    
    def test_subscribe_and_publish(self):
        """测试基础订阅发布功能"""
        received_data = []
        
        def handler(data):
            received_data.append(data)
        
        self.event_bus.subscribe("test:event", handler)
        self.event_bus.publish("test:event", "test_data")
        
        assert len(received_data) == 1
        assert received_data[0] == "test_data"
    
    def test_unsubscribe(self):
        """测试取消订阅"""
        call_count = 0
        
        def handler(data):
            nonlocal call_count
            call_count += 1
        
        self.event_bus.subscribe("test:event", handler)
        self.event_bus.publish("test:event", "data1")
        
        self.event_bus.unsubscribe("test:event", handler)
        self.event_bus.publish("test:event", "data2")
        
        assert call_count == 1

# tests/integration/test_skill_system.py
class TestSkillSystem:
    @pytest.fixture
    def mock_game_frame(self):
        """模拟游戏画面"""
        import numpy as np
        frame = np.zeros((1080, 1920, 3), dtype=np.uint8)
        # 模拟技能图标
        frame[1018:1052, 778:812] = [100, 100, 255]  # 蓝色技能图标
        return frame
    
    def test_skill_detection(self, mock_game_frame):
        """测试技能检测功能"""
        from torchlight_assistant.core.skill_manager import SkillManager
        
        skill_manager = SkillManager()
        skill_config = {
            "name": "测试技能",
            "key": "1",
            "coords": [778, 1018, 34, 34],
            "template_coords": [778, 1018, 20, 20]
        }
        
        result = skill_manager.check_skill_ready(mock_game_frame, skill_config)
        assert isinstance(result, bool)
```

### 模拟测试环境

#### 图像数据模拟
```python
# tests/fixtures/image_generator.py
import numpy as np
import cv2

class MockImageGenerator:
    """模拟图像生成器"""
    
    @staticmethod
    def create_skill_icon(size=(34, 34), color=(100, 100, 255), ready=True):
        """创建模拟技能图标"""
        icon = np.full((*size, 3), color, dtype=np.uint8)
        
        if not ready:
            # 添加灰色蒙版表示冷却中
            overlay = np.full((*size, 3), (128, 128, 128), dtype=np.uint8)
            icon = cv2.addWeighted(icon, 0.3, overlay, 0.7, 0)
        
        return icon
    
    @staticmethod
    def create_hp_bar(width=213, height=94, percentage=80):
        """创建模拟HP条"""
        bar = np.zeros((height, width, 3), dtype=np.uint8)
        
        # 绿色部分表示当前HP
        fill_width = int(width * percentage / 100)
        bar[:, :fill_width] = [0, 255, 0]  # 绿色
        
        # 红色部分表示损失HP
        bar[:, fill_width:] = [0, 0, 255]  # 红色
        
        return bar
```

### 性能测试

#### 捕获性能测试
```python
# tests/performance/test_capture_performance.py
import time
import pytest
from torchlight_assistant.utils.native_graphics_capture_manager import NativeGraphicsCaptureManager

class TestCapturePerformance:
    def test_capture_fps(self):
        """测试捕获帧率"""
        capture_manager = NativeGraphicsCaptureManager()
        capture_manager.initialize()
        
        frame_count = 0
        start_time = time.time()
        test_duration = 5.0  # 测试5秒
        
        while time.time() - start_time < test_duration:
            frame = capture_manager.get_latest_frame()
            if frame is not None:
                frame_count += 1
            time.sleep(0.001)  # 1ms间隔
        
        elapsed_time = time.time() - start_time
        fps = frame_count / elapsed_time
        
        print(f"捕获FPS: {fps:.2f}")
        assert fps >= 30  # 至少30FPS
    
    def test_memory_usage(self):
        """测试内存使用"""
        import psutil
        import gc
        
        process = psutil.Process()
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        capture_manager = NativeGraphicsCaptureManager()
        capture_manager.initialize()
        
        # 捕获1000帧
        for _ in range(1000):
            frame = capture_manager.get_latest_frame()
            if frame is not None:
                # 模拟处理
                processed = frame[100:200, 100:200]
        
        gc.collect()
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory
        
        print(f"内存增长: {memory_increase:.2f}MB")
        assert memory_increase < 50  # 内存增长不超过50MB
```

---

## 📊 性能分析工具

### 内置性能监控

#### 实时性能统计 (增强版)
```python
class PerformanceMonitor:
    """性能监控器 - 支持暂停/恢复状态监控"""
    
    def __init__(self):
        self.metrics = {
            "capture_times": deque(maxlen=100),
            "process_times": deque(maxlen=100),
            "memory_usage": deque(maxlen=50),
            "cpu_usage": deque(maxlen=50),
            # 🚀 新增：暂停/恢复相关指标
            "scheduler_pauses": deque(maxlen=100),
            "pause_durations": deque(maxlen=50),
            "cpu_savings": deque(maxlen=50)
        }
        self.last_update = time.time()
        self.pause_start_time = None
        self.last_cpu_before_pause = None
    
    def record_scheduler_pause(self, reason: str):
        """记录调度器暂停事件"""
        self.pause_start_time = time.time()
        self.last_cpu_before_pause = self._get_current_cpu_usage()
        self.metrics["scheduler_pauses"].append({
            "timestamp": self.pause_start_time,
            "reason": reason,
            "type": "pause"
        })
    
    def record_scheduler_resume(self, reason: str):
        """记录调度器恢复事件"""
        if self.pause_start_time:
            pause_duration = time.time() - self.pause_start_time
            self.metrics["pause_durations"].append(pause_duration)
            
            # 计算CPU节约效果
            current_cpu = self._get_current_cpu_usage()
            if self.last_cpu_before_pause:
                cpu_saving = self.last_cpu_before_pause - current_cpu
                self.metrics["cpu_savings"].append(max(0, cpu_saving))
            
            self.metrics["scheduler_pauses"].append({
                "timestamp": time.time(),
                "reason": reason,
                "type": "resume",
                "pause_duration": pause_duration
            })
            
            self.pause_start_time = None
    
    def get_scheduler_statistics(self):
        """获取调度器暂停/恢复统计信息"""
        stats = {}
        
        # 暂停频率和持续时间统计
        if self.metrics["pause_durations"]:
            durations = list(self.metrics["pause_durations"])
            stats["pause_behavior"] = {
                "total_pauses": len(durations),
                "avg_pause_duration_s": np.mean(durations),
                "max_pause_duration_s": np.max(durations),
                "total_pause_time_s": np.sum(durations)
            }
        
        # CPU节约效果统计
        if self.metrics["cpu_savings"]:
            savings = list(self.metrics["cpu_savings"])
            stats["cpu_optimization"] = {
                "avg_cpu_savings_percent": np.mean(savings),
                "max_cpu_savings_percent": np.max(savings),
                "total_savings_events": len(savings)
            }
        
        # 最近的暂停/恢复事件
        recent_events = []
        for event in list(self.metrics["scheduler_pauses"])[-10:]:
            recent_events.append({
                "type": event["type"],
                "reason": event["reason"],
                "time_ago": time.time() - event["timestamp"]
            })
        stats["recent_events"] = recent_events
        
        return stats
```

#### 🚀 暂停/恢复机制调试

**调试OSD显示增强**：
```python
# 新增的调试信息显示
scheduler_debug_info = {
    "调度器状态": "运行中/已暂停",
    "暂停原因": "优先级按键/用户操作",
    "暂停时长": "2.5s",
    "CPU节约": "73%",
    "活跃任务数": "0/5",
    "优先级按键": "space+right_mouse"
}
```

**性能对比可视化**：
```python
# CPU使用率对比图表
performance_comparison = {
    "传统模式": {
        "基线CPU": 25.3,
        "优先级模式CPU": 24.1,  # 几乎无变化
        "节约效果": "4%"
    },
    "新架构": {
        "基线CPU": 22.1,
        "优先级模式CPU": 6.8,   # 大幅降低
        "节约效果": "69%"
    }
}
```

**暂停/恢复事件日志**：
```python
# 调试日志示例
[DEBUG] [性能优化] 优先级按键按下 space - 调度器暂停请求
[DEBUG] [UnifiedScheduler] 暂停所有任务执行 - 5个任务已暂停
[DEBUG] [性能监控] CPU使用率从22.1%降至6.8% - 节约69%
[DEBUG] [性能优化] 优先级按键释放 - 调度器恢复请求  
[DEBUG] [UnifiedScheduler] 恢复所有任务执行 - 重新计算执行时间
[DEBUG] [性能监控] 暂停持续2.3秒 - 累计节约CPU时间1.58秒
```

#### 性能监控热键

**新增调试热键**：
- **Ctrl+Shift+P**: 显示调度器暂停/恢复统计
- **Ctrl+Shift+C**: 显示CPU使用率历史图表
- **Ctrl+Shift+R**: 重置性能监控统计数据

#### 性能优化验证工具

```python
class SchedulerPerformanceValidator:
    """调度器性能验证工具"""
    
    def validate_pause_resume_efficiency(self):
        """验证暂停/恢复机制的效率"""
        results = {
            "暂停响应时间": self._measure_pause_response_time(),
            "恢复响应时间": self._measure_resume_response_time(),
            "CPU节约效果": self._measure_cpu_savings(),
            "任务调度准确性": self._validate_task_scheduling()
        }
        return results
    
    def _measure_pause_response_time(self):
        """测量从按键到调度器暂停的响应时间"""
        # 模拟按键 -> 测量到暂停的延迟
        # 目标：< 10ms
        
    def _measure_cpu_savings(self):
        """测量实际的CPU节约效果"""
        # 对比暂停前后的CPU使用率
        # 目标：> 60% CPU节约
```

### 外部分析工具

#### 使用py-spy进行性能分析
```bash
# 安装py-spy
pip install py-spy

# 实时分析运行中的pyahk
py-spy top --pid <pyahk_process_id>

# 生成火焰图
py-spy record -o profile.svg --pid <pyahk_process_id> --duration 60

# 分析特定函数
py-spy record -o profile.svg --pid <pyahk_process_id> --function
```

#### 使用line_profiler详细分析
```python
# 在需要分析的函数上添加装饰器
@profile
def process_frame(self, frame):
    """处理帧数据"""
    # 函数实现
    pass

# 运行分析
kernprof -l -v main.py
```

#### 内存泄漏检测
```python
# 使用memory_profiler
from memory_profiler import profile

@profile
def capture_loop(self):
    """捕获循环内存分析"""
    for i in range(1000):
        frame = self.get_frame()
        self.process_frame(frame)

# 使用tracemalloc
import tracemalloc

def start_memory_trace():
    """开始内存追踪"""
    tracemalloc.start()

def take_memory_snapshot():
    """获取内存快照"""
    snapshot = tracemalloc.take_snapshot()
    top_stats = snapshot.statistics('lineno')
    
    print("Top 10 memory consumers:")
    for stat in top_stats[:10]:
        print(stat)
```

---

## 🔧 代码贡献指南

### 开发工作流

#### 分支管理策略
```bash
# 主分支
main                    # 稳定发布版本
develop                 # 开发主分支

# 功能分支
feature/new-skill-ai    # 新功能开发
feature/performance-opt # 性能优化
bugfix/memory-leak     # 问题修复
hotfix/critical-crash  # 紧急修复
```

#### 提交规范
```bash
# 提交消息格式
<type>(<scope>): <description>

# 类型说明
feat:     新功能
fix:      问题修复
docs:     文档更新
style:    代码格式化
refactor: 代码重构
test:     测试相关
chore:    构建/工具相关

# 示例
feat(skill): add AI-based skill timing optimization
fix(capture): resolve DXGI memory leak in long sessions
docs(api): update event bus documentation
```

### 代码规范

#### Python代码风格
```python
# 使用Black进行格式化
black --line-length 88 torchlight_assistant/

# 使用isort整理导入
isort torchlight_assistant/ --profile black

# 使用flake8检查代码质量
flake8 torchlight_assistant/ --max-line-length 88

# 使用mypy进行类型检查
mypy torchlight_assistant/ --ignore-missing-imports
```

#### 文档字符串规范
```python
def process_skill_detection(
    self, 
    frame: np.ndarray, 
    skill_config: dict
) -> tuple[bool, float]:
    """检测技能是否就绪
    
    Args:
        frame: 游戏画面帧，shape为(H, W, 3)的BGR图像
        skill_config: 技能配置字典，包含坐标和模板信息
        
    Returns:
        tuple: (是否就绪, 相似度分数)
            - 是否就绪: True表示技能可以使用
            - 相似度分数: 0.0-1.0之间的模板匹配相似度
    
    Raises:
        ValueError: 当frame为None或shape不正确时
        KeyError: 当skill_config缺少必要字段时
        
    Example:
        >>> frame = capture_manager.get_latest_frame()
        >>> config = {"coords": [100, 100, 50, 50], "template": template}
        >>> ready, score = self.process_skill_detection(frame, config)
        >>> if ready and score > 0.8:
        ...     self.use_skill(config["key"])
    """
```

### 测试要求

#### 测试覆盖率要求
```bash
# 运行测试并生成覆盖率报告
pytest --cov=torchlight_assistant --cov-report=html --cov-report=term

# 覆盖率要求
# 新功能: >= 90%
# 核心模块: >= 95%
# 工具函数: >= 85%
```

#### Pull Request检查清单
- [ ] 所有测试通过
- [ ] 代码覆盖率达标
- [ ] 代码风格检查通过
- [ ] 文档字符串完整
- [ ] 性能测试通过
- [ ] 向后兼容性验证
- [ ] 更新相关文档

通过完善的调试工具和开发环境，开发者可以高效地进行功能开发、问题诊断和性能优化，确保pyahk项目的持续发展和稳定运行。