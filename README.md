# Torchlight Assistant - 高性能游戏自动化辅助工具

一个基于Python和C++的现代化桌面游戏自动化辅助工具，专为ARPG游戏（如《暗黑破坏神4》）设计。采用先进的**事件驱动架构**和**零拷贝屏幕捕获技术**，提供毫秒级响应的技能循环自动化、装备词缀洗练、状态监控和热键管理等功能。项目重构为高效、稳定的架构设计，确保卓越的性能表现和用户体验。

项目包含两个主要入口：
- `main.py`：完整的GUI版本，包含所有功能模块
- `main_special.py`：简化的命令行版本，专注于特定自动化任务

## 核心特性

*   **高性能零拷贝屏幕捕获**: 利用现代 **Windows Graphics Capture API** 和C++实现，Python层通过内存共享直接访问帧数据，避免了传统方式的内存拷贝开销，确保毫秒级的响应速度。采用双缓冲机制和智能帧率控制，进一步优化性能表现。
*   **事件驱动与模块化架构**: 
    *   **事件驱动核心**: 系统的核心组件（如UI、热键管理器、宏引擎、技能管理器）通过中央**事件总线（EventBus）**进行通信，完全解耦，极大地提高了代码的可维护性和可扩展性。支持异步事件处理和性能监控。
    *   **统一调度器 (`UnifiedScheduler`)**: `SkillManager` 的核心。它使用一个基于 `heapq` 的单一线程调度器来管理所有时间相关的任务（包括定时技能、冷却检测和序列执行），取代了旧的多线程模型，显著降低了资源开销，并提高了计时精度。
*   **即时音频反馈**: 通过预置的音频文件（hello.wav, goodbye.wav, pause.wav, resume.wav），为启动、停止、暂停和恢复等核心操作提供清晰、无延迟的声音提示，增强了"无视觉"操作的确认感。支持配置开关控制是否启用声音反馈。
*   **配置驱动的装备词缀洗练**:
    *   一个独立的、由 **F7** 热键控制的自动化模块，用于执行装备词缀的洗练（重铸）操作。
    *   采用**三状态智能识别**：通过OCR识别“随机词缀”（初始界面）、“关闭”（确认弹窗）和词缀选择界面，精准判断当前游戏状态。
    *   **实时OSD反馈**：通过颜色编码的OSD窗口显示详细状态信息，包括当前操作（“准备点击附魔”、“正在查找目标”等）、尝试次数、目标词缀列表等。
    *   **按需OCR加载**：OCR引擎仅在用户点击“加载OCR引擎”按钮时初始化，避免程序启动时的资源占用，提高兼容性。
*   **智能自动寻路与探索**: 采用先进的地图拼接技术、相位相关位移追踪和A*算法，实现对随机地图的自主探索和精确路径规划。支持双模式运行（探索模式和寻路模式）、实时目标识别、智能地图构建和路点跟随执行。全局地图使用5000x5000像素的numpy数组，支持8方向移动的A*路径规划算法。
*   **“一次捕获，多次使用”性能优化**: 在每个检测周期中，程序只进行一次屏幕捕获，然后将该帧数据在内存中复用给所有需要图像识别的技能。这从根本上避免了重复的、高成本的截图操作，显著降低了CPU占用率。
*   **模式互斥逻辑**: 严格区分“技能模式”、“洗练模式”和“寻路模式”。程序会根据用户指令和配置自动选择一种模式运行，确保逻辑清晰，行为可预测。
*   **智能图像与文字识别**:
    *   **冷却检测**: 采用高效的图像相似度对比算法，实现精准的技能冷却状态识别。
    *   **文字识别 (OCR)**: 集成 **PaddleOCR** 引擎，用于装备洗练时的词缀识别。OCR引擎按需加载，在用户第一次点击“加载OCR引擎”时初始化，避免了程序启动时不必要的资源占用。
*   **灵活的技能条件判断**: 支持多种技能触发条件，包括定时、冷却、资源（血量/蓝量）、BUFF等。所有条件判断都遵循"一次捕获，多次使用"的优化设计。

## 自动寻路功能详解 (已实现)

本项目的高级功能，旨在实现对随机生成地图（如《暗黑破坏神4》的地牢）的自主探索和路径规划。该功能采用**新架构设计**，通过 **F9** 热键准备寻路模式，**Z** 键执行寻路任务。目前已完成三个阶段的全面实现。

其核心技术方案分为三个阶段：

### 第一阶段：地图解读与拼接 (已实现)

此阶段的目标是将游戏小地图的像素图像，翻译并拼接成一张程序可以理解的、持久化的全局地图。

1.  **路径提取**: 程序利用 `OpenCV` 对小地图截图进行**颜色过滤**。通过`cv2.cvtColor`转为灰度图后，使用`cv2.threshold`将小地图中颜色较亮的、可通行的路径区域提取出来，生成一张只包含路径的二值化“蒙版”（Mask）。这一步直接过滤掉了地图背景、怪物标记等所有动态“噪音”。
2.  **图像优化**: 为了让路径数据更可靠，会使用`cv2.morphologyEx`和“闭运算”(`MORPH_CLOSE`)、“开运算”(`MORPH_OPEN`)来填补路径线条中的微小断裂，并移除孤立的噪点，得到一张干净、完整的路径图。
3.  **地图位移追踪**: 由于游戏小地图是“玩家在中心，地图移动”的模式，程序会对比**连续两帧**的“纯净路径图”，使用`cv2.phaseCorrelate`（相位相关）技术，精确计算出地图滚动的像素位移`(dx, dy)`。
4.  **全局地图拼接**: 程序在内存中维护一张巨大的“全局地图”（如5000x5000的`numpy`数组）。根据计算出的位移，它就能反推出玩家在全局地图上的绝对坐标，并将当前看到的新路况，通过`cv2.add`操作“拼接”到全局地图的正确位置上，像拼图一样，逐步扩大已探索的区域。

### 第二阶段：探索与路径规划 (已实现)

在拥有了绘制地图的能力后，程序需要一个策略来探索未知区域。

1.  **“Z字形/除草机”探索算法**: 在没有最终目标的情况下，程序采用一种系统性的‘除草机’算法来遍历地图。它会控制角色沿一个方向（如“右”）持续移动，直到在**已拼接的全局地图**上探测到前方有障碍物。然后，角色会向下移动一小段固定距离，并掉转方向（变为“左”）继续移动，如此往复，确保以Z字形路径完整地覆盖所有可探索区域，避免走回头路。
2.  **A\*寻路 (已实现)**: 一旦目标（如出口的独特图标）出现在视野中，并被记录到全局地图上后，程序将立即停止探索，并在已拼接的全局地图上运行 **A\*** 算法，规划出从玩家当前位置到目标的**最优路径**。实现了完整的路径规划、路点跟随和模式切换逻辑。

### 第三阶段：寻路执行 (已实现)

此阶段的目标是控制角色，精准地沿着规划好的路径移动。

1.  **方向向量**: 因为玩家永远在小地图中心，所以路径上的任何一个路点（Waypoint）都天然地代表了一个从玩家出发的**方向向量**。
2.  **路点跟随**: 实现了完整的路点跟随算法，支持精确的距离判断和路点切换。程序会根据当前位置与目标路点的距离，计算精确的方向向量，并在游戏主屏幕的相应位置模拟鼠标点击，驱动角色沿着A*规划的最优路径精确移动。同时支持暂停/恢复功能和模式智能切换。
3.  **移动执行**: 使用InputHandler的click_mouse_at方法在屏幕坐标(960, 540)为中心，根据计算出的方向向量和距离(150像素)确定点击位置，实现精确的角色移动控制。

## 架构设计

本工具采用分层和模块化的设计，其核心组件和职责如下：

*   **`MacroEngine` (宏引擎)**: 作为项目的**状态与事件协调中心**。它负责管理程序的核心状态，并作为**资源调度中心**，根据当前模式（战斗、洗练、寻路）动态指挥底层捕获模块切换最高效的工作模式。
*   **`SkillManager` (技能管理器)**: **技能决策引擎**。它订阅配置更新事件，将用户配置翻译成具体的、可执行的任务，并利用其内部的 `UnifiedScheduler` 实例进行调度。
*   **`SimpleAffixRerollManager` (智能洗练管理器)**: **装备洗练引擎**。一个完全独立的模块，在自己的线程中运行，负责执行所有与装备洗练相关的自动化流程。
*   **`PathfindingManager` (寻路管理器)**: **自动寻路引擎**。采用统一状态管理架构，由`MacroEngine`统一调度启停、暂停和恢复。在独立的线程中运行，持续地从`BorderFrameManager`获取屏幕数据，通过图像处理来解读小地图，利用相位相关技术追踪地图位移，并将探索到的地图拼接成一张完整的全局地图。支持双模式运行（探索模式和寻路模式）、实时目标识别和A*路径规划。
*   **`InputHandler` (输入处理器)**: **输入执行与队列管理中心**。它封装了键盘和鼠标的模拟输入操作，并独立管理一个按键队列。
*   **`UnifiedScheduler` (统一调度器)**: 项目定时任务的心脏。一个基于`heapq`的单线程循环，能够高效、精确地管理成百上千个不同间隔的定时任务。
*   **`BorderFrameManager` (边框图管理器)**: 一个**灵活的帧服务**，能够根据 `MacroEngine` 的指令，在“全屏捕获”和“指定区域捕获”之间动态切换，并为上层模块提供按需分割的帧数据切片。
*   **`NativeGraphicsCaptureManager` (原生图形捕获管理器)**: 封装C++捕获库，提供高性能的屏幕捕获服务。支持全屏或指定区域捕获，采用零拷贝技术和智能帧率控制。
*   **`EventBus` (事件总线)**: 基于发布/订阅模式，实现各模块间的异步通信，支持ThreadPoolExecutor优化的事件处理，是整个架构的神经中枢。包含递归事件检测和性能监控功能。
*   **`ConfigManager` (配置管理器)**: 负责配置文件的加载、保存和管理。支持JSON格式配置文件的读写操作。
*   **`PaddleOcrManager` (OCR管理器)**: 一个工具类，负责管理PaddleOCR引擎的生命周期，采用按需加载和性能优化配置。支持异步初始化和错误处理。
*   **`HotkeyManager` (热键管理器)**: 基于Windows API的低级键盘钩子管理器，支持热键的动态注册、注销和条件抑制。
*   **`SoundManager` (声音管理器)**: 管理音频反馈的播放，使用winsound库实现非阻塞音频播放。
*   **`WindowUtils` (窗口工具)**: 提供窗口检测、激活和管理功能，支持进程名和窗口类名的查找。
*   **`DebugLog` (调试日志)**: 基于环境变量的条件日志系统，支持不同级别的日志输出。

## 使用方法

1.  **启动程序**:
    *   **完整版本**: 运行 `main.py`，启动包含完整GUI界面的版本。
    *   **简化版本**: 运行 `main_special.py`，启动命令行版本（专注于特定自动化任务，需要管理员权限）。

2.  **配置**: 在"技能配置"、"目标窗口"、"时间间隔/声音"、"原地模式"、"洗练"、"寻路"等标签页中完成您的配置。支持加载/保存JSON格式的配置文件。

3.  **热键操作**:
    *   **F8 (主控键)**: 准备/停止**技能模式**。
    *   **F7 (洗练键)**: 启动/停止**装备洗练模式**（需要先加载OCR引擎）。
    *   **F9 (寻路键)**: 准备/停止**自动寻路模式**。
    *   **Z (执行/暂停键)**: 在"准备"状态下，按下Z键，开始执行对应的任务（技能或寻路）。在"运行"状态下，按下Z键，暂停任务。在"暂停"状态下，再次按下Z键，恢复任务。
    *   **原地模式热键**: 可配置的热键，用于切换原地释放技能模式。
    *   **交互/强制移动键**: 可配置的热键，用于临时屏蔽技能执行。

4.  **特殊功能**:
    *   **序列模式**: 支持按预设顺序循环执行多个技能。
    *   **原地模式**: 支持两种实现方式 - Shift修饰符或阻止鼠标键。
    *   **窗口激活**: 自动检测并激活目标游戏窗口。

## 技术亮点

### 1. 智能资源管理
- **情景感知的捕获策略**: 程序能够根据当前任务（战斗、寻路、洗练）的实际需求，动态切换屏幕捕获模式。在需要大范围视野时（寻路/战斗）自动切换为全屏捕获，在需要极致OCR速度时（洗练）切换为小范围UI区域捕获，在空闲时则完全停止捕获，最大限度地平衡了性能开销与功能需求。

### 2. 现代化的UI与核心架构
- **事件驱动设计**: 所有核心组件通过中央事件总线进行松耦合通信，逻辑清晰，易于扩展。支持异步事件处理和递归事件检测。
- **统一状态机架构**: 采用革新的两步式操作模式，所有功能模式（技能、洗练、寻路）都遵循STOPPED→READY→RUNNING→PAUSED的统一状态流转，确保用户体验一致性和操作安全性。
- **清晰的模块化UI**: UI层经过重构，将主窗口、各类配置组件和自定义控件完全分离，极大地提升了代码的可读性和可维护性。使用PySide6构建现代化界面。
- **线程安全的UI更新**: 借助 `QTimer`，所有来自后台线程的UI更新请求都会被安全地调度到主线程执行，杜绝了多线程 UI操作导致的崩溃风险。
- **智能输入处理**: InputHandler采用队列机制和线程池，确保输入操作的高效执行和状态同步。

### 3. 高性能与高效率
- **零拷贝屏幕捕获**: 基于C++和Windows Graphics Capture API，从根本上消除了内存拷贝开销。Python层通过ctypes直接访问C++内存缓冲区。
- **高效的任务调度**: 使用基于 `heapq` 的单线程统一调度器，以极低的资源开销精确管理所有定时任务。支持任务的动态添加、移除和间隔更新。
- **"一次捕获，多次使用"**: 图像帧在内存中被复用，避免了重复截图带来的CPU性能损耗。BorderFrameManager负责帧数据的统一管理和分发。
- **智能缓存机制**: 模板缓存和进程缓存减少重复计算，带内存限制和自动清理功能。

### 4. 稳健性与兼容性
- **稳健的错误处理**: 在所有关键路径上都添加了详细的错误日志，告别"静默失败"，便于快速定位问题。支持DEBUG环境变量控制日志输出级别。
- **依赖版本管理**: 在 `requirements.txt` 中明确指定依赖版本，保证了开发和部署环境的一致性与可复现性。包含PySide6、OpenCV、PaddleOCR等核心依赖。
- **按需加载**: OCR等重资源模块按需加载，优化了程序的启动速度和资源占用。支持异步初始化和错误恢复。
- **跨平台兼容性**: 主要针对Windows平台设计，使用Windows API实现底层功能，同时保持Python层的平台无关性。

### 5. 智能寻路与探索技术
- **先进的地图拼接技术**: 采用`cv2.phaseCorrelate`相位相关算法，实现了亚像素级精度的地图位移追踪，确保全局地图的高精度拼接。支持动态地图更新和内存优化。
- **高效的A*路径规划**: 实现了支持8方向移动的A*算法，支持动态地图更新和实时路径重规划，确保找到最优路径。使用Node类和heapq实现高效的优先级队列。
- **智能双模式切换**: 在探索模式下采用Z字形遍历算法（"除草机"模式），一旦发现目标即刻切换到寻路模式，实现高效的自主探索和精确寻路。
- **实时目标识别**: 通过HSV颜色空间过滤和轮廓检测，实现了对游戏中特定目标（如任务点、传送门）的实时识别和定位。支持亮蓝色目标的自动检测。
- **全局地图管理**: 使用5000x5000像素的numpy数组维护全局地图，支持玩家位置追踪和地图区域的动态拼接。

## 依赖环境与配置

### 系统要求
- **操作系统**: Windows 10/11 (主要支持平台)
- **Python版本**: 3.7+
- **权限要求**: 部分功能需要管理员权限（如热键监听）

### 核心依赖
```
PySide6>=6.5.0        # GUI框架
psutil>=5.9.0         # 系统进程管理
pynput>=1.7.6         # 键盘鼠标输入控制
Pillow>=9.0.0         # 图像处理
numpy>=1.20.0         # 数值计算
opencv-python>=4.5.0  # 计算机视觉
pywin32>=306          # Windows API接口
paddleocr==2.7.3      # OCR文字识别
```

### 环境配置
- **DEBUG模式**: 设置环境变量`DEBUG=1`启用详细日志输出
- **代理设置**: 支持HTTP/HTTPS代理配置（用于PaddleOCR下载）
- **配置文件**: 支持JSON格式的配置文件，支持多套配置切换

### 项目结构
```
torchlight_assistant/
├── core/                    # 核心业务逻辑
│   ├── macro_engine.py     # 主控制器
│   ├── skill_manager.py    # 技能管理
│   ├── input_handler.py    # 输入处理
│   └── ...
├── gui/                    # 用户界面
│   ├── main_window.py      # 主窗口
│   ├── skill_config_widget.py
│   └── ...
├── utils/                  # 工具类
│   ├── native_graphics_capture_manager.py
│   ├── border_frame_manager.py
│   └── ...
└── native_capture/         # C++原生捕获库
    ├── capture_lib.cpp
    ├── python_wrapper.py
    └── ...
```