# 02 核心架构设计

## 概述

pyahk采用现代化的分层架构和模块化设计，基于事件驱动模式构建。整个系统围绕**事件总线**进行组件间通信，通过**统一调度器**管理定时任务，使用**零此机制解决程序响应过快导致游戏来不及处理"暂停"状态的问题，确保优先级操作的绝对可靠性。

**架构流程**:
1. `InputHandler`检测到优先级按键操作
2. **立即**通过事件总线发布`scheduler_pause_requested`事件
3. **【关键】** 向**紧急队列**推入前置延迟指令（如delay50）
4. 向**高优先级队列**推入按键本身
5. 执行顺序：先延迟，再按键，确保游戏状态同步

#### 3. 按键序列处理实现高性能图像处理。

## 核心架构原则

### 1. 事件驱动架构
- **中央事件总线**：所有组件通过EventBus进行松耦合通信。
- **发布/订阅模式**：支持异步事件处理和模块解耦。
- **递归事件检测**：防止事件循环和死锁。
- **线程安全**：支持多线程环境下的事件传递。

### 2. 统一状态管理
- **标准状态机**：STOPPED → READY → RUNNING → PAUSED。
- **状态转换控制**：严格的状态转换规则和权限检查。
- **模式互斥**：技能模式、洗练模式、寻路模式的互斥执行。
- **一致性保证**：所有功能模块遵循统一的状态流转。

### 3. 模块化设计
- **单一职责**：每个模块只负责特定功能领域。
- **接口标准化**：统一的模块接口和通信协议。
- **可插拔架构**：支持模块的动态加载和卸载。
- **依赖注入**：通过构造函数注入依赖关系。

## 核心组件架构

### MacroEngine - 系统协调中心
- **核心职责**：
  - 系统状态管理和转换控制（四状态机：STOPPED→READY→RUNNING→PAUSED）。
  - 功能模块的生命周期管理和依赖注入。
  - 根据当前模式调度底层资源（技能模式、寻路模式、洗练模式互斥）。
  - 热键处理和用户交互响应，支持热键的动态注册/取消。

### EventBus - 通信中枢
- **技术特性**：
  - 单例模式设计，确保全局唯一的事件总线实例。
  - 支持同步和异步事件处理，异步事件使用线程池(6个工作线程)。
  - 基于`threading.local()`的递归事件检测和防护机制。
  - 线程安全的事件订阅/发布，支持多线程并发访问。

### UnifiedScheduler - 任务调度核心
- **技术优势**：
  - 基于`heapq`的高效优先级队列，支持任务按执行时间排序。
  - `time.monotonic()`单调时间源，避免系统时钟调整和夏令时影响。
  - 支持任务的动态增删改、暂停/恢复和间隔更新。
  - 单线程调度避免竞态条件，提供亚毫秒级定时精度。

---

## 输入系统架构

### 设计目标
- **选择性拦截**：实现特殊按键（space）的游戏原生响应与管理按键（E、right_mouse）的程序完全控制。
- **统一入口**：所有输入通过 `InputHandler` 统一调度。
- **优先级保障**：使用`MultiPriorityQueue`实现四级优先级（紧急、高、普通、低）调度。
- **可靠性**: 引入"前置延迟"机制，确保高优先级操作在游戏中的响应万无一失。
- **灵活性**: 支持"按键序列"，允许用户配置复杂的宏命令，如 `delay50,q`。
- **健壮性**: 拥有智能去重机制，能处理复杂序列，防止指令堆积或丢失。

### 核心架构：选择性事件拦截

#### 按键分类系统
系统自动将优先级按键分为两类进行差异化处理：

| 分类 | 按键类型 | 处理机制 | 用途 |
|------|----------|----------|------|
| **特殊按键** | space | 游戏原生响应 + 程序监控 | 闪避、格挡等即时响应操作 |
| **管理按键** | E, right_mouse | 程序完全接管（事件拦截） | 技能、攻击等精确控制操作 |

#### 技术实现：pynput事件拦截
```python
# 关键返回值控制机制
def _on_key_press(self, key):
    if key in self.managed_keys:
        return False  # 拦截：阻止事件传递给游戏
    else:
        return None   # 透传：事件正常传递给游戏
```

### 核心组件

| 组件 | 职责 |
|------|------|
| InputHandler | 输入系统总控制器，实现选择性事件拦截和统一调度 |
| MultiPriorityQueue | 四级优先队列，确保紧急操作总能最先执行 |
| pynput Listeners | 系统级监听器，支持suppress=True的选择性拦截 |

### 核心机制：选择性拦截、前置延迟与序列化

#### 1. 选择性事件拦截机制
解决不同按键需要不同处理方式的问题：保持关键操作的游戏体验，同时实现精确的程序控制。

**架构流程**:
1. pynput监听器捕获所有系统级按键事件
2. InputHandler根据按键类型选择处理策略：
   - **特殊按键**：发布程序事件（暂停调度器等）但不拦截系统事件
   - **管理按键**：完全拦截系统事件，由程序接管控制
3. 按键分类在配置加载时自动完成

#### 2. 优先级按键：前置延迟机制
此机制是为解决游戏自动化中的一个核心痛点：当程序快速触发“暂停”并立即执行“闪避”时，游戏客户端可能因未能及时处理状态切换而“吞掉”闪避指令。

**架构流程**:
1.  `InputHandler`监听到优先级按键（如`space`）被按下。
2.  **立即**通过事件总线发布`scheduler_pause_requested`事件，请求暂停技能调度器。
3.  **【关键】** `InputHandler`并不直接执行`space`，而是向**紧急队列**的队首插入一个`delay`指令（如50ms）。
4.  随后，将`space`指令插入**高优先级队列**。
5.  输入处理线程在执行时，会先处理紧急队列中的`delay`指令，等待50ms，之后再执行高优队列中的`space`指令。这个延迟给予了游戏客户端足够的时间来响应“暂停”，从而确保了后续的`space`操作能够被正确执行。

#### 2. 按键序列处理
`InputHandler`的`execute_skill_*`等方法，现在能将字符串（如`"delay50,q"`）解析为指令序列。

**架构流程**:
1.  方法接收到序列字符串，按逗号分割成独立的指令（`delay50` 和 `q`）。
2.  将整个序列字符串（`"delay50,q"`）作为一个"单元"添加到内部的去重集合`_queued_keys_set`中，防止在它执行完之前被重复添加。
3.  将序列中的单个指令（`delay50`, `q`）依次推入`MultiPriorityQueue`的相应队列中。
4.  **【关键】** 在序列的最后一个指令（`q`）之后，再向队列中推入一个特殊的内部标记，如`__cleanup_sequence__delay50,q`。
5.  当输入处理线程执行到这个标记时，它会从去重集合`_queued_keys_set`中移除整个序列字符串，从而允许这个序列在未来被再次触发。

#### 3. 智能去重 (`_should_deduplicate_key`)
这个方法为序列化处理提供了健壮性保障。它决定了一个指令或序列是否应该被去重。规则如下：
-   **指令层面**：`delay`指令、紧急药剂按键、鼠标左键等，永远不会被去重。
-   **序列层面**：如果一个序列（如`"delay50,q"`）中包含任何一个不应被去重的指令，那么整个序列都不会被去重。

这个设计确保了系统的灵活性和可靠性，既能执行复杂的宏，又不会丢失关键操作。

### 状态与事件流程

#### 输入处理流程
```
外部调用 (技能/药剂)
    ↓
InputHandler.execute_*(key="delay50,q", priority="high")
    ↓
1. 检查优先级模式是否激活 (若激活则普通/低优技能被跳过)
2. 检查序列是否应被去重 (调用 _should_deduplicate_key)
3. 若通过，则将序列作为一个整体加入去重集合
4. 解析序列，将 "delay50", "q", "__cleanup_sequence__..." 依次推入高优队列
    ↓
后台线程: MultiPriorityQueue.get() (按四级优先级顺序消费)
    ↓
解析并执行单个指令 (如 time.sleep(0.05) 或 pynput.press('q'))
    ↓
执行到 __cleanup_sequence__ 标记时，从去重集合中移除序列
```

#### 优先级按键选择性拦截流程
```
用户按下优先级按键（如space或E）
    ↓
pynput._on_key_press() 捕获系统事件
    ↓
InputHandler 判断按键类型：
├─ 特殊按键(space): 发布程序事件 + return None (透传给游戏)
└─ 管理按键(E): 发布程序事件 + return False (拦截系统事件)
    ↓
程序事件处理：
1. 发布 scheduler_pause_requested 事件
2. 执行前置延迟机制 (emergency队列: delay50, high队列: 按键)
    ↓
SkillManager 响应事件，调用 unified_scheduler.pause()
    ↓
🛑 所有普通/低优先级调度任务暂停

用户释放按键
    ↓
同样的选择性拦截逻辑
    ↓
发布 scheduler_resume_requested 事件
    ↓
▶️ 调度任务恢复
```
```
用户按下`space`
    ↓
InputHandler._on_key_press()
    ↓
1. 发布 `scheduler_pause_requested` 事件
2. 执行“前置延迟”机制 (向紧急队列放`delay`, 向高优队列放`space`)
    ↓
SkillManager 响应事件, 调用 unified_scheduler.pause()
    ↓
🛑 所有普通/低优调度任务暂停，CPU占用降低

用户释放`space`
    ↓
InputHandler._on_key_release()
    ↓
发布 `scheduler_resume_requested` 事件
    ↓
SkillManager 响应事件, 调用 unified_scheduler.resume()
    ↓
▶️ 调度任务恢复
```

---

## 数据流架构

### 屏幕捕获数据流
```
DXGI Desktop Duplication (C++)
    ↓ 零拷贝共享内存
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发到各检测模块
SkillManager/ResourceManager/PathfindingManager
```

### 用户输入数据流
```
用户操作 (GUI/热键)
    ↓ 事件发布
EventBus (事件分发)
    ↓ 状态更新
MacroEngine (状态管理)
    ↓ 模块调度
具体功能模块 (执行操作)
    ↓ 按键/序列入队
InputHandler (优先级与序列管理)
    ↓ 硬件输出
pynput/AHK服务
```

### 配置数据流
```
JSON配置文件
    ↓ 加载解析
ConfigManager (配置管理)
    ↓ 事件通知
EventBus (配置更新事件)
    ↓ 配置同步
各功能模块 (热更新)
```

---

## 线程模型设计

### 主线程 (GUI线程)
- **职责**：用户界面更新、事件处理。
- **特点**：Qt主事件循环，通过信号槽与后台线程安全通信。

### 调度线程 (UnifiedScheduler)
- **职责**：定时任务的精确调度和执行。
- **特点**：单线程串行执行，避免竞态条件。

### 输入处理线程 (InputHandler)
- **职责**：独立于主线程，消费`MultiPriorityQueue`中的指令，执行实际的按键和延迟操作。

### 功能线程 (独立模块)
- **职责**：如`SimpleAffixRerollManager`（洗练）、`PathfindingManager`（寻路）等，在独立线程中运行，避免阻塞主线程和输入线程。

### 事件总线线程池
- **职责**：异步执行通过`EventBus`分发的事件回调，实现模块间非阻塞通信。

---

## 内存管理与扩展点

### 内存管理架构
- **图像数据管理**: `BorderFrameManager` 统一管理帧缓存和模板缓存。
- **C++层零拷贝管理**: `DXGICaptureSession` 采用双缓冲区和原子指针技术。
- **对象生命周期管理**: 懒加载（如OCR引擎）、对象池、引用计数等。

### 扩展点设计
- **新功能模块集成**: 实现标准接口，订阅事件，注册到`MacroEngine`。
- **自定义输入处理器**: 允许注册新的处理器到`InputHandler`。
- **事件扩展**: 自由定义和发布/订阅新事件。

这种架构设计确保了系统的可扩展性、可维护性和高性能，为复杂的游戏自动化需求提供了坚实的技术基础。