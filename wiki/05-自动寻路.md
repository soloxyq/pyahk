# 自动寻路系统

## 概述

自动寻路系统是pyahk的高级功能模块，专门为随机生成地图（如《暗黑破坏神4》地牢）设计。采用**相位相关位移跟踪**和**A*算法**，实现智能地图探索和精确路径规划。系统支持双模式运行，能够自主探索未知区域并规划最优路径。

## 核心技术架构

### 三阶段技术方案

#### 第一阶段：地图解读与拼接
将游戏小地图的像素图像翻译并拼接成程序可理解的全局地图。

**1. 路径提取**
```python
# OpenCV颜色过滤提取可通行路径
def extract_paths(minimap_frame):
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    _, mask = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)
    return mask  # 二值化路径蒙版
```

**2. 图像优化**
```python
# 形态学操作优化路径连通性
def optimize_paths(path_mask):
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    # 闭运算填补断裂
    closed = cv2.morphologyEx(path_mask, cv2.MORPH_CLOSE, kernel)
    # 开运算移除噪点
    opened = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel)
    return opened
```

**3. 地图位移追踪**
```python
# 相位相关算法计算地图移动
def track_displacement(prev_frame, curr_frame):
    displacement, response = cv2.phaseCorrelate(prev_frame, curr_frame)
    return displacement  # (dx, dy) 像素位移
```

**4. 全局地图拼接**
```python
# 维护5000x5000的全局地图
def update_global_map(global_map, current_paths, player_pos):
    x, y = player_pos
    global_map[y:y+h, x:x+w] = cv2.add(
        global_map[y:y+h, x:x+w], current_paths
    )
```

#### 第二阶段：探索与路径规划
实现系统性的地图探索和智能路径规划。

**1. "除草机"探索算法**
```python
class LawnmowerExplorer:
    def __init__(self):
        self.direction = "right"
        self.row_height = 50
        
    def get_next_move(self, current_pos, obstacle_map):
        if self.can_continue_direction():
            return self.get_direction_vector()
        else:
            self.move_to_next_row()
            self.reverse_direction()
            return self.get_direction_vector()
```

**2. A*寻路算法**
```python
class AStarPathfinder:
    def find_path(self, start, goal, obstacle_map):
        open_set = []
        heapq.heappush(open_set, (0, start))
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            if current == goal:
                return self.reconstruct_path(current)
            
            for neighbor in self.get_neighbors(current):
                if self.is_valid_move(neighbor, obstacle_map):
                    self.process_neighbor(neighbor, current)
```

#### 第三阶段：寻路执行
精确控制角色沿规划路径移动。

**1. 方向向量计算**
```python
def calculate_direction_vector(current_pos, target_waypoint):
    dx = target_waypoint[0] - current_pos[0]
    dy = target_waypoint[1] - current_pos[1]
    
    # 标准化到150像素距离
    length = math.sqrt(dx*dx + dy*dy)
    if length > 0:
        dx = (dx / length) * 150
        dy = (dy / length) * 150
    
    return (dx, dy)
```

**2. 路点跟随系统**
```python
class WaypointFollower:
    def __init__(self, path, reach_threshold=15):
        self.path = path
        self.current_waypoint_index = 0
        self.reach_threshold = reach_threshold
    
    def update(self, player_position):
        if self.reached_current_waypoint(player_position):
            self.advance_to_next_waypoint()
        
        return self.get_movement_direction(player_position)
```

## 功能特性

### 1. 双模式运行

#### 探索模式
- **目标**：系统性遍历所有可探索区域
- **算法**：Z字形/除草机算法
- **特点**：确保完整覆盖，避免遗漏区域
- **切换条件**：发现目标时自动切换到寻路模式

#### 寻路模式
- **目标**：从当前位置到达指定目标
- **算法**：A*最优路径算法
- **特点**：最短路径，动态避障
- **应用场景**：到达出口、传送门、任务点等

### 2. 智能目标识别
```python
def detect_targets(frame):
    # HSV颜色空间过滤
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    
    # 亮蓝色目标检测
    lower_blue = np.array([100, 100, 200])
    upper_blue = np.array([120, 255, 255])
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    
    # 轮廓检测
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    targets = []
    for contour in contours:
        if cv2.contourArea(contour) > min_area:
            x, y, w, h = cv2.boundingRect(contour)
            targets.append((x + w//2, y + h//2))
    
    return targets
```

### 3. 地图管理系统
- **全局地图**：5000x5000像素numpy数组
- **坐标系统**：统一的像素坐标系
- **内存优化**：动态区域管理，避免内存溢出
- **持久化**：支持地图数据保存和加载

## 配置指南

### 基础配置
```json
{
  "pathfinding": {
    "enabled": true,
    "exploration_mode": "lawnmower",
    "movement_speed": 150,
    "waypoint_threshold": 15,
    "global_map_size": 5000
  }
}
```

### 探索参数
```json
{
  "exploration_config": {
    "row_height": 50,
    "direction_change_delay": 500,
    "obstacle_detection_threshold": 128,
    "exploration_timeout": 300000
  }
}
```

### 寻路参数
```json
{
  "pathfinding_config": {
    "algorithm": "astar",
    "heuristic": "manhattan",
    "diagonal_movement": true,
    "path_smoothing": true,
    "dynamic_replanning": true
  }
}
```

### 目标检测配置
```json
{
  "target_detection": {
    "color_ranges": {
      "exit": {"hsv_min": [100, 100, 200], "hsv_max": [120, 255, 255]},
      "waypoint": {"hsv_min": [60, 100, 100], "hsv_max": [80, 255, 255]}
    },
    "min_contour_area": 50,
    "detection_interval": 100
  }
}
```

## 使用流程

### 准备阶段
1. **F9准备**：进入寻路模式准备状态
2. **地图初始化**：创建全局地图数据结构
3. **位置校准**：确定玩家在全局地图中的初始位置
4. **目标设置**：配置要寻找的目标类型

### 执行阶段
1. **Z开始**：启动自动寻路
2. **探索模式**：开始系统性地图探索
3. **目标检测**：持续监控目标出现
4. **模式切换**：发现目标时切换到寻路模式
5. **路径执行**：沿A*规划路径移动到目标

### 监控与调试
- **实时地图显示**：可视化当前探索状态
- **路径轨迹**：显示已规划和正在执行的路径
- **状态监控**：实时显示当前模式和执行状态

## 算法详解

### A*路径规划算法
```python
class AStarNode:
    def __init__(self, position, g_cost=0, h_cost=0, parent=None):
        self.position = position
        self.g_cost = g_cost  # 从起点到当前节点的实际代价
        self.h_cost = h_cost  # 从当前节点到目标的启发式代价
        self.f_cost = g_cost + h_cost  # 总代价
        self.parent = parent

def heuristic(pos1, pos2):
    # 曼哈顿距离启发函数
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

def get_neighbors(position):
    # 8方向移动
    directions = [(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]
    neighbors = []
    for dx, dy in directions:
        neighbors.append((position[0] + dx, position[1] + dy))
    return neighbors
```

### 相位相关位移跟踪
```python
def phase_correlate_tracking(img1, img2):
    # 转换到频域
    f1 = np.fft.fft2(img1)
    f2 = np.fft.fft2(img2)
    
    # 计算相位相关
    cross_power_spectrum = f1 * np.conj(f2)
    cross_power_spectrum /= np.abs(cross_power_spectrum)
    
    # 逆变换得到相关结果
    correlation = np.fft.ifft2(cross_power_spectrum)
    
    # 找到峰值位置
    peak_position = np.unravel_index(np.argmax(correlation), correlation.shape)
    
    # 计算位移
    displacement = calculate_displacement(peak_position, img1.shape)
    
    return displacement
```

## 性能优化

### 计算优化
- **ROI处理**：仅处理感兴趣区域，减少计算量
- **图像缩放**：在保持精度的前提下缩小处理图像
- **并行计算**：利用多线程处理图像和路径计算

### 内存优化
- **动态加载**：按需加载地图区域数据
- **数据压缩**：压缩存储不常用的地图区域
- **垃圾回收**：及时清理不需要的图像数据

### 算法优化
```python
# A*算法优化
class OptimizedAStar:
    def __init__(self):
        self.path_cache = {}  # 路径缓存
        self.heuristic_cache = {}  # 启发函数缓存
    
    def find_path_cached(self, start, goal, obstacles):
        cache_key = (start, goal, hash(obstacles.tobytes()))
        if cache_key in self.path_cache:
            return self.path_cache[cache_key]
        
        path = self.find_path(start, goal, obstacles)
        self.path_cache[cache_key] = path
        return path
```

## 扩展功能

### 多层地图支持
- 支持不同楼层的地图管理
- 楼层间的传送点识别
- 3D坐标系统

### 智能避障
- 动态障碍物检测
- 实时路径重规划
- 碰撞预测和避免

### 协作寻路
- 多角色协调移动
- 队伍集合点规划
- 分布式探索策略

## 故障排除

### 常见问题

1. **地图拼接错位**
   - 检查相位相关算法参数
   - 验证坐标转换逻辑
   - 确认图像预处理质量

2. **路径规划失败**
   - 检查障碍物检测准确性
   - 验证A*算法参数设置
   - 确认目标点可达性

3. **移动执行不准确**
   - 校准屏幕坐标转换
   - 调整移动向量计算
   - 检查输入延迟设置

### 调试工具
- **地图可视化**：实时显示全局地图状态
- **路径追踪**：显示规划路径和实际移动轨迹
- **性能监控**：监控算法执行时间和内存使用

### 参数调优
```python
# 调试参数配置
debug_config = {
    "visualization": {
        "show_global_map": True,
        "show_current_path": True,
        "show_explored_areas": True,
        "update_interval": 100
    },
    "logging": {
        "log_movement": True,
        "log_pathfinding": True,
        "log_map_updates": True,
        "log_level": "DEBUG"
    }
}
```