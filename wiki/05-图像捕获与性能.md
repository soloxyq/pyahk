# 05 图像捕获与性能

本章详细介绍pyahk的图像捕获技术、模板匹配算法与性能优化策略，重点讲解基于DXGI的零拷贝屏幕捕获技术和高效的图像处理管道。

---
## 1. 核心捕获技术

### DXGI Desktop Duplication 零拷贝实现
```cpp
// C++底层实现 - capture_lib.cpp
class DXGICaptureSession {
    // 双缓冲区设计
    std::vector<uint8_t> buffer_a;
    std::vector<uint8_t> buffer_b;
    
    // 原子指针，指向当前可读缓冲区
    std::atomic<uint8_t*> current_read_buffer;
    
    // 写入缓冲区切换标志
    bool writing_to_a = true;
};
```

### Python层零拷贝接口
```python
# python_wrapper.py
def get_frame(self, session_id: int) -> Optional[np.ndarray]:
    """Zero-Copy NumPy Array Creation"""
    frame_ptr = self._lib.capture_get_frame(handle)
    # 直接使用C++内存创建NumPy数组
    # 注意：返回的数组与C++共享内存，应立即处理
```

### 架构数据流
```
DXGI Desktop Duplication (C++) 
    ↓ 零拷贝共享内存
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发到各检测模块
SkillManager/ResourceManager/PathfindingManager
```

---
## 2. 准备阶段 (READY)
- F8/F9 进入 READY 时只执行一次：
  - `capture_once_for_debug_and_cache()`：获取静态帧（用于调试对比/日志）
  - `capture_template_hsv()`：截取 HP/MP 区域转换 HSV 模板
  - 技能冷却图标：可在首次检测时延迟截取或使用坐标矩形局部提取

目的：冻结一组稳定参考，避免运行期间背景波动影响模板。

---
## 3. 技能冷却检测

| 步骤 | 描述 |
|------|------|
| 1 | 通过坐标 + Size 提取正方形 ROI |
| 2 | 计算与缓存模板的 RGB 相似度 (阈值默认 95%) |
| 3 | 高于阈值判定为“Ready”，否则处于冷却或未知 |

优化建议：
- 降低 ROI 尺寸以减少噪声（典型 12~20 像素）
- 跳过启用=false 的技能
- 合并多技能 ROI 提取（未来批处理）

---
## 4. 资源 (HP/MP) HSV 模板匹配

流程：
1. READY 阶段缓存 HSV 模板 (region → HSV 转换)
2. 运行时 ROI → HSV → 按容差范围统计匹配像素比例
3. 计算剩余百分比 vs threshold → 判定是否触发

技巧：
- H 值环绕：差值 >180 → 360-差值
- 容差不宜过大，否则“假满”
- 可引入“双段阈值 + 滞后”减少抖动

---
## 5. 模板缓存策略

| 类型 | 位置 | 更新时机 |
|------|------|----------|
| HP/MP HSV | ResourceManager / BorderFrameManager | READY / 手动刷新 |
| 技能图标 | BorderFrameManager | 首次冷却检测或 READY 捕获 |
| 调试帧 | debug_frame_xxxx.png | 每次准备 / 手动触发 |

清理：未来可添加 LRU 或按分辨率/版本签名失效。

---
## 🚀 6. 智能调度与性能优化 (最新架构)

### 优先级按键暂停/恢复机制

#### 性能优化背景
传统实现存在严重的"零功效资源浪费"问题：
- ❌ 优先级按键激活时，技能执行虽被阻塞，但调度器仍在运行
- ❌ `check_cooldowns`、帧捕获、像素分析等CPU密集操作持续执行但结果被丢弃
- ❌ 在手动操作期间消耗大量不必要的计算资源

#### 新架构解决方案
实现事件驱动的智能暂停/恢复机制：

```python
# 性能监控数据
性能提升指标：
- CPU使用率降低：70-90% (在暂停期间)
- 帧捕获停止：完全避免无效的屏幕捕获
- 像素分析暂停：停止HSV计算和模板匹配
- 调度任务数：从N个活跃任务降至0个
```

#### 事件驱动流程
```
优先级按键按下 (space/right_mouse)
    ↓
InputHandler._on_key_press() - 检测并记录
    ↓
第一个优先级按键 → _pause_skill_scheduler()
    ↓
event_bus.publish('scheduler_pause_requested')
    ↓
SkillManager._on_scheduler_pause_requested()
    ↓
unified_scheduler.pause() - 暂停所有调度任务
    ↓
🛑 系统进入"零计算"模式

优先级按键释放
    ↓
所有优先级按键释放 → _resume_skill_scheduler()
    ↓
event_bus.publish('scheduler_resume_requested')
    ↓
SkillManager._on_scheduler_resume_requested()
    ↓
unified_scheduler.resume() - 智能恢复调度
    ↓
▶️ 重新计算任务时间并恢复运行
```

#### 智能恢复算法
```python
def resume(self) -> bool:
    """智能恢复 - 避免任务堆积执行"""
    self._paused = False
    current_time = self._now()
    
    # 🔥 关键：重新计算所有任务的下次执行时间
    for task in self._tasks.values():
        if task.enabled:
            task.next_run_time = current_time + task.interval
    
    self._rebuild_heap()  # 重建优先级堆
    self._condition.notify()  # 唤醒调度线程
    return True
```

**智能恢复特点**：
- 避免恢复时的"任务雪崩"
- 重新计算时间，确保任务正常间隔执行
- 线程安全的状态切换

### 7. 任务频率规划 (优化版)

| 任务 | 推荐间隔 | 暂停优化 | 说明 |
|------|----------|----------|------|
| 冷却检测 | 120~200ms | ✅ 暂停 | 优先级按键时完全停止 |
| 药剂检测 | 150~250ms | ✅ 暂停 | 手动操作时无需检测 |
| Debug 发布 | ≥200ms | ✅ 暂停 | UI刷新在暂停时也停止 |
| 寻路重规划 | 300~500ms | ✅ 暂停 | 手动移动时停止自动寻路 |
| 帧捕获 | 100ms | ✅ 暂停 | 最大的CPU节约来源 |

### 8. 性能监控指标

#### CPU使用率对比
```
传统模式 (优先级按键激活时)：
- 帧捕获：持续进行 (高CPU)
- 冷却检测：持续执行但结果丢弃 (中CPU)  
- 像素分析：HSV计算但不产生效果 (中CPU)
- 总体：浪费约60-80%计算资源

新架构 (优先级按键激活时)：
- 帧捕获：完全停止 ✅
- 冷却检测：调度器暂停 ✅
- 像素分析：无帧数据输入，自然停止 ✅
- 总体：CPU使用率降低70-90% ✅
```

#### 内存优化效果
- **帧缓存**：暂停期间不产生新的帧数据
- **处理队列**：输入队列继续工作，但计算队列空闲
- **模板数据**：保持缓存，恢复时立即可用

#### 响应性提升
- **按键延迟**：减少CPU竞争，提升按键响应速度
- **帧率稳定**：游戏帧率更稳定，减少后台干扰
- **系统负载**：整体系统负载显著降低

这个架构实现了真正的"按需计算"，只在实际需要时消耗系统资源，大大提升了整体性能表现。

---
## 7. 性能瓶颈常见来源与优化建议

### 常见性能瓶颈
- **检测方法选择不当**：使用OCR而非矩形检测（性能差82-803倍）
- 过多高频 Scheduler 任务（<80ms）
- 每次检测重复 `cv2.cvtColor` / 过大 ROI
- 不必要的深拷贝 (np.array(frame))
- 频繁磁盘 IO（调试帧保存过多）
- 大量 DEBUG 日志字符串拼接

### 检测方法性能对比（实测478次）

| 方法 | 平均耗时 | 成功率 | 准确率 | 速度优势 |
|------|----------|--------|--------|----------|
| 矩形检测 | 0.3ms | 100% | 96%误差<5% | 基准 |
| 圆形检测 | ~5ms | 99%+ | 95%+ | 慢17倍 |
| Template OCR | 25ms | 98.3% | 90-95% | 慢82倍 |
| Keras OCR | 99ms | 98.5% | >99% | 慢330倍 |
| Tesseract OCR | 241ms | 99.0% | 95-100% | 慢803倍 |

**优化建议**：优先使用矩形检测或圆形检测，避免不必要的OCR计算。

---
## 8. 优化策略清单

| 场景 | 策略 | 性能提升 |
|------|------|----------|
| **检测方法选择** | **使用矩形/圆形检测替代OCR** | **82-803倍** |
| 优先级按键期间 | 启用智能暂停/恢复机制 | 70-90% CPU |
| ROI 过大 | 缩小至核心像素区域 | 中等 |
| HSV 转换重复 | 缓存同一帧的 HSV 版（需衡量内存） | 中等 |
| 模板抖动 | 增加连续性窗口 / 移动平均 | 小 |
| CPU 占用高 | 合并任务间隔；调试发布降频 | 中等 |
| 图像检测延迟 | 使用整型运算 / 向量化替代循环 | 小 |

**最重要的优化**：选择正确的检测方法！矩形检测比OCR快82-803倍，且准确率更高。

---
## 9. 性能评估建议

### 基准测试工具
- **完整benchmark**: `python performance_test/perf_full_benchmark.py`
  - 测试所有检测方法的性能和准确率
  - 自动生成详细统计报告
  - 识别OCR错误案例

### 性能监控指标
- **采集周期**：统计 scheduler 实际执行延迟（计划 vs 实际）
- **帧耗时**：在关键算法块加时间差日志（DEBUG 模式）
- **资源曲线**：将 HP/MP 比例定期写入结构（后期可视化）
- **检测方法对比**：记录不同方法的耗时和准确率
- **暂停/恢复统计**：优先级按键期间的CPU节约率

---
## 10. 未来增强方向

### 短期优化
- ✅ **矩形检测算法优化**：已从"最长连续段"改为"总填充行数"，准确率提升至96%
- ✅ **HSV容差可配置**：已支持从JSON配置文件调整容差参数
- 批量 ROI 提取（一次切片返回多个区域）
- 自适应调度（空闲期自动加大间隔）

### 长期优化
- SIMD / Numba 加速 HSV 匹配
- GPU 加速（CUDA/OpenCL）
- 模板质量评分 + 自动重采样提示
- 机器学习优化HSV容差参数

### 已完成的优化
- ✅ 矩形检测性能：0.3ms，比OCR快82-803倍
- ✅ 智能暂停/恢复：优先级按键期间节省70-90% CPU
- ✅ 零拷贝屏幕捕获：DXGI双缓冲区设计

---
本章完。返回目录：`README` 或继续阅读下一章节。
