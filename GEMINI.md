# pyahk - 高性能ARPG游戏自动化辅助工具

一个基于 Python 和 C++ 的现代化桌面游戏自动化辅助工具，专为 ARPG 游戏（如《暗黑破坏神 4》、《流放之路 2》等）设计。采用先进的**事件驱动架构**和**零拷贝屏幕捕获技术**，提供毫秒级响应的技能循环自动化、智能药剂管理（支持双色检测）、装备词缀洗练、自动寻路和热键管理等功能。项目采用现代化的分层架构设计，集成技能优先级系统，确保卓越的性能表现和用户体验。

## 项目概述

**pyahk** 是一个强大的ARPG游戏自动化辅助工具，由Python与C++合作开发。项目面向《暗黑破坏神4》、《流放之路2》等现代ARPG游戏设计，提供毫秒级的高性能游戏操作自动化。

与传统的AutoHotkey脚本相比，pyahk采用现代化的技术架构：

- **事件驱动架构**：所有组件通过中央事件总线进行通信，实现高度解耦
- **零拷贝捕获技术**：基于Windows Graphics Capture API的C++底层实现，极大降低性能开销
- **统一调度器**：取代传统多线程模型，提供更精确的定时任务管理
- **模块化设计**：清晰的功能分离，易于维护和扩展

## 项目入口

pyahk提供两种使用方式：

1. **GUI版本** (`main.py`)：完整的图形用户界面，支持所有功能模块的可视化配置和控制
2. **命令行版本** (`main_special.py`)：轻量级版本，专注于特定游戏场景的自动化任务

## 核心功能特性

- **零拷贝屏幕捕获技术**: 利用现代Windows Graphics Capture API和C++底层实现，Python层通过ctypes直接访问帧数据，避免内存拷贝开销，确保毫秒级响应速度
- **事件驱动架构**: 系统核心组件通过中央事件总线(EventBus)进行通信，实现完全解耦，极大提高代码可维护性和可扩展性
- **统一调度器**: 基于heapq的单线程调度器，管理所有定时任务，取代传统多线程模型，显著降低资源开销并提高计时精度
- **智能药剂管理**: 采用先进的HSV双色检测算法，支持正常/中毒状态智能识别，支持HP/MP的精确检测和自动喂药功能，内置1080P优化配置，支持内部冷却机制防止药水浪费
- **装备词缀洗练**: 独立的F7热键控制模块，采用三状态智能识别，通过PaddleOCR进行词缀识别，支持实时OSD反馈
- **自动寻路与探索**: 采用相位相关位移跟踪和A*算法，实现随机地图的自主探索和精确路径规划，支持双模式运行
- **模式互斥逻辑**: 严格区分"技能模式"、"洗练模式"和"寻路模式"，确保逻辑清晰、行为可预测
- **技能触发系统**: 支持定时(Timer)、冷却(Cooldown)与按住(Hold)。按住由 AHK 服务执行，仅在状态切换时一次性按/放，不进入任何循环或定时任务。集成技能优先级系统，高优先级技能在检查和执行队列中都享有优先权。
- **音频反馈系统**: 通过预置音频文件为启动、停止、暂停和恢复等操作提供无延迟声音提示

## 自动寻路功能详解 (已实现)

本项目的高级功能，旨在实现对随机生成地图（如《暗黑破坏神 4》的地牢）的自主探索和路径规划。该功能采用**新架构设计**，通过 **F9** 热键准备寻路模式，**Z** 键执行寻路任务。目前已完成三个阶段的全面实现。

其核心技术方案分为三个阶段：

### 第一阶段：地图解读与拼接 (已实现)

此阶段的目标是将游戏小地图的像素图像，翻译并拼接成一张程序可以理解的、持久化的全局地图。

1.  **路径提取**: 程序利用 `OpenCV` 对小地图截图进行**颜色过滤**。通过`cv2.cvtColor`转为灰度图后，使用`cv2.threshold`将小地图中颜色较亮的、可通行的路径区域提取出来，生成一张只包含路径的二值化“蒙版”（Mask）。这一步直接过滤掉了地图背景、怪物标记等所有动态“噪音”。
2.  **图像优化**: 为了让路径数据更可靠，会使用`cv2.morphologyEx`和“闭运算”(`MORPH_CLOSE`)、“开运算”(`MORPH_OPEN`)来填补路径线条中的微小断裂，并移除孤立的噪点，得到一张干净、完整的路径图。
3.  **地图位移追踪**: 由于游戏小地图是“玩家在中心，地图移动”的模式，程序会对比**连续两帧**的“纯净路径图”，使用`cv2.phaseCorrelate`（相位相关）技术，精确计算出地图滚动的像素位移`(dx, dy)`。
4.  **全局地图拼接**: 程序在内存中维护一张巨大的“全局地图”（如 5000x5000 的`numpy`数组）。根据计算出的位移，它就能反推出玩家在全局地图上的绝对坐标，并将当前看到的新路况，通过`cv2.add`操作“拼接”到全局地图的正确位置上，像拼图一样，逐步扩大已探索的区域。

### 第二阶段：探索与路径规划 (已实现)

在拥有了绘制地图的能力后，程序需要一个策略来探索未知区域。

1.  **“Z 字形/除草机”探索算法**: 在没有最终目标的情况下，程序采用一种系统性的‘除草机’算法来遍历地图。它会控制角色沿一个方向（如“右”）持续移动，直到在**已拼接的全局地图**上探测到前方有障碍物。然后，角色会向下移动一小段固定距离，并掉转方向（变为“左”）继续移动，如此往复，确保以 Z 字形路径完整地覆盖所有可探索区域，避免走回头路。
2.  **A\*寻路 (已实现)**: 一旦目标（如出口的独特图标）出现在视野中，并被记录到全局地图上后，程序将立即停止探索，并在已拼接的全局地图上运行 **A\*** 算法，规划出从玩家当前位置到目标的**最优路径**。实现了完整的路径规划、路点跟随和模式切换逻辑。

### 第三阶段：寻路执行 (已实现)

此阶段的目标是控制角色，精准地沿着规划好的路径移动。

1.  **方向向量**: 因为玩家永远在小地图中心，所以路径上的任何一个路点（Waypoint）都天然地代表了一个从玩家出发的**方向向量**。
2.  **路点跟随**: 实现了完整的路点跟随算法，支持精确的距离判断和路点切换。程序会根据当前位置与目标路点的距离，计算精确的方向向量，并在游戏主屏幕的相应位置模拟鼠标点击，驱动角色沿着 A\*规划的最优路径精确移动。同时支持暂停/恢复功能和模式智能切换。
3.  **移动执行**: 使用 InputHandler 的 click_mouse_at 方法在屏幕坐标(960, 540)为中心，根据计算出的方向向量和距离(150 像素)确定点击位置，实现精确的角色移动控制。

## 智能药剂助手详解 (已实现)

专为 ARPG 游戏设计的智能药剂管理系统，采用职责清晰的**三层委托架构**，实现了精确的血蓝条检测和自动喝药功能。该系统将调度、业务逻辑和底层检测完全分离，确保了代码的高度可维护性和扩展性。

### 核心技术方案：三层委托架构

药剂的检测和执行流程贯穿三个核心模块，每一层都只负责自己的核心职责，并将其他任务委托给下一层。

#### 第 1 层: `SkillManager` (调度层)

`SkillManager` 作为顶层的调度中心，它不关心药剂的具体逻辑。它只负责通过其内部的 `UnifiedScheduler`，按固定的时间间隔（例如200ms）启动一个名为 `check_resources` 的任务。

```python
# in SkillManager
def check_resources(self):
    """独立的资源管理检查任务（被统一调度器调用）"""
    if not self._is_running or self._is_paused or not self.resource_manager:
        return

    # 1. 获取当前帧，为所有检测做准备
    cached_frame = self._prepare_frame_detection_cache()
    if cached_frame is None:
        return

    # 2. 将帧数据和执行权完全委托给 ResourceManager
    self.resource_manager.check_and_execute_resources(cached_frame)
```

#### 第 2 层: `ResourceManager` (业务逻辑层)

`ResourceManager` 是药剂功能的“大脑”，负责所有业务逻辑。它是一个被动的、无独立线程的模块。

1.  **接收调度**: 接收 `SkillManager` 的调用和帧数据。
2.  **管理冷却**: 检查药剂自身的内部冷却时间（`_check_internal_cooldown`），防止浪费。
3.  **决策**: 判断是否需要使用药剂（`_should_use_hp_resource`）。
4.  **委托检测**: 当需要判断血量/蓝量是否低于阈值时，它**不会自己进行图像计算**，而是将这个任务再次委托给底层的 `BorderFrameManager`。
5.  **执行操作**: 如果所有条件满足，则调用 `InputHandler` 执行按键。

```python
# in ResourceManager
def _is_resource_low(self, resource_type: str, cached_frame: Optional[np.ndarray]) -> bool:
    """检查资源是否低于阈值"""
    config = self.hp_config if resource_type == "hp" else self.mp_config
    threshold = config.get("threshold", 50)
    region_x1, region_y1, x2, y2 = self._get_region_from_config(config)
    
    # 将检测任务委托给 BorderFrameManager，并传入特定名称 "hp_region"
    is_sufficient = self.border_frame_manager.compare_cooldown_image(
        cached_frame, region_x1, region_y1, f"{resource_type}_region", size, threshold
    )

    # 返回取反结果（匹配度高=资源足，所以取反表示需要喝药）
    return not is_sufficient
```

#### 第 3 层: `BorderFrameManager` (统一检测层)

`BorderFrameManager` 是所有图像比对功能的**统一检测核心**。它提供了一个名为 `compare_cooldown_image` 的通用接口。

1.  **接收请求**: 接收来自 `ResourceManager`（药剂检测）或 `SkillManager`（技能冷却检测）的调用。
2.  **智能路由**: 该方法内部通过检查传入的 `skill_name` 参数来区分任务类型。如果名称是 `"hp_region"` 或 `"mp_region"`，它就调用药剂检测的专用算法；否则，执行技能冷却的RGB比对算法。
3.  **执行检测**: 调用内部私有的 `_compare_resource_hsv` 方法，该方法负责执行真正的 **HSV 模板匹配** 算法，比较当前帧与F8准备时缓存的HSV模板，并返回匹配度。

```python
# in BorderFrameManager
def compare_cooldown_image(self, frame, x, y, skill_name, size, threshold) -> bool:
    """统一检测接口，内置任务路由"""
    # 1. 智能路由：检查是否是资源检测任务
    if skill_name in ["hp_region", "mp_region"]:
        # 2. 如果是，则调用专门的HSV比较方法
        return self._compare_resource_hsv(frame, x, y, size, skill_name, threshold)

    # 3. 否则，执行标准的技能冷却RGB比较
    # ... (RGB comparison logic)

def _compare_resource_hsv(self, frame, resource_name, threshold) -> bool:
    """药剂检测专用算法：执行HSV模板匹配"""
    # 1. 从帧中提取区域，并转换为HSV色彩空间
    # 2. 从缓存中获取此资源（如'hp_region'）的HSV模板
    # 3. 逐像素进行带有容差的HSV值比较（特殊处理H色相的环形特性）
    # 4. 计算匹配像素的百分比
    # 5. 如果匹配度低于阈值，则返回True（表示资源充足）
    # ... (Implementation details)
```

### 技术亮点

#### 1. 清晰的分层委托架构
- **职责单一**: `SkillManager` 只管调度，`ResourceManager` 只管业务，`BorderFrameManager` 只管检测。代码清晰，易于维护和测试。
- **高度解耦**: 任何一层的内部实现（例如`BorderFrameManager`未来改用更先进的算法）都不会影响到上层模块的接口和调用方式。

#### 2. 统一调度与被动执行
- **无独立线程**: `ResourceManager` 是一个被动模块，不创建自己的线程，由 `SkillManager` 的统一调度器驱动，从根源上避免了多线程的复杂性和资源竞争。
- **帧复用**: `SkillManager` 在每次调度循环开始时获取一次屏幕帧，然后将这个帧数据传递给所有需要它的模块，避免了重复截图的性能开销。

#### 3. 统一检测核心
- **代码复用**: 技能冷却和药剂检测共享同一个底层入口 (`compare_cooldown_image`) 和同一套模板缓存系统，最大化了代码复用。
- **易于扩展**: 未来如果需要添加新的检测类型（例如“怒气”检测），只需在 `BorderFrameManager` 的路由逻辑中增加一个新的分支，而无需修改上层业务代码。

### 功能特性

#### 1. 现代化配置界面

- **独立 TAB 页**：专门的"智能药剂"配置标签页
- **HP/MP 分离配置**：血药和蓝药完全独立的配置区域
- **1080P 默认值**：针对 1080P 屏幕优化的默认坐标和颜色值
- **全局设置**：可配置的检测间隔(50-1000ms)，默认 200ms

#### 2. 默认配置优化 (1080P)

```
# 血药默认配置
hp_defaults = {
    "region": (136, 910, 213, 1004),    # 1080P血条区域
    "hsv": (314, 75, 29),               # 血药颜色HSV
    "tolerance": (10, 20, 20),          # 颜色容差
    "threshold": 50,                    # 50%触发阈值
    "cooldown": 5000,                   # 5秒冷却
    "key": "1"                          # 默认按键
}

# 蓝药默认配置
mp_defaults = {
    "region": (1552, 910, 1560, 1004), # 1080P蓝条区域
    "hsv": (208, 80, 58),               # 蓝药颜色HSV
    "tolerance": (7, 5, 5),             # 更严格的容差
    "threshold": 50,                    # 50%触发阈值
    "cooldown": 8000,                   # 8秒冷却
    "key": "2"                          # 默认按键
}
```

#### 3. 区域选择与颜色拾取工具

- **界面隐藏**: 点击"📦 选择区域"或"🎨 拾取颜色"时主界面自动隐藏，提供全屏操作体验。
- **可视化操作**: 支持拖拽选择区域、放大镜像素拾取、实时HSV值显示等功能。

#### 4. 战斗模式集成

- **F8 启动**: 按 F8 进入战斗模式，`SkillManager` 的调度器启动，药剂检测任务自动开始。
- **状态同步**: 与战斗系统完全同步，支持暂停/恢复。

### 使用流程

#### 配置阶段

1. **启动程序**：运行 main.py 进入 GUI 界面。
2. **选择 TAB**：点击"智能药剂"TAB 进入配置。
3. **配置参数**: 1080P 用户可直接使用默认配置。其他用户可通过“选择区域”和“拾取颜色”工具自定义区域和颜色参数，并设置触发阈值和冷却时间。

#### 战斗阶段

1. **进入游戏**：启动目标游戏。
2. **启动辅助**：按 F8 进入战斗模式。
3. **自动检测**: 系统将根据配置的“检测间隔”自动执行三层委托检测。
4. **智能喝药**: 当 `ResourceManager` 判断药剂需要使用且冷却已就绪时，会自动按下对应按键。
5. **退出辅助**: 再次按 F8 退出战斗模式。

### 配置示例

```json
{
  "resource_management": {
    "hp_config": {
      "enabled": true,
      "key": "1",
      "threshold": 50,
      "cooldown": 5000,
      "region_x1": 136,
      "region_y1": 910,
      "region_x2": 213,
      "region_y2": 1004,
      "target_h": 314,
      "target_s": 75,
      "target_v": 29,
      "tolerance_h": 10,
      "tolerance_s": 20,
      "tolerance_v": 20
    },
    "mp_config": {
      "enabled": true,
      "key": "2",
      "threshold": 50,
      "cooldown": 8000,
      "region_x1": 1552,
      "region_y1": 910,
      "region_x2": 1560,
      "region_y2": 1004,
      "target_h": 208,
      "target_s": 80,
      "target_v": 58,
      "tolerance_h": 7,
      "tolerance_s": 5,
      "tolerance_v": 5
    },
    "check_interval": 200
  }
}
```

## 技能配置系统优化 (已完成)

为了提高系统的准确性和可维护性，我们对技能配置系统进行了全面的清理和优化：

### 触发模式说明

- 现支持三种实际工作的触发模式：
  - `TriggerMode = 0`: 定时模式（Timer）- 基于固定时间间隔执行技能
  - `TriggerMode = 1`: 冷却模式（Cooldown）- 基于技能图标冷却状态执行技能
  - `TriggerMode = 2`: 按住模式（Hold）- 进入运行状态时一次性按下；暂停/停止时一次性释放，由 AHK 服务执行
- 说明：按住模式不参与任何循环或定时任务，仅由 SkillManager 在状态切换与配置变更时一次性触发。

### 技能优先级系统

- **双重优先级机制**: 技能系统实现了完整的优先级处理，确保核心技能优先执行
  - **检查优先级**: 高优先级技能在冷却检测时优先检查和执行
  - **队列优先级**: 高优先级技能的按键会被插入到输入队列的最前端，确保立即执行
- **优先级字段**: `Priority: true/false` - 控制技能的执行优先级
- **应用场景**: 核心输出技能设为高优先级，确保在关键时刻优先释放

### 配置分离优化

- **Resource 配置独立**: 智能药剂功能的配置完全独立于技能配置
- **UI 界面分离**: 技能配置界面移除了 resource 相关字段，添加友好提示指向"智能药剂"标签页
- **配置结构清晰**: 避免了配置混乱和字段冲突

### 代码清理成果

```
# 优化后的技能配置结构
{
  "Enabled": true,
  "Priority": false,    // 高优先级：检查优先 + 队列前端插入
  "Timer": 1000,
  "TriggerMode": 0,     // 0=定时, 1=冷却, 2=按住(Hold, 仅一次性按/放)
  "CooldownCoordX": 0,
  "CooldownCoordY": 0,
  "CooldownSize": 12,
  "ExecuteCondition": 0,
  "AltKey": ""
}
```

### 用户体验改进

- **配置更准确**: 不会产生无效的配置项
- **界面更清晰**: 只显示实际可用的选项
- **维护更容易**: 减少了混淆和错误配置的可能性

## 按住（Hold）集成说明

- 设计目标：在“定时/冷却”之外，新增“按住”这一持续性输入能力，但不进入循环或定时任务，仅在状态切换时一次性执行。
- UI 配置：技能“触发方式”下拉框包含 定时/冷却/按住 三项；选择按住时会隐藏不相关的定时/冷却参数。
- 执行路径：
  - InputHandler：仅将 hold_key/release_key 委托给 AHK（WM_COPYDATA，窗口标题默认为 "HoldServer_Window_UniqueName_12345"；支持组合键如 "ctrl+shift+w"）。
  - SkillManager：负责“按住”的生命周期管理
    - start：先释放残留，再启动调度，随后一次性按住所有 TriggerMode=2 的技能键
    - resume：一次性重新按住
    - pause/stop：一次性释放
    - 配置热更新：在运行且未暂停时，按增量对齐（新增按住、移除释放）
  - MacroEngine：不再直接处理“按住”，避免与 SkillManager 重复。
- AHK 服务：
  - 使用 hold_server.ahk（已精简为仅处理 hold/release）。Python 侧通过 WM_COPYDATA 发送 "hold:key" / "release:key"。
  - 未安装/未运行 AHK 时：仅“按住”功能失效（发送失败返回 False），其他功能（定时、冷却、点击、寻路、洗练、药剂）全部正常。
- 使用步骤：
  1) 启动 hold_server.ahk（若自定义窗口名，请在程序中设置对应标题）
  2) 在技能配置中选择“按住”，并填写 Key（支持组合键用“+”连接）
  3) F8 准备 → Z 运行：会一次性按下；Z 暂停/停止：会一次性释放

## 架构设计

本工具采用分层和模块化的设计，其核心组件和职责如下：

- **`MacroEngine` (宏引擎)**: 作为项目的**状态与事件协调中心**。它负责管理程序的核心状态，并作为**资源调度中心**，根据当前模式（战斗、洗练、寻路）动态指挥底层捕获模块切换最高效的工作模式。
- **`SkillManager` (技能管理器)**: **技能调度中心**。它利用其内部的 `UnifiedScheduler` 实例，管理所有技能和药剂检测的定时任务，并作为顶层协调者，将药剂相关的业务逻辑委托给 `ResourceManager`。
- **`SimpleAffixRerollManager` (智能洗练管理器)**: **装备洗练引擎**。一个完全独立的模块，在自己的线程中运行，负责执行所有与装备洗练相关的自动化流程。
- **`PathfindingManager` (寻路管理器)**: **自动寻路引擎**。采用统一状态管理架构，由`MacroEngine`统一调度启停、暂停和恢复。在独立的线程中运行，持续地从`BorderFrameManager`获取屏幕数据，通过图像处理来解读小地图，利用相位相关技术追踪地图位移，并将探索到的地图拼接成一张完整的全局地图。支持双模式运行（探索模式和寻路模式）、实时目标识别和 A\*路径规划。
- **`InputHandler` (输入处理器)**: **输入执行与队列管理中心**。它封装了键盘和鼠标的模拟输入操作，并独立管理一个按键队列。
- **`UnifiedScheduler` (统一调度器)**: 项目定时任务的心脏。一个基于`heapq`的单线程循环，能够高效、精确地管理成百上千个不同间隔的定时任务。
- **`ResourceManager` (资源管理器)**: **药剂业务逻辑模块**。一个被动的、无独立线程的模块，负责药剂的**冷却管理**和**按键执行决策**。它被 `SkillManager` 调度，并将底层的图像检测任务委托给 `BorderFrameManager`。
- **`BorderFrameManager` (边框图管理器)**: **统一检测核心**。它提供一个 `compare_cooldown_image` 接口，内部能够智能区分技能冷却（RGB比较）和药剂检测（HSV模板匹配），为所有上层模块提供统一的、带缓存的检测服务。
- **`NativeGraphicsCaptureManager` (原生图形捕获管理器)**: 封装 C++捕获库，提供高性能的屏幕捕获服务。支持全屏或指定区域捕获，采用零拷贝技术和智能帧率控制。
- **`EventBus` (事件总线)**: 基于发布/订阅模式，实现各模块间的异步通信，支持 ThreadPoolExecutor 优化的事件处理，是整个架构的神经中枢。包含递归事件检测和性能监控功能。
- **`ConfigManager` (配置管理器)**: 负责配置文件的加载、保存和管理。支持 JSON 格式配置文件的读写操作。
- **`PaddleOcrManager` (OCR 管理器)**: 一个工具类，负责管理 PaddleOCR 引擎的生命周期，采用按需加载和性能优化配置。支持异步初始化和错误处理。
- **`HotkeyManager` (热键管理器)**: 基于 Windows API 的低级键盘钩子管理器，支持热键的动态注册、注销和条件抑制。
- **`SoundManager` (声音管理器)**: 管理音频反馈的播放，使用 winsound 库实现非阻塞音频播放。
- **`WindowUtils` (窗口工具)**: 提供窗口检测、激活和管理功能，支持进程名和窗口类名的查找。
- **`DebugLog` (调试日志)**: 基于环境变量的条件日志系统，支持不同级别的日志输出。

## 使用方法

1.  **启动程序**:

    - **完整版本**: 运行 `main.py`，启动包含完整 GUI 界面的版本。
    - **简化版本**: 运行 `main_special.py`，启动命令行版本（专注于特定自动化任务，需要管理员权限）。

2.  **配置**: 在"技能配置"、"目标窗口"、"时间间隔/声音"、"原地模式"、"洗练"、"寻路"、"智能药剂"等标签页中完成您的配置。支持加载/保存 JSON 格式的配置文件。

3.  **热键操作**:

    - **F8 (主控键)**: 准备/停止**技能模式**（包含智能药剂功能）。
    - **F7 (洗练键)**: 启动/停止**装备洗练模式**（需要先加载 OCR 引擎）。
    - **F9 (寻路键)**: 准备/停止**自动寻路模式**。
    - **Z (执行/暂停键)**: 在"准备"状态下，按下 Z 键，开始执行对应的任务（技能或寻路）。在"运行"状态下，按下 Z 键，暂停任务。在"暂停"状态下，再次按下 Z 键，恢复任务。
    - **原地模式热键**: 可配置的热键，用于切换原地释放技能模式。
    - **交互/强制移动键**: 可配置的热键，用于临时屏蔽技能执行。

4.  **特殊功能**:
    - **序列模式**: 支持按预设顺序循环执行多个技能。
    - **原地模式**: 支持两种实现方式 - Shift 修饰符或阻止鼠标键。
    - **窗口激活**: 自动检测并激活目标游戏窗口。

## 技术亮点

### 1. 智能资源管理

- **情景感知的捕获策略**: 程序能够根据当前任务（战斗、寻路、洗练）的实际需求，动态切换屏幕捕获模式。在需要大范围视野时（寻路/战斗）自动切换为全屏捕获，在需要极致 OCR 速度时（洗练）切换为小范围 UI 区域捕获，在空闲时则完全停止捕获，最大限度地平衡了性能开销与功能需求。
- **统一的检测架构**: 技能冷却检测和药剂检测使用相同的底层系统，实现代码最大化复用。药剂检测被巧妙地伪装成特殊的技能冷却检测，共享模板缓存和检测逻辑。
- **智能模板缓存**: 在F8准备阶段统一截取所有检测区域的模板（包括技能图标和药剂区域），支持RGB和HSV双格式缓存，实现高效的模板匹配检测。

### 2. 现代化的 UI 与核心架构

- **事件驱动设计**: 所有核心组件通过中央事件总线进行松耦合通信，逻辑清晰，易于扩展。支持异步事件处理和递归事件检测。
- **统一状态机架构**: 采用革新的两步式操作模式，所有功能模式（技能、洗练、寻路）都遵循 STOPPED→READY→RUNNING→PAUSED 的统一状态流转，确保用户体验一致性和操作安全性。
- **清晰的模块化 UI**: UI 层经过重构，将主窗口、各类配置组件和自定义控件完全分离，极大地提升了代码的可读性和可维护性。使用 PySide6 构建现代化界面。
- **线程安全的 UI 更新**: 借助 `QTimer`，所有来自后台线程的 UI 更新请求都会被安全地调度到主线程执行，杜绝了多线程 UI 操作导致的崩溃风险。
- **智能输入处理**: InputHandler 采用队列机制和线程池，确保输入操作的高效执行和状态同步。支持技能优先级队列插入，高优先级按键自动插入队列前端。
- **技能优先级系统**: 实现双重优先级机制，高优先级技能在检查顺序和执行队列中都享有优先权，确保核心技能及时释放。
- **OSD状态显示优化**: 修复多线程UI更新冲突，所有OSD更新都通过QTimer调度到主线程，确保显示稳定性和程序稳定性。

### 3. 高性能与高效率

- **零拷贝屏幕捕获**: 基于 C++和 Windows Graphics Capture API，从根本上消除了内存拷贝开销。Python 层通过 ctypes 直接访问 C++内存缓冲区。
- **高效的任务调度**: 使用基于 `heapq` 的单线程统一调度器，以极低的资源开销精确管理所有定时任务。支持任务的动态添加、移除和间隔更新。
- **"一次捕获，多次使用"**: 图像帧在内存中被复用，避免了重复截图带来的 CPU 性能损耗。BorderFrameManager 负责帧数据的统一管理和分发。
- **智能缓存机制**: 模板缓存和进程缓存减少重复计算，带内存限制和自动清理功能。

### 4. 稳健性与兼容性

- **稳健的错误处理**: 在所有关键路径上都添加了详细的错误日志，告别"静默失败"，便于快速定位问题。支持 DEBUG 环境变量控制日志输出级别。
- **依赖版本管理**: 在 `requirements.txt` 中明确指定依赖版本，保证了开发和部署环境的一致性与可复现性。包含 PySide6、OpenCV、PaddleOCR 等核心依赖。
- **按需加载**: OCR 等重资源模块按需加载，优化了程序的启动速度和资源占用。支持异步初始化和错误恢复。
- **配置清理与简化**: 移除了未实现的功能（如 InternalCooldown），简化了技能触发模式为定时(Timer)、冷却(Cooldown)和按住(Hold)三种，提高了配置的准确性和可维护性。
- **OSD稳定性修复**: 修复多线程UI更新冲突问题，所有OSD更新都通过主线程调度，确保程序运行稳定性和用户界面响应性。
- **跨平台兼容性**: 主要针对 Windows 平台设计，使用 Windows API 实现底层功能，同时保持 Python 层的平台无关性。

### 5. 智能寻路与探索技术

- **先进的地图拼接技术**: 采用`cv2.phaseCorrelate`相位相关算法，实现了亚像素级精度的地图位移追踪，确保全局地图的高精度拼接。支持动态地图更新和内存优化。
- **高效的 A\*路径规划**: 实现了支持 8 方向移动的 A\*算法，支持动态地图更新和实时路径重规划，确保找到最优路径。使用 Node 类和 heapq 实现高效的优先级队列。
- **智能双模式切换**: 在探索模式下采用 Z 字形遍历算法（"除草机"模式），一旦发现目标即刻切换到寻路模式，实现高效的自主探索和精确寻路。
- **实时目标识别**: 通过 HSV 颜色空间过滤和轮廓检测，实现了对游戏中特定目标（如任务点、传送门）的实时识别和定位。支持亮蓝色目标的自动检测。
- **全局地图管理**: 使用 5000x5000 像素的 numpy 数组维护全局地图，支持玩家位置追踪和地图区域的动态拼接。

### 6. 智能药剂技术

- **先进的双色检测算法**: 采用HSV双色检测，支持正常状态和中毒状态的智能识别，实现更精确的资源量估算。
- **统一的检测架构**: 药剂检测本质上是特殊的技能冷却检测，使用相同的底层检测系统，实现代码最大化复用和统一维护。
- **HSV 容差检测算法**: 采用 HSV 颜色空间实现像素级精确匹配，支持环形色相处理和容差范围设置，确保在不同光照条件下稳定检测。
- **被动式检测架构**: 由 SkillManager 统一调度，避免独立线程开销。复用屏幕帧数据，提高整体性能。支持完整的状态管理（启动/暂停/停止）。
- **智能模板缓存**: 在F8准备阶段自动截取并缓存HSV模板，支持动态容差调整，实现精确的模板匹配检测。
- **内部冷却机制**: 实现药水使用间隔控制，防止连续按键浪费药水。支持 HP 和 MP 独立冷却时间设置，带详细的冷却状态日志。
- **1080P 优化配置**: 内置针对 1080P 屏幕优化的默认坐标和颜色值。空配置时自动使用默认值，确保开箱即用的体验。
- **配置分离设计**: resource 配置完全独立于 skill 配置，避免配置混乱。支持配置的部分更新和向后兼容。
- **界面隐藏操作**: 区域选择和颜色拾取时自动隐藏主界面，提供全屏操作体验。操作完成后无缝恢复界面状态。

## 依赖环境与配置

### 系统要求

- **操作系统**: Windows 10/11 (主要支持平台)
- **Python 版本**: 3.7+
- **权限要求**: 部分功能需要管理员权限（如热键监听）

### 核心依赖

```
PySide6>=6.5.0        # GUI框架
psutil>=5.9.0         # 系统进程管理
pynput>=1.7.6         # 键盘鼠标输入控制
Pillow>=9.0.0         # 图像处理
numpy>=1.20.0         # 数值计算
opencv-python>=4.5.0  # 计算机视觉
pywin32>=306          # Windows API接口
paddleocr==2.7.3      # OCR文字识别
```

### 环境配置

- **DEBUG 模式**: 设置环境变量`DEBUG=1`启用详细日志输出
- **代理设置**: 支持 HTTP/HTTPS 代理配置（用于 PaddleOCR 下载）
- **配置文件**: 支持 JSON 格式的配置文件，支持多套配置切换

### 项目结构

```
pyahk/
├── main.py                     # GUI版本主入口
├── main_special.py             # 命令行版本入口
├── requirements.txt            # Python依赖列表
├── *.json                     # 配置文件(default.json, d4.json等)
├── native_capture/            # C++原生捕获库
│   ├── capture_lib.cpp       # C++捕获实现
│   ├── capture_lib.h         # C++头文件
│   ├── python_wrapper.py     # Python ctypes包装器
│   ├── CMakeLists.txt        # CMake构建配置
│   └── build.bat             # Windows构建脚本
└── torchlight_assistant/      # Python主应用包
    ├── core/                  # 核心业务逻辑
    │   ├── macro_engine.py    # 宏引擎：状态管理与事件协调
    │   ├── skill_manager.py   # 技能管理器：统一调度器集成
    │   ├── resource_manager.py # 资源管理器：被动式药剂检测
    │   ├── input_handler.py   # 输入处理器：键鼠队列管理
    │   ├── pathfinding_manager.py # 寻路管理器：A*算法实现
    │   ├── simple_affix_reroll_manager.py # 洗练管理器
    │   ├── event_bus.py       # 事件总线：发布订阅模式
    │   ├── unified_scheduler.py # 统一调度器：heapq实现
    │   ├── config_manager.py  # 配置管理器：JSON处理
    │   └── states.py          # 状态定义：MacroState枚举
    ├── gui/                   # 用户界面层
    │   ├── main_window.py     # 主窗口：集成所有界面组件
    │   ├── status_window.py   # OSD状态窗口
    │   ├── ui_components.py   # UI组件：标签页和控件
    │   ├── resource_widgets.py # 智能药剂配置界面
    │   ├── skill_config_widget.py # 技能配置界面
    │   ├── custom_widgets.py  # 自定义控件
    │   └── styles.py          # 界面样式定义
    └── utils/                 # 工具类层
        ├── native_graphics_capture_manager.py # 原生捕获管理
        ├── border_frame_manager.py # 边框图管理：帧数据分发
        ├── hotkey_manager.py   # 热键管理：Windows API钩子
        ├── paddle_ocr_manager.py # OCR管理：PaddleOCR封装
        ├── sound_manager.py    # 声音管理：音频反馈
        ├── window_utils.py     # 窗口工具：进程查找
        ├── debug_log.py        # 调试日志：条件输出
        └── a_star.py           # A*算法：路径规划实现