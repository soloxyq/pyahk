# 11 图像捕获与性能优化

本章介绍屏幕捕获、模板缓存、图像检测算法与整体性能优化策略，帮助在功能扩展时保持高帧效率与低 CPU 占用。

---
## 1. 捕获架构概述

```
C++ Capture DLL → 共享缓冲 (BGRA) → Python ctypes 映射 → BorderFrameManager 分发
```

特点：
- 零拷贝访问：避免 Python 侧二次复制
- 模式切换：根据当前模式（技能/寻路/洗练）调整捕获区域策略
- 统一帧缓存：同一帧数据被多个检测任务复用

---
## 2. 准备阶段 (READY)
- F8/F9 进入 READY 时只执行一次：
  - `capture_once_for_debug_and_cache()`：获取静态帧（用于调试对比/日志）
  - `capture_template_hsv()`：截取 HP/MP 区域转换 HSV 模板
  - 技能冷却图标：可在首次检测时延迟截取或使用坐标矩形局部提取

目的：冻结一组稳定参考，避免运行期间背景波动影响模板。

---
## 3. 技能冷却检测

| 步骤 | 描述 |
|------|------|
| 1 | 通过坐标 + Size 提取正方形 ROI |
| 2 | 计算与缓存模板的 RGB 相似度 (阈值默认 95%) |
| 3 | 高于阈值判定为“Ready”，否则处于冷却或未知 |

优化建议：
- 降低 ROI 尺寸以减少噪声（典型 12~20 像素）
- 跳过启用=false 的技能
- 合并多技能 ROI 提取（未来批处理）

---
## 4. 资源 (HP/MP) HSV 模板匹配

流程：
1. READY 阶段缓存 HSV 模板 (region → HSV 转换)
2. 运行时 ROI → HSV → 按容差范围统计匹配像素比例
3. 计算剩余百分比 vs threshold → 判定是否触发

技巧：
- H 值环绕：差值 >180 → 360-差值
- 容差不宜过大，否则“假满”
- 可引入“双段阈值 + 滞后”减少抖动

---
## 5. 模板缓存策略

| 类型 | 位置 | 更新时机 |
|------|------|----------|
| HP/MP HSV | ResourceManager / BorderFrameManager | READY / 手动刷新 |
| 技能图标 | BorderFrameManager | 首次冷却检测或 READY 捕获 |
| 调试帧 | debug_frame_xxxx.png | 每次准备 / 手动触发 |

清理：未来可添加 LRU 或按分辨率/版本签名失效。

---
## 6. 任务频率规划

| 任务 | 推荐间隔 | 说明 |
|------|----------|------|
| 冷却检测 | 120~200ms | 过低收益小；避免抢占资源 |
| 药剂检测 | 150~250ms | 高峰时可降低频率 |
| Debug 发布 | ≥200ms | UI 线程安全刷新 |
| 寻路重规划 | 300~500ms | 地图位移 + 目标识别 |

---
## 7. 性能瓶颈常见来源
- 过多高频 Scheduler 任务（<80ms）
- 每次检测重复 `cv2.cvtColor` / 过大 ROI
- 不必要的深拷贝 (np.array(frame))
- 频繁磁盘 IO（调试帧保存过多）
- 大量 DEBUG 日志字符串拼接

---
## 8. 优化策略清单
| 场景 | 策略 |
|------|------|
| ROI 过大 | 缩小至核心像素区域 |
| HSV 转换重复 | 缓存同一帧的 HSV 版（需衡量内存） |
| 模板抖动 | 增加连续性窗口 / 移动平均 |
| CPU 占用高 | 合并任务间隔；调试发布降频 |
| 图像检测延迟 | 使用整型运算 / 向量化替代循环 |

---
## 9. 性能评估建议
- 采集周期：统计 scheduler 实际执行延迟（计划 vs 实际）
- 帧耗时：在关键算法块加时间差日志（DEBUG 模式）
- 资源曲线：将 HP/MP 比例定期写入结构（后期可视化）

---
## 10. 未来增强方向
- SIMD / Numba 加速 HSV 匹配
- 批量 ROI 提取（一次切片返回多个区域）
- 自适应调度（空闲期自动加大间隔）
- GPU 加速（CUDA/OpenCL）
- 模板质量评分 + 自动重采样提示

---
本章完。返回目录：`README` 或继续阅读下一章节。
