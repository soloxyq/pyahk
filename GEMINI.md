# pyahk - 高性能ARPG游戏自动化辅助工具

一个基于 Python 和 C++ 的现代化桌面游戏自动化辅助工具，专为 ARPG 游戏（如《暗黑破坏神 4》、《流放之路 2》等）设计。采用先进的**事件驱动架构**和**零拷贝屏幕捕获技术**，提供毫秒级响应的技能循环自动化、智能药剂管理、装备词缀洗练、自动寻路和热键管理等功能。项目采用现代化的分层架构设计，确保卓越的性能表现和用户体验。

## 项目概述

**pyahk** 是一个强大的ARPG游戏自动化辅助工具，由Python与C++合作开发。项目面向《暗黑破坏神4》、《流放之路2》等现代ARPG游戏设计，提供毫秒级的高性能游戏操作自动化。

与传统的AutoHotkey脚本相比，pyahk采用现代化的技术架构：

- **事件驱动架构**：所有组件通过中央事件总线进行通信，实现高度解耦
- **零拷贝捕获技术**：基于Windows Graphics Capture API的C++底层实现，极大降低性能开销
- **统一调度器**：取代传统多线程模型，提供更精确的定时任务管理
- **模块化设计**：清晰的功能分离，易于维护和扩展

## 项目入口

pyahk提供两种使用方式：

1. **GUI版本** (`main.py`)：完整的图形用户界面，支持所有功能模块的可视化配置和控制
2. **命令行版本** (`main_special.py`)：轻量级版本，专注于特定游戏场景的自动化任务

## 核心功能特性

- **零拷贝屏幕捕获技术**: 利用现代Windows Graphics Capture API和C++底层实现，Python层通过ctypes直接访问帧数据，避免内存拷贝开销，确保毫秒级响应速度
- **事件驱动架构**: 系统核心组件通过中央事件总线(EventBus)进行通信，实现完全解耦，极大提高代码可维护性和可扩展性
- **统一调度器**: 基于heapq的单线程调度器，管理所有定时任务，取代传统多线程模型，显著降低资源开销并提高计时精度
- **智能药剂管理**: 采用HSV颜色空间匹配技术的被动式检测系统，支持HP/MP的精确检测和自动喂药功能，内置1080P优化配置
- **装备词缀洗练**: 独立的F7热键控制模块，采用三状态智能识别，通过PaddleOCR进行词缀识别，支持实时OSD反馈
- **自动寻路与探索**: 采用相位相关位移跟踪和A*算法，实现随机地图的自主探索和精确路径规划，支持双模式运行
- **模式互斥逻辑**: 严格区分"技能模式"、"洗练模式"和"寻路模式"，确保逻辑清晰、行为可预测
- **简化的技能触发系统**: 支持定时模式(Timer)和冷却模式(Cooldown)两种核心触发模式，移除未实现的内部冷却模式
- **音频反馈系统**: 通过预置音频文件为启动、停止、暂停和恢复等操作提供无延迟声音提示

## 自动寻路功能详解 (已实现)

本项目的高级功能，旨在实现对随机生成地图（如《暗黑破坏神 4》的地牢）的自主探索和路径规划。该功能采用**新架构设计**，通过 **F9** 热键准备寻路模式，**Z** 键执行寻路任务。目前已完成三个阶段的全面实现。

其核心技术方案分为三个阶段：

### 第一阶段：地图解读与拼接 (已实现)

此阶段的目标是将游戏小地图的像素图像，翻译并拼接成一张程序可以理解的、持久化的全局地图。

1.  **路径提取**: 程序利用 `OpenCV` 对小地图截图进行**颜色过滤**。通过`cv2.cvtColor`转为灰度图后，使用`cv2.threshold`将小地图中颜色较亮的、可通行的路径区域提取出来，生成一张只包含路径的二值化“蒙版”（Mask）。这一步直接过滤掉了地图背景、怪物标记等所有动态“噪音”。
2.  **图像优化**: 为了让路径数据更可靠，会使用`cv2.morphologyEx`和“闭运算”(`MORPH_CLOSE`)、“开运算”(`MORPH_OPEN`)来填补路径线条中的微小断裂，并移除孤立的噪点，得到一张干净、完整的路径图。
3.  **地图位移追踪**: 由于游戏小地图是“玩家在中心，地图移动”的模式，程序会对比**连续两帧**的“纯净路径图”，使用`cv2.phaseCorrelate`（相位相关）技术，精确计算出地图滚动的像素位移`(dx, dy)`。
4.  **全局地图拼接**: 程序在内存中维护一张巨大的“全局地图”（如 5000x5000 的`numpy`数组）。根据计算出的位移，它就能反推出玩家在全局地图上的绝对坐标，并将当前看到的新路况，通过`cv2.add`操作“拼接”到全局地图的正确位置上，像拼图一样，逐步扩大已探索的区域。

### 第二阶段：探索与路径规划 (已实现)

在拥有了绘制地图的能力后，程序需要一个策略来探索未知区域。

1.  **“Z 字形/除草机”探索算法**: 在没有最终目标的情况下，程序采用一种系统性的‘除草机’算法来遍历地图。它会控制角色沿一个方向（如“右”）持续移动，直到在**已拼接的全局地图**上探测到前方有障碍物。然后，角色会向下移动一小段固定距离，并掉转方向（变为“左”）继续移动，如此往复，确保以 Z 字形路径完整地覆盖所有可探索区域，避免走回头路。
2.  **A\*寻路 (已实现)**: 一旦目标（如出口的独特图标）出现在视野中，并被记录到全局地图上后，程序将立即停止探索，并在已拼接的全局地图上运行 **A\*** 算法，规划出从玩家当前位置到目标的**最优路径**。实现了完整的路径规划、路点跟随和模式切换逻辑。

### 第三阶段：寻路执行 (已实现)

此阶段的目标是控制角色，精准地沿着规划好的路径移动。

1.  **方向向量**: 因为玩家永远在小地图中心，所以路径上的任何一个路点（Waypoint）都天然地代表了一个从玩家出发的**方向向量**。
2.  **路点跟随**: 实现了完整的路点跟随算法，支持精确的距离判断和路点切换。程序会根据当前位置与目标路点的距离，计算精确的方向向量，并在游戏主屏幕的相应位置模拟鼠标点击，驱动角色沿着 A\*规划的最优路径精确移动。同时支持暂停/恢复功能和模式智能切换。
3.  **移动执行**: 使用 InputHandler 的 click_mouse_at 方法在屏幕坐标(960, 540)为中心，根据计算出的方向向量和距离(150 像素)确定点击位置，实现精确的角色移动控制。

## 智能药剂助手详解 (已实现)

专为 ARPG 游戏设计的智能药剂管理系统，实现了精确的血蓝条颜色检测和自动喝药功能。该功能采用先进的 HSV 颜色空间匹配技术，支持界面隐藏的可视化区域选择和颜色拾取工具。

### 核心技术方案

#### 1. HSV 颜色空间精确匹配

- **H(色相)**：0-359 度，区分颜色类型（红/蓝/绿等）
- **S(饱和度)**：0-255，控制颜色鲜艳程度
- **V(明度)**：0-255，控制颜色亮度
- **容差控制**：每个维度独立设置容差范围，实现精确匹配
- **OpenCV 转换**：Qt 色相值(0-359)自动转换为 OpenCV 色相值(0-179)

#### 2. 智能资源检测算法

```
# 计算区域内匹配颜色的像素百分比
matching_pixels = cv2.countNonZero(mask)
percentage = (matching_pixels / total_pixels) * 100.0

# HSV范围匹配
lower_hsv = np.array([h_min, s_min, v_min])
upper_hsv = np.array([h_max, s_max, v_max])
mask = cv2.inRange(hsv_region, lower_hsv, upper_hsv)
```

#### 3. 被动式检测架构

采用被动式检测模式，由 SkillManager 统一调度：

```
def check_and_execute_resources(self, cached_frame: Optional[np.ndarray] = None) -> bool:
    """被动调用的资源检测，避免独立线程开销"""
    if not self._is_running or self._is_paused:
        return False

    # 检查HP和MP，执行必要的按键操作
    executed = False
    if self.hp_config.get("enabled", False):
        if self._should_use_hp_resource(cached_frame):
            self._execute_resource("hp", self.hp_config)
            executed = True
    # ... MP检测逻辑
    return executed
```

#### 4. 内部冷却机制

```
def _check_internal_cooldown_ready(self, resource_type: str) -> bool:
    config = self.hp_config if resource_type == "hp" else self.mp_config
    current_time = time.time()
    last_press_time = self._flask_cooldowns.get(resource_type, 0)
    cooldown_seconds = config.get("cooldown", 5000) / 1000.0

    is_ready = current_time - last_press_time >= cooldown_seconds
    if not is_ready:
        remaining = cooldown_seconds - (current_time - last_press_time)
        LOG_INFO(f"[ResourceManager] {resource_type.upper()} 冷却中，剩余: {remaining:.1f}秒")
    return is_ready
```

### 功能特性

#### 1. 现代化配置界面

- **独立 TAB 页**：专门的"智能药剂"配置标签页
- **HP/MP 分离配置**：血药和蓝药完全独立的配置区域
- **1080P 默认值**：针对 1080P 屏幕优化的默认坐标和颜色值
- **全局设置**：可配置的检测间隔(50-1000ms)，默认 200ms

#### 2. 默认配置优化 (1080P)

```
# 血药默认配置
hp_defaults = {
    "region": (136, 910, 213, 1004),    # 1080P血条区域
    "hsv": (314, 75, 29),               # 血药颜色HSV
    "tolerance": (10, 20, 20),          # 颜色容差
    "threshold": 50,                    # 50%触发阈值
    "cooldown": 5000,                   # 5秒冷却
    "key": "1"                          # 默认按键
}

# 蓝药默认配置
mp_defaults = {
    "region": (1552, 910, 1560, 1004), # 1080P蓝条区域
    "hsv": (208, 80, 58),               # 蓝药颜色HSV
    "tolerance": (7, 5, 5),             # 更严格的容差
    "threshold": 50,                    # 50%触发阈值
    "cooldown": 8000,                   # 8秒冷却
    "key": "2"                          # 默认按键
}
```

#### 3. 区域选择工具

- **界面隐藏**：点击"📦 选择区域"按钮时主界面自动隐藏
- **全屏操作**：显示全屏区域选择对话框
- **拖拽选择**：鼠标拖拽选择检测区域
- **坐标验证**：自动验证坐标范围和边界
- **无缝恢复**：操作完成后主界面自动重新显示

#### 4. 颜色拾取工具

- **放大镜效果**：4 倍放大显示鼠标位置像素
- **实时 HSV 显示**：显示当前像素的 HSV 值
- **十字线定位**：屏幕十字线指示拾取位置
- **一键拾取**：点击即可拾取并自动设置容差范围
- **颜色预览**：实时显示拾取的颜色效果

#### 5. 战斗模式集成

- **F8 启动**：按 F8 进入战斗模式，ResourceManager 自动启动
- **统一调度**：由 SkillManager 每 200ms 调用一次检测
- **帧复用**：复用 SkillManager 的屏幕帧数据，避免重复捕获
- **状态同步**：与战斗系统完全同步，支持暂停/恢复

### 技术亮点

#### 1. 被动式架构设计

- **无独立线程**：ResourceManager 不创建独立线程，避免资源竞争
- **统一调度**：由 SkillManager 统一调度，确保时序一致性
- **帧数据复用**：复用已捕获的屏幕帧，提高性能
- **状态管理**：完整的启动/暂停/停止状态管理

#### 2. 配置分离与默认值

- **配置独立**：resource 配置完全独立于 skill 配置
- **默认值完善**：空配置时自动使用 1080P 优化的默认值
- **UI 同步**：配置加载时 UI 控件自动同步显示
- **向后兼容**：支持旧配置格式的自动迁移

#### 3. 性能优化设计

- **区域检测**：只检测指定的小区域，避免全屏处理
- **HSV 优化**：使用 HSV 颜色空间，对光照变化更鲁棒
- **智能缓存**：缓存计算结果，减少重复运算
- **边界检查**：完整的坐标边界检查和错误处理

#### 4. 用户体验优化

- **开箱即用**：默认配置适用于大多数 1080P 用户
- **可视化配置**：直观的区域选择和颜色拾取工具
- **实时反馈**：详细的日志输出和状态显示
- **错误处理**：完善的错误处理和用户提示

### 使用流程

#### 配置阶段

1. **启动程序**：运行 main.py 进入 GUI 界面
2. **选择 TAB**：点击"智能药剂"TAB 进入配置
3. **使用默认值**：1080P 用户可直接使用默认配置
4. **自定义配置**：根据需要调整区域、颜色、阈值等参数
5. **全局设置**：调整检测间隔（默认 200ms）

#### 战斗阶段

1. **进入游戏**：启动目标游戏
2. **启动辅助**：按 F8 进入战斗模式
3. **自动检测**：系统每 200ms 检测一次资源状态
4. **智能喝药**：低于阈值且冷却完成时自动按键
5. **退出辅助**：再次按 F8 退出战斗模式

### 配置示例

```
{
  "resource_management": {
    "hp_config": {
      "enabled": true,
      "key": "1",
      "threshold": 50,
      "cooldown": 5000,
      "region_x1": 136,
      "region_y1": 910,
      "region_x2": 213,
      "region_y2": 1004,
      "target_h": 314,
      "target_s": 75,
      "target_v": 29,
      "tolerance_h": 10,
      "tolerance_s": 20,
      "tolerance_v": 20
    },
    "mp_config": {
      "enabled": true,
      "key": "2",
      "threshold": 50,
      "cooldown": 8000,
      "region_x1": 1552,
      "region_y1": 910,
      "region_x2": 1560,
      "region_y2": 1004,
      "target_h": 208,
      "target_s": 80,
      "target_v": 58,
      "tolerance_h": 7,
      "tolerance_s": 5,
      "tolerance_v": 5
    },
    "check_interval": 200
  }
}
```

## 技能配置系统优化 (已完成)

为了提高系统的准确性和可维护性，我们对技能配置系统进行了全面的清理和优化：

### 触发模式简化

- **移除未实现功能**: 彻底移除了`TriggerMode = 2`（内部冷却模式）和相关的`InternalCooldown`字段
- **双模式设计**: 现在只支持两种实际工作的触发模式：
  - `TriggerMode = 0`: **定时模式** - 基于固定时间间隔执行技能
  - `TriggerMode = 1`: **冷却模式** - 基于技能图标冷却状态执行技能

### 配置分离优化

- **Resource 配置独立**: 智能药剂功能的配置完全独立于技能配置
- **UI 界面分离**: 技能配置界面移除了 resource 相关字段，添加友好提示指向"智能药剂"标签页
- **配置结构清晰**: 避免了配置混乱和字段冲突

### 代码清理成果

```
# 简化后的技能配置结构
{
  "Enabled": true,
  "Priority": false,
  "Timer": 1000,
  "TriggerMode": 0,  // 0=定时, 1=冷却 (2已移除)
  "CooldownCoordX": 0,
  "CooldownCoordY": 0,
  "CooldownSize": 12,
  "ExecuteCondition": 0,
  "AltKey": ""
  // "InternalCooldown": 已移除
}
```

### 用户体验改进

- **配置更准确**: 不会产生无效的配置项
- **界面更清晰**: 只显示实际可用的选项
- **维护更容易**: 减少了混淆和错误配置的可能性

## 架构设计

本工具采用分层和模块化的设计，其核心组件和职责如下：

- **`MacroEngine` (宏引擎)**: 作为项目的**状态与事件协调中心**。它负责管理程序的核心状态，并作为**资源调度中心**，根据当前模式（战斗、洗练、寻路）动态指挥底层捕获模块切换最高效的工作模式。
- **`SkillManager` (技能管理器)**: **技能决策引擎**。它订阅配置更新事件，将用户配置翻译成具体的、可执行的任务，并利用其内部的 `UnifiedScheduler` 实例进行调度。
- **`SimpleAffixRerollManager` (智能洗练管理器)**: **装备洗练引擎**。一个完全独立的模块，在自己的线程中运行，负责执行所有与装备洗练相关的自动化流程。
- **`PathfindingManager` (寻路管理器)**: **自动寻路引擎**。采用统一状态管理架构，由`MacroEngine`统一调度启停、暂停和恢复。在独立的线程中运行，持续地从`BorderFrameManager`获取屏幕数据，通过图像处理来解读小地图，利用相位相关技术追踪地图位移，并将探索到的地图拼接成一张完整的全局地图。支持双模式运行（探索模式和寻路模式）、实时目标识别和 A\*路径规划。
- **`InputHandler` (输入处理器)**: **输入执行与队列管理中心**。它封装了键盘和鼠标的模拟输入操作，并独立管理一个按键队列。
- **`UnifiedScheduler` (统一调度器)**: 项目定时任务的心脏。一个基于`heapq`的单线程循环，能够高效、精确地管理成百上千个不同间隔的定时任务。
- **`ResourceManager` (资源管理器)**: 智能药剂助手的核心。被动式资源检测模块，由 SkillManager 统一调度，支持 HP/MP 的精确颜色检测和自动喝药功能。采用 HSV 颜色空间匹配技术，实现像素级精确识别，支持内部冷却机制防止药水浪费。内置 1080P 优化的默认配置。
- **`BorderFrameManager` (边框图管理器)**: 一个**灵活的帧服务**，能够根据 `MacroEngine` 的指令，在“全屏捕获”和“指定区域捕获”之间动态切换，并为上层模块提供按需分割的帧数据切片。
- **`NativeGraphicsCaptureManager` (原生图形捕获管理器)**: 封装 C++捕获库，提供高性能的屏幕捕获服务。支持全屏或指定区域捕获，采用零拷贝技术和智能帧率控制。
- **`EventBus` (事件总线)**: 基于发布/订阅模式，实现各模块间的异步通信，支持 ThreadPoolExecutor 优化的事件处理，是整个架构的神经中枢。包含递归事件检测和性能监控功能。
- **`ConfigManager` (配置管理器)**: 负责配置文件的加载、保存和管理。支持 JSON 格式配置文件的读写操作。
- **`PaddleOcrManager` (OCR 管理器)**: 一个工具类，负责管理 PaddleOCR 引擎的生命周期，采用按需加载和性能优化配置。支持异步初始化和错误处理。
- **`HotkeyManager` (热键管理器)**: 基于 Windows API 的低级键盘钩子管理器，支持热键的动态注册、注销和条件抑制。
- **`SoundManager` (声音管理器)**: 管理音频反馈的播放，使用 winsound 库实现非阻塞音频播放。
- **`WindowUtils` (窗口工具)**: 提供窗口检测、激活和管理功能，支持进程名和窗口类名的查找。
- **`DebugLog` (调试日志)**: 基于环境变量的条件日志系统，支持不同级别的日志输出。

## 使用方法

1.  **启动程序**:

    - **完整版本**: 运行 `main.py`，启动包含完整 GUI 界面的版本。
    - **简化版本**: 运行 `main_special.py`，启动命令行版本（专注于特定自动化任务，需要管理员权限）。

2.  **配置**: 在"技能配置"、"目标窗口"、"时间间隔/声音"、"原地模式"、"洗练"、"寻路"、"智能药剂"等标签页中完成您的配置。支持加载/保存 JSON 格式的配置文件。

3.  **热键操作**:

    - **F8 (主控键)**: 准备/停止**技能模式**（包含智能药剂功能）。
    - **F7 (洗练键)**: 启动/停止**装备洗练模式**（需要先加载 OCR 引擎）。
    - **F9 (寻路键)**: 准备/停止**自动寻路模式**。
    - **Z (执行/暂停键)**: 在"准备"状态下，按下 Z 键，开始执行对应的任务（技能或寻路）。在"运行"状态下，按下 Z 键，暂停任务。在"暂停"状态下，再次按下 Z 键，恢复任务。
    - **原地模式热键**: 可配置的热键，用于切换原地释放技能模式。
    - **交互/强制移动键**: 可配置的热键，用于临时屏蔽技能执行。

4.  **特殊功能**:
    - **序列模式**: 支持按预设顺序循环执行多个技能。
    - **原地模式**: 支持两种实现方式 - Shift 修饰符或阻止鼠标键。
    - **窗口激活**: 自动检测并激活目标游戏窗口。

## 技术亮点

### 1. 智能资源管理

- **情景感知的捕获策略**: 程序能够根据当前任务（战斗、寻路、洗练）的实际需求，动态切换屏幕捕获模式。在需要大范围视野时（寻路/战斗）自动切换为全屏捕获，在需要极致 OCR 速度时（洗练）切换为小范围 UI 区域捕获，在空闲时则完全停止捕获，最大限度地平衡了性能开销与功能需求。

### 2. 现代化的 UI 与核心架构

- **事件驱动设计**: 所有核心组件通过中央事件总线进行松耦合通信，逻辑清晰，易于扩展。支持异步事件处理和递归事件检测。
- **统一状态机架构**: 采用革新的两步式操作模式，所有功能模式（技能、洗练、寻路）都遵循 STOPPED→READY→RUNNING→PAUSED 的统一状态流转，确保用户体验一致性和操作安全性。
- **清晰的模块化 UI**: UI 层经过重构，将主窗口、各类配置组件和自定义控件完全分离，极大地提升了代码的可读性和可维护性。使用 PySide6 构建现代化界面。
- **线程安全的 UI 更新**: 借助 `QTimer`，所有来自后台线程的 UI 更新请求都会被安全地调度到主线程执行，杜绝了多线程 UI 操作导致的崩溃风险。
- **智能输入处理**: InputHandler 采用队列机制和线程池，确保输入操作的高效执行和状态同步。

### 3. 高性能与高效率

- **零拷贝屏幕捕获**: 基于 C++和 Windows Graphics Capture API，从根本上消除了内存拷贝开销。Python 层通过 ctypes 直接访问 C++内存缓冲区。
- **高效的任务调度**: 使用基于 `heapq` 的单线程统一调度器，以极低的资源开销精确管理所有定时任务。支持任务的动态添加、移除和间隔更新。
- **"一次捕获，多次使用"**: 图像帧在内存中被复用，避免了重复截图带来的 CPU 性能损耗。BorderFrameManager 负责帧数据的统一管理和分发。
- **智能缓存机制**: 模板缓存和进程缓存减少重复计算，带内存限制和自动清理功能。

### 4. 稳健性与兼容性

- **稳健的错误处理**: 在所有关键路径上都添加了详细的错误日志，告别"静默失败"，便于快速定位问题。支持 DEBUG 环境变量控制日志输出级别。
- **依赖版本管理**: 在 `requirements.txt` 中明确指定依赖版本，保证了开发和部署环境的一致性与可复现性。包含 PySide6、OpenCV、PaddleOCR 等核心依赖。
- **按需加载**: OCR 等重资源模块按需加载，优化了程序的启动速度和资源占用。支持异步初始化和错误恢复。
- **配置清理与简化**: 移除了未实现的功能（如 InternalCooldown），简化了技能触发模式为定时(Timer)和冷却(Cooldown)两种，提高了配置的准确性和可维护性。
- **跨平台兼容性**: 主要针对 Windows 平台设计，使用 Windows API 实现底层功能，同时保持 Python 层的平台无关性。

### 5. 智能寻路与探索技术

- **先进的地图拼接技术**: 采用`cv2.phaseCorrelate`相位相关算法，实现了亚像素级精度的地图位移追踪，确保全局地图的高精度拼接。支持动态地图更新和内存优化。
- **高效的 A\*路径规划**: 实现了支持 8 方向移动的 A\*算法，支持动态地图更新和实时路径重规划，确保找到最优路径。使用 Node 类和 heapq 实现高效的优先级队列。
- **智能双模式切换**: 在探索模式下采用 Z 字形遍历算法（"除草机"模式），一旦发现目标即刻切换到寻路模式，实现高效的自主探索和精确寻路。
- **实时目标识别**: 通过 HSV 颜色空间过滤和轮廓检测，实现了对游戏中特定目标（如任务点、传送门）的实时识别和定位。支持亮蓝色目标的自动检测。
- **全局地图管理**: 使用 5000x5000 像素的 numpy 数组维护全局地图，支持玩家位置追踪和地图区域的动态拼接。

### 6. 智能药剂技术

- **HSV 精确颜色匹配**: 采用 HSV 颜色空间实现像素级精确匹配，支持任意颜色的智能识别。每个维度独立设置容差范围，Qt 色相值自动转换为 OpenCV 格式，确保精确检测。
- **被动式检测架构**: 由 SkillManager 统一调度，避免独立线程开销。复用屏幕帧数据，提高整体性能。支持完整的状态管理（启动/暂停/停止）。
- **区域资源百分比计算**: 通过计算检测区域内匹配颜色像素的百分比，实现精确的资源量估算。支持动态阈值设置和边界检查，避免误触发。
- **内部冷却机制**: 实现药水使用间隔控制，防止连续按键浪费药水。支持 HP 和 MP 独立冷却时间设置，带详细的冷却状态日志。
- **1080P 优化配置**: 内置针对 1080P 屏幕优化的默认坐标和颜色值。空配置时自动使用默认值，确保开箱即用的体验。
- **配置分离设计**: resource 配置完全独立于 skill 配置，避免配置混乱。支持配置的部分更新和向后兼容。
- **界面隐藏操作**: 区域选择和颜色拾取时自动隐藏主界面，提供全屏操作体验。操作完成后无缝恢复界面状态。

## 依赖环境与配置

### 系统要求

- **操作系统**: Windows 10/11 (主要支持平台)
- **Python 版本**: 3.7+
- **权限要求**: 部分功能需要管理员权限（如热键监听）

### 核心依赖

```
PySide6>=6.5.0        # GUI框架
psutil>=5.9.0         # 系统进程管理
pynput>=1.7.6         # 键盘鼠标输入控制
Pillow>=9.0.0         # 图像处理
numpy>=1.20.0         # 数值计算
opencv-python>=4.5.0  # 计算机视觉
pywin32>=306          # Windows API接口
paddleocr==2.7.3      # OCR文字识别
```

### 环境配置

- **DEBUG 模式**: 设置环境变量`DEBUG=1`启用详细日志输出
- **代理设置**: 支持 HTTP/HTTPS 代理配置（用于 PaddleOCR 下载）
- **配置文件**: 支持 JSON 格式的配置文件，支持多套配置切换

### 项目结构

```
pyahk/
├── main.py                     # GUI版本主入口
├── main_special.py             # 命令行版本入口
├── requirements.txt            # Python依赖列表
├── *.json                     # 配置文件(default.json, d4.json等)
├── native_capture/            # C++原生捕获库
│   ├── capture_lib.cpp       # C++捕获实现
│   ├── capture_lib.h         # C++头文件
│   ├── python_wrapper.py     # Python ctypes包装器
│   ├── CMakeLists.txt        # CMake构建配置
│   └── build.bat             # Windows构建脚本
└── torchlight_assistant/      # Python主应用包
    ├── core/                  # 核心业务逻辑
    │   ├── macro_engine.py    # 宏引擎：状态管理与事件协调
    │   ├── skill_manager.py   # 技能管理器：统一调度器集成
    │   ├── resource_manager.py # 资源管理器：被动式药剂检测
    │   ├── input_handler.py   # 输入处理器：键鼠队列管理
    │   ├── pathfinding_manager.py # 寻路管理器：A*算法实现
    │   ├── simple_affix_reroll_manager.py # 洗练管理器
    │   ├── event_bus.py       # 事件总线：发布订阅模式
    │   ├── unified_scheduler.py # 统一调度器：heapq实现
    │   ├── config_manager.py  # 配置管理器：JSON处理
    │   └── states.py          # 状态定义：MacroState枚举
    ├── gui/                   # 用户界面层
    │   ├── main_window.py     # 主窗口：集成所有界面组件
    │   ├── status_window.py   # OSD状态窗口
    │   ├── ui_components.py   # UI组件：标签页和控件
    │   ├── resource_widgets.py # 智能药剂配置界面
    │   ├── skill_config_widget.py # 技能配置界面
    │   ├── custom_widgets.py  # 自定义控件
    │   └── styles.py          # 界面样式定义
    └── utils/                 # 工具类层
        ├── native_graphics_capture_manager.py # 原生捕获管理
        ├── border_frame_manager.py # 边框图管理：帧数据分发
        ├── hotkey_manager.py   # 热键管理：Windows API钩子
        ├── paddle_ocr_manager.py # OCR管理：PaddleOCR封装
        ├── sound_manager.py    # 声音管理：音频反馈
        ├── window_utils.py     # 窗口工具：进程查找
        ├── debug_log.py        # 调试日志：条件输出
        └── a_star.py           # A*算法：路径规划实现