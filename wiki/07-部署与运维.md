# 07 部署与运维

## 概述

本章提供pyahk的完整部署指南，包括环境准备、依赖安装、配置部署、运维监控和故障处理等内容，帮助用户在各种环境下成功部署和运行pyahk。

---

## 🚀 环境准备

### 系统要求

#### 操作系统支持
- **Windows 10** (版本 1903 或更新)
- **Windows 11** (推荐)
- **不支持**: Linux, macOS (依赖Windows特定API)

#### 硬件要求
```
最低配置:
- CPU: Intel i5-4代 或 AMD 等效处理器
- 内存: 4GB RAM
- 显卡: 支持DXGI的独立显卡或集成显卡
- 存储: 500MB 可用空间

推荐配置:
- CPU: Intel i7-8代 或 AMD Ryzen 5 3600+
- 内存: 8GB+ RAM
- 显卡: GTX 1060 / RX 580 或更高
- 存储: 1GB 可用空间 (SSD推荐)
```

#### 权限要求
- **管理员权限**: 热键监听、窗口操作需要
- **防火墙设置**: 允许Python.exe网络访问(OCR功能)
- **杀毒软件**: 添加pyahk目录到白名单

### Python环境配置

#### 版本要求
```bash
# 检查Python版本
python --version
# 要求: Python 3.7+ (推荐 3.9 或 3.10)
```

#### 虚拟环境设置 (推荐)
```bash
# 创建虚拟环境
python -m venv pyahk_env

# 激活虚拟环境
# Windows
pyahk_env\Scripts\activate
# PowerShell
pyahk_env\Scripts\Activate.ps1

# 升级pip
python -m pip install --upgrade pip
```

---

## 📦 依赖安装

### 自动安装 (推荐)
```bash
# 克隆项目
git clone <repository-url>
cd pyahk

# 安装所有依赖
pip install -r requirements.txt
```

### requirements.txt 详解
```ini
# GUI框架
PySide6>=6.5.0          # 主界面框架

# 系统操作
psutil>=5.9.0           # 进程监控
pynput>=1.7.6           # 键盘鼠标控制
pywin32>=306            # Windows API

# 图像处理
Pillow>=9.0.0           # 基础图像操作
mss>=9.0.1             # 屏幕截图 (备用)
numpy>=1.20.0          # 数值计算
opencv-python>=4.5.0   # 计算机视觉

# OCR文字识别
paddleocr==2.7.3        # 固定版本，避免兼容性问题

# 可选依赖
watchdog>=2.1.0         # 文件监控 (配置热重载)
```

### 手动依赖处理

#### 常见安装问题
```bash
# 1. PySide6安装失败
pip install PySide6 --no-cache-dir

# 2. PaddleOCR安装问题
pip install paddleocr==2.7.3 -i https://pypi.tuna.tsinghua.edu.cn/simple

# 3. OpenCV安装问题  
pip install opencv-python --no-cache-dir

# 4. pywin32注册
python Scripts/pywin32_postinstall.py -install
```

#### 离线安装
```bash
# 下载依赖包
pip download -r requirements.txt -d offline_packages/

# 离线安装
pip install --no-index --find-links offline_packages/ -r requirements.txt
```

### C++组件编译

#### 编译工具准备
```bash
# 需要安装:
# 1. Visual Studio 2019+ 或 Build Tools for Visual Studio
# 2. CMake 3.15+
# 3. Git

# 检查编译环境
cmake --version
git --version
```

#### 编译native_capture
```bash
cd native_capture

# 方法1: 使用批处理脚本
build.bat

# 方法2: 手动编译
mkdir build
cd build
cmake ..
cmake --build . --config Release
```

#### 编译产物验证
```bash
# 检查生成的DLL
ls native_capture/capture_lib.dll

# Python中测试导入
python -c "from native_capture.python_wrapper import CaptureManager; print('OK')"
```

---

## ⚙️ 配置部署

### 目录结构
```
pyahk/
├── main.py                 # 主程序入口
├── main_special.py         # 特殊模式入口
├── requirements.txt        # 依赖列表
├── default.json           # 默认配置
├── torchlight_assistant/  # 核心代码
├── native_capture/        # C++捕获库
├── sounds/               # 音效文件
├── wiki/                 # 文档
└── logs/                 # 日志目录 (运行时创建)
```

### 配置文件部署

#### 1. 创建基础配置
```bash
# 复制默认配置
cp default.json my_config.json

# 编辑配置
notepad my_config.json
```

#### 2. 环境特定配置
```json
{
  "deployment": {
    "environment": "production",
    "log_level": "INFO",
    "debug_mode": false,
    "auto_backup": true
  },
  "performance": {
    "capture_interval": 100,
    "scheduler_precision": 50,
    "max_queue_size": 1000
  }
}
```

### 权限配置

#### UAC设置
```bash
# 创建管理员权限快捷方式
# 右键 -> 属性 -> 高级 -> 以管理员身份运行
```

#### 防火墙配置
```powershell
# PowerShell管理员模式
New-NetFirewallRule -DisplayName "PyAHK" -Direction Inbound -Program "C:\Python39\python.exe" -Action Allow
New-NetFirewallRule -DisplayName "PyAHK" -Direction Outbound -Program "C:\Python39\python.exe" -Action Allow
```

---

## 🔧 服务化部署

### Windows服务模式

#### 1. 创建服务脚本
```python
# pyahk_service.py
import win32serviceutil
import win32service
import win32event
import os
import sys

class PyAHKService(win32serviceutil.ServiceFramework):
    _svc_name_ = "PyAHKService"
    _svc_display_name_ = "PyAHK Game Automation Service"
    _svc_description_ = "PyAHK自动化服务"

    def __init__(self, args):
        win32serviceutil.ServiceFramework.__init__(self, args)
        self.hWaitStop = win32event.CreateEvent(None, 0, 0, None)

    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        win32event.SetEvent(self.hWaitStop)

    def SvcDoRun(self):
        import main
        main.run_service_mode()

if __name__ == '__main__':
    win32serviceutil.HandleCommandLine(PyAHKService)
```

#### 2. 安装服务
```bash
python pyahk_service.py install
python pyahk_service.py start
```

### 计划任务部署

#### 创建计划任务
```powershell
# PowerShell创建计划任务
$action = New-ScheduledTaskAction -Execute "python" -Argument "C:\pyahk\main.py"
$trigger = New-ScheduledTaskTrigger -AtStartup
$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

Register-ScheduledTask -TaskName "PyAHK" -Action $action -Trigger $trigger -Settings $settings -Principal $principal
```

---

## 📊 监控与运维

### 日志管理

#### 日志配置
```python
# logging_config.py
import logging
import logging.handlers

def setup_logging():
    logger = logging.getLogger('pyahk')
    logger.setLevel(logging.INFO)
    
    # 文件日志 (轮转)
    file_handler = logging.handlers.RotatingFileHandler(
        'logs/pyahk.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    
    # 控制台日志
    console_handler = logging.StreamHandler()
    
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
```

#### 日志分析
```bash
# 日志分析脚本
# analyze_logs.py
import re
from collections import Counter

def analyze_performance(log_file):
    """分析性能日志"""
    with open(log_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # 提取执行时间
    timing_pattern = r'执行耗时: (\d+\.?\d*)ms'
    timings = [float(m.group(1)) for line in lines for m in [re.search(timing_pattern, line)] if m]
    
    print(f"平均执行时间: {sum(timings)/len(timings):.2f}ms")
    print(f"最大执行时间: {max(timings):.2f}ms")
    
def analyze_errors(log_file):
    """分析错误日志"""
    with open(log_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    error_lines = [line for line in lines if 'ERROR' in line]
    error_patterns = Counter([line.split('ERROR')[1].split(':')[0].strip() for line in error_lines])
    
    print("错误统计:")
    for error, count in error_patterns.most_common():
        print(f"  {error}: {count}次")
```

### 性能监控

#### 资源监控脚本
```python
# monitor.py
import psutil
import time
from datetime import datetime

class PyAHKMonitor:
    def __init__(self, process_name="python.exe"):
        self.process_name = process_name
        self.process = None
        
    def find_process(self):
        """查找PyAHK进程"""
        for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
            try:
                if 'main.py' in ' '.join(proc.info['cmdline']):
                    self.process = proc
                    return True
            except:
                continue
        return False
    
    def get_stats(self):
        """获取进程统计信息"""
        if not self.process:
            return None
            
        try:
            return {
                'cpu_percent': self.process.cpu_percent(),
                'memory_mb': self.process.memory_info().rss / 1024 / 1024,
                'threads': self.process.num_threads(),
                'status': self.process.status()
            }
        except:
            return None
    
    def monitor_loop(self, interval=30):
        """监控循环"""
        while True:
            if not self.find_process():
                print(f"{datetime.now()}: PyAHK进程未找到")
                time.sleep(interval)
                continue
                
            stats = self.get_stats()
            if stats:
                print(f"{datetime.now()}: CPU: {stats['cpu_percent']:.1f}%, "
                      f"内存: {stats['memory_mb']:.1f}MB, "
                      f"线程: {stats['threads']}, "
                      f"状态: {stats['status']}")
            
            time.sleep(interval)

if __name__ == "__main__":
    monitor = PyAHKMonitor()
    monitor.monitor_loop()
```

### 健康检查

#### 自动健康检查
```python
# health_check.py
import requests
import json
import time
from datetime import datetime

class HealthChecker:
    def __init__(self):
        self.checks = [
            self.check_process_running,
            self.check_memory_usage,
            self.check_log_errors,
            self.check_config_files
        ]
    
    def check_process_running(self):
        """检查进程是否运行"""
        # 实现进程检查逻辑
        pass
    
    def check_memory_usage(self):
        """检查内存使用"""
        # 实现内存检查逻辑
        pass
    
    def run_all_checks(self):
        """运行所有健康检查"""
        results = {}
        for check in self.checks:
            try:
                results[check.__name__] = check()
            except Exception as e:
                results[check.__name__] = f"检查失败: {e}"
        
        return results
```

---

## 🛠️ 故障处理

### 常见部署问题

#### 1. 权限问题
```bash
# 症状: 热键无效，无法截图
# 解决: 以管理员权限运行
Right-click -> Run as administrator

# 或创建管理员权限快捷方式
```

#### 2. DLL加载失败
```bash
# 症状: ImportError: DLL load failed
# 解决: 安装Visual C++ Redistributable
# 下载并安装: vc_redist.x64.exe
```

#### 3. OCR初始化失败
```bash
# 症状: PaddleOCR初始化错误
# 解决: 清理PaddleOCR缓存
rm -rf ~/.paddleocr/
pip uninstall paddleocr
pip install paddleocr==2.7.3
```

### 自动恢复机制

#### 进程守护脚本
```python
# watchdog.py
import subprocess
import time
import os
import signal

class ProcessWatchdog:
    def __init__(self, command, restart_delay=10):
        self.command = command
        self.restart_delay = restart_delay
        self.process = None
        
    def start_process(self):
        """启动被监控进程"""
        try:
            self.process = subprocess.Popen(self.command, shell=True)
            print(f"进程启动: PID {self.process.pid}")
            return True
        except Exception as e:
            print(f"启动失败: {e}")
            return False
    
    def is_process_running(self):
        """检查进程是否运行"""
        if self.process is None:
            return False
        
        poll = self.process.poll()
        return poll is None
    
    def restart_process(self):
        """重启进程"""
        print("正在重启进程...")
        if self.process:
            try:
                self.process.terminate()
                self.process.wait(timeout=5)
            except:
                self.process.kill()
        
        time.sleep(self.restart_delay)
        return self.start_process()
    
    def watch(self):
        """监控循环"""
        if not self.start_process():
            return
        
        try:
            while True:
                if not self.is_process_running():
                    print("进程已停止，准备重启")
                    if not self.restart_process():
                        print("重启失败，退出监控")
                        break
                
                time.sleep(5)  # 5秒检查一次
        
        except KeyboardInterrupt:
            print("停止监控")
            if self.process:
                self.process.terminate()

# 使用示例
if __name__ == "__main__":
    watchdog = ProcessWatchdog("python main.py")
    watchdog.watch()
```

### 配置备份与恢复

#### 自动备份脚本
```python
# backup_config.py
import json
import shutil
import os
from datetime import datetime

def backup_configs():
    """备份所有配置文件"""
    backup_dir = f"backups/{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    os.makedirs(backup_dir, exist_ok=True)
    
    config_files = [
        "default.json",
        "d4.json", 
        "poe2_锐眼.json"
    ]
    
    for config_file in config_files:
        if os.path.exists(config_file):
            shutil.copy2(config_file, backup_dir)
            print(f"备份: {config_file} -> {backup_dir}")

def restore_config(backup_date, config_name):
    """恢复指定配置"""
    backup_path = f"backups/{backup_date}/{config_name}"
    if os.path.exists(backup_path):
        shutil.copy2(backup_path, config_name)
        print(f"恢复: {backup_path} -> {config_name}")
    else:
        print(f"备份文件不存在: {backup_path}")
```

通过这套完整的部署与运维体系，可以确保pyahk在各种环境下稳定可靠地运行，并提供及时的问题诊断和自动恢复能力。