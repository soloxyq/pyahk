# 03 功能模块详解

本章详细介绍pyahk的四大核心功能模块：技能系统、智能药剂、装备洗练和自动寻路。每个模块都采用模块化设计，既可独立运行，也可协同工作。

---

## 🎯 技能自动化系统

### 概述
技能系统是pyahk的核心功能，提供自动化的技能释放、冷却检测和优先级管理。支持多种触发模式和执行条件，实现精确的战斗自动化。

### 三种触发模式

#### 1. 定时模式 (TriggerMode = 0)
```json
{
  "name": "持续技能",
  "key": "1",
  "trigger_mode": 0,
  "interval": 1000,  // 每1秒执行一次
  "priority": false
}
```
- **功能**：基于固定时间间隔执行技能
- **使用场景**：持续BUFF技能、定期回血技能
- **特点**：严格按时间间隔执行，不受游戏状态影响

#### 2. 冷却模式 (TriggerMode = 1)
```json
{
  "name": "主要输出",
  "key": "q",
  "trigger_mode": 1,
  "cooldown_coords": [100, 50, 20, 20],  // [x, y, width, height]
  "priority": true
}
```
- **功能**：基于技能图标冷却状态执行技能
- **检测原理**：通过RGB图像匹配检测技能是否可用
- **使用场景**：主要输出技能、有冷却时间的关键技能

#### 3. 按住模式 (TriggerMode = 2)
```json
{
  "name": "移动技能",
  "key": "shift",
  "trigger_mode": 2
}
```
- **功能**：进入运行状态时按下，停止时释放
- **特点**：
  - 仅在状态切换时一次性执行
  - 不参与循环或定时任务
  - 由AHK服务执行，支持组合键
- **使用场景**：持续技能、移动速度增强

### 优先级系统

#### 双重优先级机制
- **检查优先级**：高优先级技能在冷却检测时优先检查
- **队列优先级**：高优先级技能按键插入PriorityDeque前端

#### 最佳实践
```json
{
  "skills": [
    {"name": "紧急恢复", "priority": true},   // 最高优先级
    {"name": "核心输出", "priority": true},   // 高优先级
    {"name": "辅助技能", "priority": false}   // 普通优先级
  ]
}
```

### 执行条件系统

#### 无条件模式 (ExecuteCondition = 0)
- 冷却就绪时直接执行主按键
- 最简单的执行模式

#### Buff限制模式 (ExecuteCondition = 1)
```json
{
  "execute_condition": 1,
  "buff_coords": [200, 100, 30, 30],
  "key": "e"
}
```
- **逻辑**：Buff存在时不执行，Buff消失时执行
- **场景**：避免重复上BUFF

#### 资源条件模式 (ExecuteCondition = 2)
```json
{
  "execute_condition": 2,
  "resource_coords": [50, 950, 200, 20],
  "resource_threshold": 70,
  "key": "r",
  "alt_key": "t"  // 资源不足时的备用按键
}
```
- **逻辑**：资源充足执行主按键，不足执行备用按键
- **连续性检查**：避免检测抖动
- **场景**：根据MP/怒气状态切换技能

---

## 💊 智能药剂系统

### 概述
采用先进的HSV双色检测算法，支持正常/中毒状态智能识别，实现精确的HP/MP检测和自动喂药功能。

### 三层委托架构

#### 第1层：SkillManager (调度层)
```python
# 通过UnifiedScheduler按固定间隔启动资源检查任务
def schedule_resource_check():
    scheduler.add_task("resource_check", 200, self.check_resources)
```

#### 第2层：ResourceManager (业务逻辑层)
```python
class ResourceManager:
    def check_hp_potion(self, frame):
        if not self._is_hp_cooldown_ready():
            return False
        
        current_percentage = self._detect_hp_percentage(frame)
        if current_percentage < self.hp_threshold:
            self._execute_hp_potion()
            return True
        return False
```

#### 第3层：BorderFrameManager (检测层)
```python
def _compare_resource_hsv(self, frame, template_hsv, tolerance):
    """HSV模板匹配，处理色相环形特性"""
    # 智能HSV颜色空间检测
    h_diff = min(abs(h1 - h2), 360 - abs(h1 - h2))
    # 计算匹配百分比
```

### HSV双色检测技术

#### 核心优势
- **光照适应性**：HSV颜色空间对光照变化不敏感
- **状态感知**：自动识别正常/中毒/异常状态的颜色变化
- **环形处理**：正确处理色相的360度环形特性

#### 配置示例
```json
{
  "hp_potion": {
    "enabled": true,
    "key": "1",
    "threshold": 50,
    "region": [136, 910, 213, 1004],
    "hsv_normal": [314, 75, 29],
    "hsv_poison": [120, 180, 50],
    "tolerance": [10, 20, 20],
    "cooldown": 5000
  }
}
```

### 内部冷却机制
```python
class ResourceManager:
    def __init__(self):
        self._last_hp_use = 0
        self._last_mp_use = 0
        self._hp_cooldown = 5000  # 5秒冷却
        self._mp_cooldown = 8000  # 8秒冷却
    
    def _is_hp_cooldown_ready(self):
        return time.time() - self._last_hp_use > self._hp_cooldown / 1000
```

---

## 🔨 装备洗练系统

### 概述
独立的F7热键控制模块，采用三状态识别机制，结合PaddleOCR文字识别技术，实现精确的词缀检测和自动洗练操作。

### 三状态识别机制

#### 状态1：未洗练状态
- **特征**：装备未进行任何洗练操作
- **识别**：通过特定UI元素的颜色和位置识别
- **操作**：点击开始洗练按钮

#### 状态2：洗练进行中
- **特征**：正在进行洗练，界面显示进度或动画
- **识别**：检测洗练进度指示器
- **操作**：等待洗练完成

#### 状态3：洗练完成
- **特征**：洗练完成，显示新词缀结果
- **识别**：检测完成状态的UI特征
- **操作**：进行OCR识别，决策是否保留

### PaddleOCR集成

#### 引擎配置
```python
from paddleocr import PaddleOCR

ocr = PaddleOCR(
    use_angle_cls=True,      # 启用角度分类
    lang='ch',               # 中文识别
    use_gpu=False,           # CPU模式，兼容性更好
    show_log=False,          # 禁用详细日志
    det_db_score_mode='slow' # 精确检测模式
)
```

#### 识别流程
```python
def recognize_affixes(self, image_region):
    # 1. 图像预处理
    processed_image = self._preprocess_image(image_region)
    
    # 2. OCR识别
    results = self.ocr.ocr(processed_image, cls=True)
    
    # 3. 文字提取和匹配
    detected_affixes = self._extract_text_from_results(results)
    
    # 4. 目标词缀匹配
    return self._match_target_affixes(detected_affixes)
```

### 配置示例
```json
{
  "affix_reroll": {
    "enabled": true,
    "max_attempts": 100,
    "target_affixes": ["暴击率", "暴击伤害", "攻击力"],
    "enchant_button": [500, 600],
    "replace_button": [600, 700],
    "close_button": [700, 100],
    "ocr_region": [400, 300, 200, 400]
  }
}
```

---

## 🗺️ 自动寻路系统

### 概述
专为随机生成地图设计，采用**相位相关位移跟踪**和**A*算法**，实现智能地图探索和精确路径规划。

### 核心技术架构

#### 第一阶段：地图解读与拼接

**1. 路径提取**
```python
def extract_paths(minimap_frame):
    """从小地图提取可通行路径"""
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    _, mask = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY)
    
    # 形态学操作优化路径连通性
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
    closed = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
    opened = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel)
    
    return opened
```

**2. 相位相关位移跟踪**
```python
def track_displacement(prev_frame, curr_frame):
    """计算地图移动的像素位移"""
    displacement, response = cv2.phaseCorrelate(prev_frame, curr_frame)
    confidence = response  # 置信度
    return displacement if confidence > 0.7 else None
```

**3. 全局地图拼接**
```python
class GlobalMapBuilder:
    def __init__(self):
        self.global_map = np.zeros((5000, 5000), dtype=np.uint8)
        self.player_pos = (2500, 2500)  # 中心起始点
    
    def update_global_map(self, current_paths, displacement):
        x, y = self.player_pos
        self.global_map[y:y+h, x:x+w] = cv2.add(
            self.global_map[y:y+h, x:x+w], current_paths
        )
```

#### 第二阶段：探索与路径规划

**1. "除草机"探索算法**
```python
class LawnmowerExplorer:
    """系统性地图探索算法"""
    def __init__(self):
        self.direction = "right"
        self.row_height = 50
        
    def get_next_move(self, current_pos, explored_map):
        if self._can_continue_current_direction():
            return self._get_direction_vector()
        else:
            self._move_to_next_row()
            self._reverse_direction()
            return self._get_direction_vector()
```

**2. A*寻路算法**
```python
class AStarPathfinder:
    def find_path(self, start, goal, obstacle_map):
        """A*算法寻找最优路径"""
        open_set = []
        heapq.heappush(open_set, (0, start))
        came_from = {}
        g_score = {start: 0}
        f_score = {start: self._heuristic(start, goal)}
        
        while open_set:
            current = heapq.heappop(open_set)[1]
            
            if current == goal:
                return self._reconstruct_path(came_from, current)
            
            for neighbor in self._get_neighbors(current):
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self._heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))
        
        return []  # 无路径
```

### 双模式运行

#### 探索模式
- **目标**：发现地图中的所有可通行区域
- **策略**：使用"除草机"算法系统性覆盖
- **触发**：未发现目标时自动启用

#### 导航模式
- **目标**：从当前位置到特定目标的最短路径
- **策略**：使用A*算法计算最优路径
- **触发**：发现目标后自动切换

### 配置示例
```json
{
  "pathfinding": {
    "enabled": true,
    "minimap_region": [1670, 50, 200, 200],
    "player_icon_color": [255, 255, 255],
    "path_color_range": [[100, 150, 100], [130, 255, 200]],
    "exploration_step": 50,
    "confidence_threshold": 0.7,
    "max_exploration_time": 300
  }
}
```

---

## 🔄 模块协同工作

### 状态管理统一性
所有功能模块都遵循统一的状态机：
```
STOPPED ←→ READY ←→ RUNNING ←→ PAUSED
```

### 模式互斥机制
- **技能模式**：F8控制，处理技能循环和药剂检测
- **洗练模式**：F7控制，独立的装备词缀洗练
- **寻路模式**：F9控制，自动地图探索和导航

### 资源共享
- **屏幕捕获**：所有模块共享同一帧数据，避免重复捕获
- **输入队列**：统一的PriorityDeque处理所有输入操作
- **配置管理**：ConfigManager统一管理所有模块配置

### 事件通信
```python
# 模块间通过EventBus进行通信
event_bus.publish("skill:cooldown_ready", skill_name="fireball")
event_bus.publish("resource:hp_low", current_hp=30)
event_bus.publish("pathfinding:target_found", target_pos=(100, 200))
```

通过这种模块化和事件驱动的设计，pyahk实现了高度灵活和可扩展的游戏自动化功能。