# 02 æ ¸å¿ƒæ¶æ„è®¾è®¡

## æ¦‚è¿°

pyahké‡‡ç”¨ç°ä»£åŒ–çš„åˆ†å±‚æ¶æ„å’Œæ¨¡å—åŒ–è®¾è®¡ï¼ŒåŸºäºäº‹ä»¶é©±åŠ¨æ¨¡å¼æ„å»ºã€‚æ•´ä¸ªç³»ç»Ÿå›´ç»•**äº‹ä»¶æ€»çº¿**è¿›è¡Œç»„ä»¶é—´é€šä¿¡ï¼Œé€šè¿‡**ç»Ÿä¸€è°ƒåº¦å™¨**ç®¡ç†å®šæ—¶ä»»åŠ¡ï¼Œä½¿ç”¨**é›¶æ‹·è´å±å¹•æ•è·**æŠ€æœ¯å®ç°é«˜æ€§èƒ½å›¾åƒå¤„ç†ã€‚

## æ ¸å¿ƒæ¶æ„åŸåˆ™

### 1. äº‹ä»¶é©±åŠ¨æ¶æ„
- **ä¸­å¤®äº‹ä»¶æ€»çº¿**ï¼šæ‰€æœ‰ç»„ä»¶é€šè¿‡EventBusè¿›è¡Œæ¾è€¦åˆé€šä¿¡
- **å‘å¸ƒ/è®¢é˜…æ¨¡å¼**ï¼šæ”¯æŒå¼‚æ­¥äº‹ä»¶å¤„ç†å’Œæ¨¡å—è§£è€¦
- **é€’å½’äº‹ä»¶æ£€æµ‹**ï¼šé˜²æ­¢äº‹ä»¶å¾ªç¯å’Œæ­»é”
- **çº¿ç¨‹å®‰å…¨**ï¼šæ”¯æŒå¤šçº¿ç¨‹ç¯å¢ƒä¸‹çš„äº‹ä»¶ä¼ é€’

### 2. ç»Ÿä¸€çŠ¶æ€ç®¡ç†
- **æ ‡å‡†çŠ¶æ€æœº**ï¼šSTOPPED â†’ READY â†’ RUNNING â†’ PAUSED
- **çŠ¶æ€è½¬æ¢æ§åˆ¶**ï¼šä¸¥æ ¼çš„çŠ¶æ€è½¬æ¢è§„åˆ™å’Œæƒé™æ£€æŸ¥
- **æ¨¡å¼äº’æ–¥**ï¼šæŠ€èƒ½æ¨¡å¼ã€æ´—ç»ƒæ¨¡å¼ã€å¯»è·¯æ¨¡å¼çš„äº’æ–¥æ‰§è¡Œ
- **ä¸€è‡´æ€§ä¿è¯**ï¼šæ‰€æœ‰åŠŸèƒ½æ¨¡å—éµå¾ªç»Ÿä¸€çš„çŠ¶æ€æµè½¬

### 3. æ¨¡å—åŒ–è®¾è®¡
- **å•ä¸€èŒè´£**ï¼šæ¯ä¸ªæ¨¡å—åªè´Ÿè´£ç‰¹å®šåŠŸèƒ½é¢†åŸŸ
- **æ¥å£æ ‡å‡†åŒ–**ï¼šç»Ÿä¸€çš„æ¨¡å—æ¥å£å’Œé€šä¿¡åè®®
- **å¯æ’æ‹”æ¶æ„**ï¼šæ”¯æŒæ¨¡å—çš„åŠ¨æ€åŠ è½½å’Œå¸è½½
- **ä¾èµ–æ³¨å…¥**ï¼šé€šè¿‡æ„é€ å‡½æ•°æ³¨å…¥ä¾èµ–å…³ç³»

## æ ¸å¿ƒç»„ä»¶æ¶æ„

### MacroEngine - ç³»ç»Ÿåè°ƒä¸­å¿ƒ
```python
class MacroEngine:
    """
    èŒè´£ï¼šçŠ¶æ€ç®¡ç†ã€èµ„æºè°ƒåº¦ã€æ¨¡å¼åè°ƒ
    """
    def __init__(self):
        self._state = MacroState.STOPPED
        self._state_lock = threading.Lock()
        self._transition_lock = threading.Lock()
        
        # åŠŸèƒ½æ¨¡å—ç®¡ç†
        self.skill_manager = None
        self.pathfinding_manager = None
        self.reroll_manager = None
        
        # èµ„æºç®¡ç†
        self.border_manager = None
        self.input_handler = None
        self.resource_manager = None
```

**æ ¸å¿ƒèŒè´£**ï¼š
- ç³»ç»ŸçŠ¶æ€ç®¡ç†å’Œè½¬æ¢æ§åˆ¶
- åŠŸèƒ½æ¨¡å—çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†
- æ ¹æ®å½“å‰æ¨¡å¼è°ƒåº¦åº•å±‚èµ„æº
- çƒ­é”®å¤„ç†å’Œç”¨æˆ·äº¤äº’å“åº”

### EventBus - é€šä¿¡ä¸­æ¢
```python
class EventBus:
    """
    èŒè´£ï¼šäº‹ä»¶åˆ†å‘ã€å¼‚æ­¥é€šä¿¡ã€æ¨¡å—è§£è€¦
    """
    def __init__(self):
        self.subscribers = defaultdict(list)
        self.subscribers_lock = threading.RLock()
        self._executor = ThreadPoolExecutor(max_workers=6)
        self._call_stack = threading.local()  # é€’å½’æ£€æµ‹
        
    def publish(self, event_name, *args, **kwargs):
        # æ”¯æŒåŒæ­¥/å¼‚æ­¥äº‹ä»¶åˆ†å‘
        
    def subscribe(self, event_name, callback):
        # äº‹ä»¶è®¢é˜…æ³¨å†Œ
```

**æŠ€æœ¯ç‰¹æ€§**ï¼š
- æ”¯æŒåŒæ­¥å’Œå¼‚æ­¥äº‹ä»¶å¤„ç†
- çº¿ç¨‹æ± ä¼˜åŒ–çš„äº‹ä»¶æ‰§è¡Œ(6ä¸ªå·¥ä½œçº¿ç¨‹)
- åŸºäºthreading.local()çš„é€’å½’äº‹ä»¶æ£€æµ‹å’Œé˜²æŠ¤
- æ€§èƒ½ç›‘æ§å’Œç»Ÿè®¡(æ¯120ç§’è®°å½•ä¸€æ¬¡)

### UnifiedScheduler - ä»»åŠ¡è°ƒåº¦æ ¸å¿ƒ
```python
class UnifiedScheduler:
    """
    èŒè´£ï¼šå®šæ—¶ä»»åŠ¡ç®¡ç†ã€ç²¾ç¡®è°ƒåº¦ã€èµ„æºæ§åˆ¶
    """
    def __init__(self):
        self._tasks = {}  # task_id -> ScheduledTask
        self._task_heap = []  # åŸºäºheapqçš„ä¼˜å…ˆçº§é˜Ÿåˆ—
        self._scheduler_thread = None
        self._lock = threading.Lock()
        self._condition = threading.Condition(self._lock)
        
    def _now(self) -> float:
        return time.monotonic()  # å•è°ƒæ—¶é—´æº
        
    def add_task(self, task_id, interval, callback, **kwargs):
        # åŠ¨æ€ä»»åŠ¡æ·»åŠ ï¼Œæ”¯æŒstart_immediatelyå‚æ•°
```

**æŠ€æœ¯ä¼˜åŠ¿**ï¼š
- åŸºäºheapqçš„é«˜æ•ˆä¼˜å…ˆçº§é˜Ÿåˆ—
- time.monotonic()å•è°ƒæ—¶é—´æºï¼Œé¿å…ç³»ç»Ÿæ—¶é’Ÿè°ƒæ•´å½±å“
- æ”¯æŒä»»åŠ¡çš„åŠ¨æ€å¢åˆ æ”¹å’Œæ›´æ–°
- å•çº¿ç¨‹è°ƒåº¦é¿å…ç«æ€æ¡ä»¶ï¼Œæä¾›äºšæ¯«ç§’çº§ç²¾åº¦

## è¾“å…¥ç³»ç»Ÿæ¶æ„

### è®¾è®¡ç›®æ ‡
- **ç»Ÿä¸€å…¥å£**ï¼šæ‰€æœ‰è¾“å…¥é€šè¿‡ `InputHandler` å¤„ç†
- **ä¼˜å…ˆçº§ä¿éšœ**ï¼šä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„PriorityDequeå®ç°ç´§æ€¥æ“ä½œæ’é˜Ÿ
- **ä½å»¶è¿Ÿæ‰§è¡Œ**ï¼šæœ€å°åŒ–é˜»å¡æ“ä½œï¼Œæ”¯æŒèŠ‚æµæ§åˆ¶
- **è°ƒè¯•å‹å¥½**ï¼šdry_run æ¨¡å¼ä¸‹å®Œæ•´è®°å½•è¡Œä¸ºè½¨è¿¹

### æ ¸å¿ƒç»„ä»¶

| ç»„ä»¶ | èŒè´£ |
|------|------|
| InputHandler | è¾“å…¥è°ƒåº¦ä¸æ‰§è¡Œï¼›ç»´æŠ¤MultiPriorityQueueã€çº¿ç¨‹ã€ä¼˜å…ˆçº§ç®¡ç†ã€æŒ‰é”®ç›‘å¬ |
| MultiPriorityQueue | å››çº§ä¼˜å…ˆé˜Ÿåˆ—ï¼šemergency/high/normal/lowï¼ŒæŒ‰ä¼˜å…ˆçº§é¡ºåºæ¶ˆè´¹ |
| PriorityKeysWidget | ä¼˜å…ˆçº§æŒ‰é”®é…ç½®UIï¼Œæ”¯æŒå¯è§†åŒ–ç®¡ç†å’Œé¢„è®¾æ¨¡å¼ |
| KeyboardListener | å®æ—¶é”®ç›˜æŒ‰é”®ç›‘å¬ï¼Œæ£€æµ‹ä¼˜å…ˆçº§æŒ‰é”®çŠ¶æ€ |
| MouseListener | å®æ—¶é¼ æ ‡æŒ‰é”®ç›‘å¬ï¼Œæ£€æµ‹ä¼˜å…ˆçº§æŒ‰é”®çŠ¶æ€ |
| HotkeyManager | å…¨å±€çƒ­é”®ç›‘å¬ï¼Œè½¬æ¢ä¸ºå†…éƒ¨äº‹ä»¶ |
| hold_server.ahk | æ¥æ”¶ WM_COPYDATAï¼Œæ‰§è¡ŒæŒ‰ä½/é‡Šæ”¾æ“ä½œ |
| DebugDisplayManager | æ¥æ”¶ dry_run åŠ¨ä½œæ–‡æœ¬ï¼Œä¾› OSD å±•ç¤º |

### MultiPriorityQueue æ¶æ„
```python
class MultiPriorityQueue:
    """å››çº§ä¼˜å…ˆé˜Ÿåˆ—ç³»ç»Ÿ"""
    def __init__(self, maxsize: int = 0):
        # æŒ‰ä¼˜å…ˆçº§ä»é«˜åˆ°ä½æ’åˆ—
        self._queues = {
            'emergency': deque(),  # ç´§æ€¥é˜Ÿåˆ— - HP/MPè¯å‰‚
            'high': deque(),       # é«˜ä¼˜å…ˆçº§é˜Ÿåˆ— - æ ¸å¿ƒæŠ€èƒ½
            'normal': deque(),     # æ™®é€šé˜Ÿåˆ— - å¸¸è§„æŠ€èƒ½
            'low': deque()         # ä½ä¼˜å…ˆçº§é˜Ÿåˆ— - è¾…åŠ©åŠŸèƒ½
        }
        self._priority_order = ['emergency', 'high', 'normal', 'low']
        self._maxsize = maxsize
        self._cond = threading.Condition()

    def put(self, item, priority='normal', block=False, timeout=None):
        """æŒ‰ä¼˜å…ˆçº§æ”¾å…¥å…ƒç´ """

    def get(self, block=True, timeout=None):
        """æŒ‰ä¼˜å…ˆçº§é¡ºåºå–å‡ºå…ƒç´ """
        for priority in self._priority_order:
            if self._queues[priority]:
                return self._queues[priority].popleft()
```

### è¾“å…¥å¤„ç†æµç¨‹
```
æŠ€èƒ½é€»è¾‘å†³å®šè¾“å…¥éœ€æ±‚
    â†“
æ£€æŸ¥ä¼˜å…ˆçº§æŒ‰é”®çŠ¶æ€ (space/right_mouseç­‰)
    â†“ (ä¼˜å…ˆçº§æŒ‰é”®æŒ‰ä¸‹æ—¶è·³è¿‡æ™®é€šæŠ€èƒ½)
InputHandler.execute_skill_*(action, priority_level)
    â†“
MultiPriorityQueue.put(action, priority='emergency'/'high'/'normal'/'low')
    â†“
åå°çº¿ç¨‹: MultiPriorityQueue.get() (æŒ‰ä¼˜å…ˆçº§é¡ºåºæ¶ˆè´¹)
    â†“
è§£æåŠ¨ä½œç±»å‹ (key_press/mouse_click/hold_*/etc.)
    â†“
æ ¹æ®dry_runæ¨¡å¼å†³å®šï¼šçœŸå®æ‰§è¡Œ or è®°å½•è°ƒè¯•
    â†“
pynput/AHKæœåŠ¡æ‰§è¡Œ or DebugDisplayManagerè®°å½•
```

### ä¼˜å…ˆçº§æŒ‰é”®ç›‘æ§æµç¨‹ - æœ€æ–°æ¶æ„
```
ç”¨æˆ·æŒ‰ä¸‹ä¼˜å…ˆçº§æŒ‰é”® (space/right_mouse)
    â†“
KeyboardListener/MouseListeneræ£€æµ‹åˆ°æŒ‰é”®äº‹ä»¶
    â†“
æ›´æ–°_priority_keys_pressedé›†åˆ
    â†“
ğŸš€ ç¬¬ä¸€ä¸ªä¼˜å…ˆçº§æŒ‰é”®æŒ‰ä¸‹æ—¶ï¼š
InputHandler._pause_skill_scheduler()
    â†“
event_bus.publish('scheduler_pause_requested')
    â†“
SkillManager._on_scheduler_pause_requested()
    â†“
unified_scheduler.pause() - æš‚åœæ‰€æœ‰è°ƒåº¦ä»»åŠ¡
    â†“
ğŸ›‘ CPUä½¿ç”¨ç‡å¤§å¹…é™ä½ - åœæ­¢å¸§æ•è·ã€å†·å´æ£€æŸ¥ç­‰

ç”¨æˆ·é‡Šæ”¾ä¼˜å…ˆçº§æŒ‰é”®
    â†“
æ‰€æœ‰ä¼˜å…ˆçº§æŒ‰é”®é‡Šæ”¾æ—¶ï¼š
InputHandler._resume_skill_scheduler()
    â†“
event_bus.publish('scheduler_resume_requested')
    â†“
SkillManager._on_scheduler_resume_requested()
    â†“
unified_scheduler.resume() - æ¢å¤æ‰€æœ‰è°ƒåº¦ä»»åŠ¡
    â†“
â–¶ï¸ ç³»ç»Ÿæ¢å¤æ­£å¸¸è¿è¡Œ
```

### ğŸš€ ä¼˜å…ˆçº§æŒ‰é”®æš‚åœ/æ¢å¤æ¶æ„

#### æ ¸å¿ƒä¼˜åŒ–åŸç†
ä¼ ç»Ÿå®ç°ä¸­ï¼Œå½“ä¼˜å…ˆçº§æŒ‰é”®æ¿€æ´»æ—¶ï¼Œè™½ç„¶æŠ€èƒ½æ‰§è¡Œè¢«é˜»å¡ï¼Œä½† `UnifiedScheduler` ä»åœ¨è¿è¡Œï¼Œå¯¼è‡´ï¼š
- `check_cooldowns` ç»§ç»­æ‰§è¡Œä½†ç»“æœè¢«ä¸¢å¼ƒ
- å¸§æ•è·å’Œåƒç´ åˆ†ææŒç»­è¿›è¡Œä½†æ— æ•ˆ
- èµ„æºæ£€æŸ¥ç­‰CPUå¯†é›†æ“ä½œé€ æˆ"é›¶åŠŸæ•ˆçš„èµ„æºæµªè´¹"

æ–°æ¶æ„é€šè¿‡**äº‹ä»¶é©±åŠ¨çš„æš‚åœ/æ¢å¤æœºåˆ¶**å®ç°çœŸæ­£çš„"æŒ‰éœ€è®¡ç®—"ï¼š

#### æ¶æ„ç»„ä»¶

**InputHandler** - ä¼˜å…ˆçº§æŒ‰é”®çŠ¶æ€ç›‘æ§
```python
def _pause_skill_scheduler(self):
    """æš‚åœæŠ€èƒ½è°ƒåº¦å™¨ä»¥èŠ‚çœCPUèµ„æº"""
    event_bus.publish('scheduler_pause_requested', {
        'reason': 'priority_key_pressed',
        'active_keys': list(self._priority_keys_pressed)
    })

def _resume_skill_scheduler(self):
    """æ¢å¤æŠ€èƒ½è°ƒåº¦å™¨"""
    event_bus.publish('scheduler_resume_requested', {
        'reason': 'priority_key_released'
    })
```

**SkillManager** - è°ƒåº¦å™¨æ§åˆ¶å“åº”
```python
def _on_scheduler_pause_requested(self, event_data):
    """å“åº”ä¼˜å…ˆçº§æŒ‰é”®æŒ‰ä¸‹ - æš‚åœè°ƒåº¦å™¨ä»¥èŠ‚çœCPUèµ„æº"""
    if self.unified_scheduler.get_status()["running"]:
        self.unified_scheduler.pause()

def _on_scheduler_resume_requested(self, event_data):
    """å“åº”ä¼˜å…ˆçº§æŒ‰é”®é‡Šæ”¾ - æ¢å¤è°ƒåº¦å™¨"""
    if self._is_running and not self._is_paused:
        self.unified_scheduler.resume()
```

**UnifiedScheduler** - æ™ºèƒ½æš‚åœ/æ¢å¤
```python
def pause(self) -> bool:
    """æš‚åœæ‰€æœ‰ä»»åŠ¡æ‰§è¡Œ"""
    if not self._running or self._paused:
        return False
    self._paused = True
    return True

def resume(self) -> bool:
    """æ¢å¤æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œ"""
    if not self._running or not self._paused:
        return False
    self._paused = False
    # æ™ºèƒ½é‡æ–°è®¡ç®—ä»»åŠ¡æ‰§è¡Œæ—¶é—´
    current_time = self._now()
    for task in self._tasks.values():
        if task.enabled:
            task.next_run_time = current_time + task.interval
    self._rebuild_heap()
    self._condition.notify()
    return True
```

#### æ€§èƒ½ä¼˜åŒ–æ•ˆæœ
- **CPUä½¿ç”¨ç‡**ï¼šä¼˜å…ˆçº§æŒ‰é”®æ¿€æ´»æœŸé—´é™ä½70-90%
- **èµ„æºèŠ‚çº¦**ï¼šå®Œå…¨åœæ­¢æ— æ•ˆçš„å¸§æ•è·ã€åƒç´ åˆ†æã€å†·å´æ£€æŸ¥
- **å“åº”æ€§**ï¼šç³»ç»Ÿæ•´ä½“å“åº”æ›´åŠ æµç•…
- **é›¶æµªè´¹**ï¼šå®ç°çœŸæ­£çš„"æŒ‰éœ€è®¡ç®—"ï¼Œåªåœ¨å®é™…éœ€è¦æ—¶æ¶ˆè€—CPUèµ„æº

#### çŠ¶æ€ç®¡ç†å±‚çº§
1. **ç”¨æˆ·æ‰‹åŠ¨æš‚åœ** (`_is_paused = True`): é€šè¿‡UIæˆ–çƒ­é”®æš‚åœæ•´ä¸ªç³»ç»Ÿ
2. **ä¼˜å…ˆçº§æŒ‰é”®æš‚åœ** (`unified_scheduler.pause()`): ä¸´æ—¶æ€§èƒ½ä¼˜åŒ–æš‚åœ
3. **ç³»ç»Ÿåœæ­¢** (`_is_running = False`): å®Œå…¨åœæ­¢è¿è¡Œ

æ¢å¤é€»è¾‘ç¡®ä¿åªæœ‰åœ¨ç³»ç»Ÿè¿è¡Œä¸­ä¸”æœªè¢«ç”¨æˆ·æ‰‹åŠ¨æš‚åœæ—¶æ‰ä¼šè‡ªåŠ¨æ¢å¤ã€‚

### Hold(æŒ‰ä½)æ¨¡å¼æ¶æ„
```python
# Holdæ¨¡å¼çŠ¶æ€ç®¡ç†
def _handle_hold_skills_on_running():
    for skill in hold_skills:
        send_hold_command(skill.key)

def _handle_hold_skills_on_stop():
    for active_hold in self._active_holds:
        send_release_command(active_hold)
```

**æŠ€æœ¯ä¼˜åŠ¿**ï¼š
- ä¸å ç”¨è°ƒåº¦å™¨èµ„æº
- ç®€å•ç¨³å®šçš„çŠ¶æ€ç®¡ç†
- é¿å…è¯¯é‡å¤æŒ‰ä¸‹
- æ”¯æŒç»„åˆé”®å’Œå¤æ‚æŒ‰é”®åºåˆ—
- åºåˆ—çº§å»é‡å’Œæ¸…ç†æœºåˆ¶

### ğŸ¯ æŒ‰é”®åºåˆ—å¤„ç†æ¶æ„

#### åºåˆ—è§£æä¸åˆ†å‘
```python
def execute_skill_normal(self, key: str):
    """æ‰§è¡Œæ™®é€šæŠ€èƒ½æŒ‰é”® - æ”¯æŒåºåˆ— delay50,q"""
    if ',' in key:
        key_sequence = [k.strip() for k in key.split(',') if k.strip()]
        for i, individual_key in enumerate(key_sequence):
            self._key_queue.put(individual_key, priority='normal', block=False)
            # åœ¨æœ€åä¸€ä¸ªå…ƒç´ åæ·»åŠ æ¸…ç†æ ‡è®°
            if i == len(key_sequence) - 1:
                cleanup_marker = f"__cleanup_sequence__{key}"
                self._key_queue.put(cleanup_marker, priority='normal', block=False)
        # å°†æ•´ä¸ªåºåˆ—å­—ç¬¦ä¸²åŠ å…¥å»é‡é›†åˆ
        self._queued_keys_set.add(key)
```

#### å»¶è¿ŸæŒ‡ä»¤å¤„ç†
```python
def _queue_processor_loop(self):
    """é˜Ÿåˆ—å¤„ç†å™¨å¾ªç¯ - æ”¯æŒå»¶è¿ŸæŒ‡ä»¤"""
    while not self._stop_event.is_set():
        key_to_execute = self._key_queue.get(timeout=0.1)
        
        # å¤„ç†å»¶è¿ŸæŒ‡ä»¤
        if key_to_execute.lower().startswith("delay"):
            delay_ms = int(key_to_execute[5:])
            if self._stop_event.wait(delay_ms / 1000.0):
                break
            continue
```

#### åºåˆ—å»é‡æœºåˆ¶
- **æ•´ä½“åºåˆ—å»é‡**ï¼š`delay50,q` ä½œä¸ºå®Œæ•´å•å…ƒå¤„ç†
- **æ¸…ç†æ ‡è®°ç³»ç»Ÿ**ï¼šè‡ªåŠ¨æ¸…ç†å·²å®Œæˆåºåˆ—çš„è·Ÿè¸ªçŠ¶æ€
- **çŠ¶æ€ä¸€è‡´æ€§**ï¼šç¡®ä¿ `_queued_keys_set` ä¸å®é™…é˜Ÿåˆ—åŒæ­¥

**æ¶æ„ä¼˜åŠ¿**ï¼š
- ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶ï¼ˆæ¯«ç§’çº§å»¶è¿Ÿï¼‰
- æ™ºèƒ½çš„åºåˆ—ç®¡ç†ï¼ˆé¿å…é‡å¤å’Œå†²çªï¼‰
- æ¸…ç†æœºåˆ¶ä¿è¯å†…å­˜æ•ˆç‡
- æ”¯æŒä»»æ„å¤æ‚çš„æŒ‰é”®ç»„åˆ

## æ•°æ®æµæ¶æ„

### å±å¹•æ•è·æ•°æ®æµ
```
DXGI Desktop Duplication (C++)
    â†“ é›¶æ‹·è´å…±äº«å†…å­˜
NativeGraphicsCaptureManager (Python ctypes)
    â†“ å¸§æ•°æ®åˆ†å‘
BorderFrameManager (ç¼“å­˜ç®¡ç†)
    â†“ æŒ‰éœ€åˆ†å‘åˆ°å„æ£€æµ‹æ¨¡å—
SkillManager/ResourceManager/PathfindingManager
```

### ç”¨æˆ·è¾“å…¥æ•°æ®æµ
```
ç”¨æˆ·æ“ä½œ (GUI/çƒ­é”®)
    â†“ äº‹ä»¶å‘å¸ƒ
EventBus (äº‹ä»¶åˆ†å‘)
    â†“ çŠ¶æ€æ›´æ–°
MacroEngine (çŠ¶æ€ç®¡ç†)
    â†“ æ¨¡å—è°ƒåº¦
å…·ä½“åŠŸèƒ½æ¨¡å— (æ‰§è¡Œæ“ä½œ)
    â†“ PriorityDequeå…¥é˜Ÿ
InputHandler (ä¼˜å…ˆçº§é˜Ÿåˆ—ç®¡ç†)
    â†“ ç¡¬ä»¶è¾“å‡º
pynput/AHKæœåŠ¡
```

### é…ç½®æ•°æ®æµ
```
JSONé…ç½®æ–‡ä»¶
    â†“ åŠ è½½è§£æ
ConfigManager (é…ç½®ç®¡ç†)
    â†“ äº‹ä»¶é€šçŸ¥
EventBus (é…ç½®æ›´æ–°äº‹ä»¶)
    â†“ é…ç½®åŒæ­¥
å„åŠŸèƒ½æ¨¡å— (çƒ­æ›´æ–°)
```

## çº¿ç¨‹æ¨¡å‹è®¾è®¡

### ä¸»çº¿ç¨‹ (GUIçº¿ç¨‹)
- **èŒè´£**ï¼šç”¨æˆ·ç•Œé¢æ›´æ–°ã€äº‹ä»¶å¤„ç†
- **ç‰¹ç‚¹**ï¼šQtä¸»äº‹ä»¶å¾ªç¯ï¼Œçº¿ç¨‹å®‰å…¨çš„UIæ›´æ–°
- **é€šä¿¡**ï¼šé€šè¿‡QTimerå’Œä¿¡å·æ§½ä¸åå°çº¿ç¨‹é€šä¿¡

### è°ƒåº¦çº¿ç¨‹ (UnifiedScheduler)
- **èŒè´£**ï¼šå®šæ—¶ä»»åŠ¡çš„ç²¾ç¡®è°ƒåº¦å’Œæ‰§è¡Œ
- **ç‰¹ç‚¹**ï¼šå•çº¿ç¨‹ä¸²è¡Œæ‰§è¡Œï¼Œé¿å…ç«æ€æ¡ä»¶
- **æ€§èƒ½**ï¼šé«˜ç²¾åº¦è®¡æ—¶ï¼Œä½å»¶è¿Ÿä»»åŠ¡åˆ†å‘

### è¾“å…¥å¤„ç†çº¿ç¨‹ (InputHandler)
```python
class InputHandler:
    def __init__(self):
        self._key_queue = MultiPriorityQueue(maxsize=9)
        self._processing_thread = threading.Thread(
            target=self._process_input_queue
        )
        # ä¼˜å…ˆçº§æŒ‰é”®ç›‘å¬å™¨
        self._keyboard_listener = None
        self._mouse_listener = None
        self._priority_keys_pressed = set()
```

### åŠŸèƒ½çº¿ç¨‹ (ç‹¬ç«‹æ¨¡å—)
```python
# æ´—ç»ƒç®¡ç†å™¨ - ç‹¬ç«‹çº¿ç¨‹
class SimpleAffixRerollManager(threading.Thread):
    def run(self):
        # ç‹¬ç«‹çš„æ´—ç»ƒé€»è¾‘å¾ªç¯
        
# å¯»è·¯ç®¡ç†å™¨ - ç‹¬ç«‹çº¿ç¨‹  
class PathfindingManager(threading.Thread):
    def run(self):
        # ç‹¬ç«‹çš„å¯»è·¯è®¡ç®—å¾ªç¯
```

### äº‹ä»¶æ€»çº¿çº¿ç¨‹æ± 
- **ThreadPoolExecutor**: 6ä¸ªå·¥ä½œçº¿ç¨‹
- **å¼‚æ­¥äº‹ä»¶å¤„ç†**: éé˜»å¡äº‹ä»¶åˆ†å‘
- **é€’å½’æ£€æµ‹**: per-threadè°ƒç”¨æ ˆç›‘æ§

## å†…å­˜ç®¡ç†æ¶æ„

### å›¾åƒæ•°æ®ç®¡ç†
```python
class BorderFrameManager:
    def __init__(self):
        # ç»Ÿä¸€çš„å›¾åƒç¼“å­˜ç®¡ç†
        self._frame_cache = {}
        self._template_cache = {}
        self._cache_lock = threading.Lock()
        
    def get_cached_frame(self, cache_key):
        # å¸¦è¿‡æœŸæ—¶é—´çš„å¸§ç¼“å­˜
        
    def update_template_cache(self, region_name, template_data):
        # HSVæ¨¡æ¿ç¼“å­˜ç®¡ç†
```

### C++å±‚é›¶æ‹·è´ç®¡ç†
```cpp
class DXGICaptureSession {
    // åŒç¼“å†²åŒºè®¾è®¡
    std::vector<uint8_t> buffer_a;
    std::vector<uint8_t> buffer_b;
    
    // åŸå­æŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰å¯è¯»ç¼“å†²åŒº
    std::atomic<uint8_t*> current_read_buffer;
    
    // å†™å…¥ç¼“å†²åŒºåˆ‡æ¢æ ‡å¿—
    bool writing_to_a = true;
};
```

### å¯¹è±¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
- **æ‡’åŠ è½½**ï¼šæŒ‰éœ€åˆ›å»ºé‡èµ„æºå¯¹è±¡ï¼ˆå¦‚OCRå¼•æ“ï¼‰
- **å¯¹è±¡æ± **ï¼šå¤ç”¨é¢‘ç¹åˆ›å»ºçš„å¯¹è±¡
- **å¼•ç”¨è®¡æ•°**ï¼šè‡ªåŠ¨æ¸…ç†ä¸å†ä½¿ç”¨çš„èµ„æº
- **å†…å­˜ç›‘æ§**ï¼šå®æ—¶ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µ

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### è¾“å…¥ç³»ç»Ÿä¼˜åŒ–
- **æ‰¹é‡å¤„ç†**: åˆå¹¶è¿ç»­çš„åŒç±»å‹æ“ä½œ
- **æ™ºèƒ½èŠ‚æµ**: æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´å»¶è¿Ÿ
- **é˜Ÿåˆ—ç›‘æ§**: é˜²æ­¢é˜Ÿåˆ—ç§¯å‹å¯¼è‡´çš„å»¶è¿Ÿ

### è°ƒåº¦å™¨ä¼˜åŒ–
- **ä»»åŠ¡åˆå¹¶**: ç›¸è¿‘æ—¶é—´çš„ä»»åŠ¡åˆå¹¶æ‰§è¡Œ
- **ä¼˜å…ˆçº§ç»§æ‰¿**: é˜²æ­¢ä½ä¼˜å…ˆçº§ä»»åŠ¡é¥¿æ­»
- **è´Ÿè½½å‡è¡¡**: åŠ¨æ€è°ƒæ•´ä»»åŠ¡æ‰§è¡Œé¢‘ç‡

### äº‹ä»¶æ€»çº¿ä¼˜åŒ–
- **äº‹ä»¶è¿‡æ»¤**: é¿å…ä¸å¿…è¦çš„äº‹ä»¶ä¼ æ’­
- **æ‰¹é‡è®¢é˜…**: å‡å°‘é”ç«äº‰
- **æ™ºèƒ½è·¯ç”±**: åŸºäºäº‹ä»¶ç±»å‹çš„å¿«é€Ÿåˆ†å‘

## æ‰©å±•ç‚¹è®¾è®¡

### æ–°åŠŸèƒ½æ¨¡å—é›†æˆ
1. å®ç°æ ‡å‡†æ¥å£ (`start()`, `stop()`, `pause()`, `resume()`)
2. è®¢é˜…å¿…è¦çš„äº‹ä»¶ (`engine:state_changed`, `config:updated`)
3. æ³¨å†Œåˆ°MacroEngineçš„æ¨¡å—ç®¡ç†å™¨
4. æ·»åŠ é…ç½®å­—æ®µåˆ°JSON schema

### è‡ªå®šä¹‰è¾“å…¥å¤„ç†å™¨
```python
class CustomInputProcessor:
    def process_action(self, action: dict) -> bool:
        # è‡ªå®šä¹‰è¾“å…¥å¤„ç†é€»è¾‘
        return True
        
# æ³¨å†Œåˆ°InputHandler
input_handler.register_processor(CustomInputProcessor())
```

### äº‹ä»¶æ‰©å±•
```python
# å®šä¹‰æ–°äº‹ä»¶
event_bus.publish("custom:new_event", data=custom_data)

# è®¢é˜…å¤„ç†
def handle_custom_event(data):
    # å¤„ç†è‡ªå®šä¹‰äº‹ä»¶
    pass
    
event_bus.subscribe("custom:new_event", handle_custom_event)
```

è¿™ç§æ¶æ„è®¾è®¡ç¡®ä¿äº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§ã€å¯ç»´æŠ¤æ€§å’Œé«˜æ€§èƒ½ï¼Œä¸ºå¤æ‚çš„æ¸¸æˆè‡ªåŠ¨åŒ–éœ€æ±‚æä¾›äº†åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚