# 05 图像捕获与性能

本章详细介绍pyahk的图像捕获技术、模板匹配算法与性能优化策略，重点讲解基于DXGI的零拷贝屏幕捕获技术和高效的图像处理管道。

---
## 1. 核心捕获技术

### DXGI Desktop Duplication 零拷贝实现
```cpp
// C++底层实现 - capture_lib.cpp
class DXGICaptureSession {
    // 双缓冲区设计
    std::vector<uint8_t> buffer_a;
    std::vector<uint8_t> buffer_b;
    
    // 原子指针，指向当前可读缓冲区
    std::atomic<uint8_t*> current_read_buffer;
    
    // 写入缓冲区切换标志
    bool writing_to_a = true;
};
```

### Python层零拷贝接口
```python
# python_wrapper.py
def get_frame(self, session_id: int) -> Optional[np.ndarray]:
    """Zero-Copy NumPy Array Creation"""
    frame_ptr = self._lib.capture_get_frame(handle)
    # 直接使用C++内存创建NumPy数组
    # 注意：返回的数组与C++共享内存，应立即处理
```

### 架构数据流
```
DXGI Desktop Duplication (C++) 
    ↓ 零拷贝共享内存
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发到各检测模块
SkillManager/ResourceManager/PathfindingManager
```

---
## 2. 准备阶段 (READY)
- F8/F9 进入 READY 时只执行一次：
  - `capture_once_for_debug_and_cache()`：获取静态帧（用于调试对比/日志）
  - `capture_template_hsv()`：截取 HP/MP 区域转换 HSV 模板
  - 技能冷却图标：可在首次检测时延迟截取或使用坐标矩形局部提取

目的：冻结一组稳定参考，避免运行期间背景波动影响模板。

---
## 3. 技能冷却检测

| 步骤 | 描述 |
|------|------|
| 1 | 通过坐标 + Size 提取正方形 ROI |
| 2 | 计算与缓存模板的 RGB 相似度 (阈值默认 95%) |
| 3 | 高于阈值判定为“Ready”，否则处于冷却或未知 |

优化建议：
- 降低 ROI 尺寸以减少噪声（典型 12~20 像素）
- 跳过启用=false 的技能
- 合并多技能 ROI 提取（未来批处理）

---
## 4. 资源 (HP/MP) HSV 模板匹配

流程：
1. READY 阶段缓存 HSV 模板 (region → HSV 转换)
2. 运行时 ROI → HSV → 按容差范围统计匹配像素比例
3. 计算剩余百分比 vs threshold → 判定是否触发

技巧：
- H 值环绕：差值 >180 → 360-差值
- 容差不宜过大，否则“假满”
- 可引入“双段阈值 + 滞后”减少抖动

---
## 5. 模板缓存策略

| 类型 | 位置 | 更新时机 |
|------|------|----------|
| HP/MP HSV | ResourceManager / BorderFrameManager | READY / 手动刷新 |
| 技能图标 | BorderFrameManager | 首次冷却检测或 READY 捕获 |
| 调试帧 | debug_frame_xxxx.png | 每次准备 / 手动触发 |

清理：未来可添加 LRU 或按分辨率/版本签名失效。

---
## 6. 任务频率规划

| 任务 | 推荐间隔 | 说明 |
|------|----------|------|
| 冷却检测 | 120~200ms | 过低收益小；避免抢占资源 |
| 药剂检测 | 150~250ms | 高峰时可降低频率 |
| Debug 发布 | ≥200ms | UI 线程安全刷新 |
| 寻路重规划 | 300~500ms | 地图位移 + 目标识别 |

---
## 7. 性能瓶颈常见来源
- 过多高频 Scheduler 任务（<80ms）
- 每次检测重复 `cv2.cvtColor` / 过大 ROI
- 不必要的深拷贝 (np.array(frame))
- 频繁磁盘 IO（调试帧保存过多）
- 大量 DEBUG 日志字符串拼接

---
## 8. 优化策略清单
| 场景 | 策略 |
|------|------|
| ROI 过大 | 缩小至核心像素区域 |
| HSV 转换重复 | 缓存同一帧的 HSV 版（需衡量内存） |
| 模板抖动 | 增加连续性窗口 / 移动平均 |
| CPU 占用高 | 合并任务间隔；调试发布降频 |
| 图像检测延迟 | 使用整型运算 / 向量化替代循环 |

---
## 9. 性能评估建议
- 采集周期：统计 scheduler 实际执行延迟（计划 vs 实际）
- 帧耗时：在关键算法块加时间差日志（DEBUG 模式）
- 资源曲线：将 HP/MP 比例定期写入结构（后期可视化）

---
## 10. 未来增强方向
- SIMD / Numba 加速 HSV 匹配
- 批量 ROI 提取（一次切片返回多个区域）
- 自适应调度（空闲期自动加大间隔）
- GPU 加速（CUDA/OpenCL）
- 模板质量评分 + 自动重采样提示

---
本章完。返回目录：`README` 或继续阅读下一章节。
