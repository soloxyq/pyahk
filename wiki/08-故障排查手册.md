# 08 æ•…éšœæ’æŸ¥æ‰‹å†Œ

## æ¦‚è¿°

æœ¬ç« æä¾›pyahkå¸¸è§é—®é¢˜çš„è¯Šæ–­å’Œè§£å†³æ–¹æ¡ˆï¼Œæ¶µç›–å®‰è£…ã€è¿è¡Œã€é…ç½®ã€æ€§èƒ½ç­‰å„ä¸ªæ–¹é¢çš„æ•…éšœæ’æŸ¥æ–¹æ³•ï¼Œå¸®åŠ©ç”¨æˆ·å¿«é€Ÿå®šä½å¹¶è§£å†³é—®é¢˜ã€‚

---

## ğŸš¨ å¿«é€Ÿè¯Šæ–­

### âš¡ **ç´§æ€¥é—®é¢˜ï¼šè¾“å…¥å®Œå…¨æ— å“åº”**

**ç°è±¡**: ç¨‹åºå¯åŠ¨åé¼ æ ‡å’Œé”®ç›˜å®Œå…¨å¤±æ•ˆï¼Œå¿…é¡»æŒ‰å³é”®æˆ–é‡å¯ç¨‹åºæ‰èƒ½æ¢å¤

**ç«‹å³è§£å†³**:
```bash
# 1. ç«‹å³å…³é—­ç¨‹åºï¼ˆå¦‚æœé¼ æ ‡å¯ç”¨ï¼‰
# 2. å¦‚æœé¼ æ ‡ä¹Ÿå¤±æ•ˆï¼ŒæŒ‰ Ctrl+Alt+Del æ‰“å¼€ä»»åŠ¡ç®¡ç†å™¨å¼ºåˆ¶ç»“æŸè¿›ç¨‹
# 3. é‡æ–°å¯åŠ¨ç¨‹åº
```

**æ ¹æœ¬åŸå› **: ä¼˜å…ˆçº§æŒ‰é”®ç›‘å¬ç³»ç»Ÿé—®é¢˜ï¼ˆå·²åœ¨2025.01ç‰ˆæœ¬ä¿®å¤ï¼‰

**æ°¸ä¹…è§£å†³**: æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬ï¼Œæ–°æ¶æ„åŸºäºWindows Hookæœºåˆ¶ï¼Œå½»åº•è§£å†³è¯¥é—®é¢˜

---

### é—®é¢˜åˆ†ç±»æ£€æŸ¥æ¸…å•

#### åŸºç¡€è¿è¡Œé—®é¢˜
- [ ] Pythonç‰ˆæœ¬æ˜¯å¦ç¬¦åˆè¦æ±‚ (3.7+)
- [ ] æ˜¯å¦ä»¥ç®¡ç†å‘˜æƒé™è¿è¡Œ
- [ ] é˜²ç«å¢™æ˜¯å¦é˜»æ­¢ç¨‹åº
- [ ] æ€æ¯’è½¯ä»¶æ˜¯å¦è¯¯æŠ¥

#### ä¾èµ–é—®é¢˜
- [ ] requirements.txtæ˜¯å¦å®Œæ•´å®‰è£…
- [ ] PaddleOCRæ˜¯å¦æ­£ç¡®åˆå§‹åŒ–
- [ ] C++è¿è¡Œåº“æ˜¯å¦å®‰è£…
- [ ] native_capture.dllæ˜¯å¦ç¼–è¯‘æˆåŠŸ

#### é…ç½®é—®é¢˜
- [ ] JSONé…ç½®æ–‡ä»¶è¯­æ³•æ˜¯å¦æ­£ç¡®
- [ ] åæ ‡é…ç½®æ˜¯å¦é€‚åˆå½“å‰åˆ†è¾¨ç‡
- [ ] æƒé™è®¾ç½®æ˜¯å¦æ­£ç¡®
- [ ] çƒ­é”®æ˜¯å¦è¢«å…¶ä»–ç¨‹åºå ç”¨

---

## ğŸ”§ å®‰è£…ä¸å¯åŠ¨é—®é¢˜

### Q1: ç¨‹åºæ— æ³•å¯åŠ¨ï¼Œæç¤ºæ¨¡å—ç¼ºå¤±
```bash
# é”™è¯¯ç¤ºä¾‹
ImportError: No module named 'PySide6'
ModuleNotFoundError: No module named 'cv2'
```

**è¯Šæ–­æ­¥éª¤**:
```bash
# 1. æ£€æŸ¥Pythonç¯å¢ƒ
python --version
pip --version

# 2. æ£€æŸ¥å·²å®‰è£…åŒ…
pip list | grep -i pyside6
pip list | grep -i opencv

# 3. é‡æ–°å®‰è£…ä¾èµ–
pip install -r requirements.txt --force-reinstall
```

**è§£å†³æ–¹æ¡ˆ**:
```bash
# æ–¹æ¡ˆ1: æ¸…ç†é‡è£…
pip uninstall PySide6 opencv-python
pip install PySide6>=6.5.0 opencv-python>=4.5.0

# æ–¹æ¡ˆ2: ä½¿ç”¨å›½å†…é•œåƒ
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple

# æ–¹æ¡ˆ3: è™šæ‹Ÿç¯å¢ƒé‡å»º
python -m venv fresh_env
fresh_env\Scripts\activate
pip install -r requirements.txt
```

### Q2: è¾“å…¥ç³»ç»Ÿå®Œå…¨æ— å“åº” âš ï¸

**ç—‡çŠ¶æè¿°**:
```
- ç¨‹åºå¯åŠ¨åé¼ æ ‡ç§»åŠ¨ã€ç‚¹å‡»å®Œå…¨æ— æ•ˆ
- é”®ç›˜æŒ‰é”®æ— ä»»ä½•å“åº”
- åªæœ‰æŒ‰ä¸€æ¬¡å³é”®åæ‰èƒ½æ¢å¤æ­£å¸¸
- æˆ–è€…éœ€è¦é‡å¯ç¨‹åºæ‰èƒ½æ¢å¤
```

**é—®é¢˜ç­‰çº§**: ğŸ”´ ä¸¥é‡ - å½±å“æ‰€æœ‰ç”¨æˆ·æ“ä½œ

**å¿«é€Ÿè¯Šæ–­**:
```python
# æ£€æŸ¥æ˜¯å¦ä½¿ç”¨æ—§ç‰ˆæœ¬çš„pynputç›‘å¬å™¨
import psutil
import sys

# æŸ¥çœ‹è¿›ç¨‹ä¿¡æ¯
for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
    if 'python' in proc.info['name'].lower():
        print(f"Pythonè¿›ç¨‹: {proc.info}")

# æ£€æŸ¥ç‰ˆæœ¬å’Œæ¶æ„
print(f"å½“å‰ç‰ˆæœ¬: æ£€æŸ¥æ˜¯å¦ä¸º2025.01+ç‰ˆæœ¬")
print(f"æ¶æ„ç±»å‹: åº”ä¸ºCtypesHotkeyManagerï¼Œépynput")
```

**è§£å†³æ–¹æ¡ˆ**:
```bash
# ç«‹å³è§£å†³ï¼ˆä¸´æ—¶ï¼‰:
1. å¼ºåˆ¶å…³é—­ç¨‹åºï¼šCtrl+Alt+Del -> ä»»åŠ¡ç®¡ç†å™¨ -> ç»“æŸè¿›ç¨‹
2. é‡æ–°å¯åŠ¨ç¨‹åº
3. å¦‚æœé—®é¢˜é‡ç°ï¼Œå‡çº§åˆ°æœ€æ–°ç‰ˆæœ¬

# æ ¹æœ¬è§£å†³ï¼ˆæ°¸ä¹…ï¼‰:
1. æ›´æ–°åˆ°2025.01+ç‰ˆæœ¬
2. æ–°ç‰ˆæœ¬ä½¿ç”¨Windows Hookæ¶æ„ï¼Œå½»åº•è§£å†³è¯¥é—®é¢˜
3. éªŒè¯æ—¥å¿—ä¸­çœ‹åˆ° "[è¾“å…¥å¤„ç†å™¨] ä¼˜å…ˆçº§æŒ‰é”®ç›‘å¬å·²å¯åŠ¨" å­—æ ·
```

**æŠ€æœ¯èƒŒæ™¯**:
- æ—§ç‰ˆæœ¬ä½¿ç”¨pynputçš„suppress=Trueæœºåˆ¶
- è¯¥æœºåˆ¶ä¼šå…¨å±€æ‹¦æˆªæ‰€æœ‰è¾“å…¥äº‹ä»¶
- æ–°ç‰ˆæœ¬æ”¹ç”¨CtypesHotkeyManageråŸºäºWindows Hook
- æ–°æ¶æ„é€‰æ‹©æ€§æ‹¦æˆªï¼Œä¸å½±å“ç³»ç»Ÿè¾“å…¥

### Q3: ç¨‹åºå¯åŠ¨ä½†çƒ­é”®æ— æ•ˆ
```bash
# é”™è¯¯ç°è±¡
- F8/F7/F9æŒ‰é”®æ— å“åº”
- æ—¥å¿—æ˜¾ç¤º"çƒ­é”®æ³¨å†Œå¤±è´¥"
- å…¶ä»–ç¨‹åºçƒ­é”®æ­£å¸¸
```

**è¯Šæ–­æ­¥éª¤**:
```python
# æ£€æŸ¥ç®¡ç†å‘˜æƒé™
import ctypes
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

print(f"ç®¡ç†å‘˜æƒé™: {is_admin()}")
```

**è§£å†³æ–¹æ¡ˆ**:
```bash
# 1. ä»¥ç®¡ç†å‘˜æƒé™è¿è¡Œ
å³é”®Pythonå›¾æ ‡ -> ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ
# æˆ–å³é”®å¿«æ·æ–¹å¼ -> å±æ€§ -> é«˜çº§ -> ä»¥ç®¡ç†å‘˜èº«ä»½è¿è¡Œ

# 2. æ£€æŸ¥çƒ­é”®å†²çª
# å…³é—­å¯èƒ½å†²çªçš„è½¯ä»¶ï¼šå½•å±è½¯ä»¶ã€æ¸¸æˆè¾…åŠ©å·¥å…·ã€ç³»ç»Ÿä¼˜åŒ–è½¯ä»¶

# 3. é‡ç½®çƒ­é”®æ³¨å†Œ
# åœ¨ä»£ç ä¸­æ·»åŠ è°ƒè¯•ä¿¡æ¯
LOG_INFO(f"æ³¨å†Œçƒ­é”® F8: {success}")
```

### Q3: GUIç•Œé¢å¡ä½æˆ–æ— å“åº”
```python
# é”™è¯¯ç°è±¡
- ç•Œé¢æ— æ³•ç‚¹å‡»
- ç¨‹åºå‡æ­»çŠ¶æ€
- ä»»åŠ¡ç®¡ç†å™¨æ˜¾ç¤º"æ— å“åº”"
```

**è¯Šæ–­å·¥å…·**:
```python
# çº¿ç¨‹ç›‘æ§è„šæœ¬
import threading
import time

def monitor_threads():
    """ç›‘æ§æ´»è·ƒçº¿ç¨‹"""
    while True:
        threads = threading.enumerate()
        print(f"æ´»è·ƒçº¿ç¨‹æ•°: {len(threads)}")
        for t in threads:
            print(f"  {t.name}: {t.is_alive()}")
        time.sleep(5)

# åœ¨ä¸»ç¨‹åºä¸­å¯åŠ¨ç›‘æ§
threading.Thread(target=monitor_threads, daemon=True).start()
```

**è§£å†³æ–¹æ¡ˆ**:
```python
# 1. é¿å…ä¸»çº¿ç¨‹é˜»å¡
def long_running_task():
    # é”™è¯¯ï¼šåœ¨ä¸»çº¿ç¨‹æ‰§è¡Œé•¿æ—¶é—´æ“ä½œ
    time.sleep(10)  # ä¼šå¯¼è‡´ç•Œé¢å¡æ­»

def correct_approach():
    # æ­£ç¡®ï¼šä½¿ç”¨çº¿ç¨‹æ± 
    from concurrent.futures import ThreadPoolExecutor
    with ThreadPoolExecutor() as executor:
        future = executor.submit(long_running_task)

# 2. ä½¿ç”¨QTimeræ›¿ä»£time.sleep
from PySide6.QtCore import QTimer

timer = QTimer()
timer.timeout.connect(periodic_task)
timer.start(1000)  # æ¯ç§’æ‰§è¡Œä¸€æ¬¡
```

---

## ğŸ“¸ å±å¹•æ•è·é—®é¢˜

### Q4: é›¶æ‹·è´æ•è·å¤±è´¥
```bash
# é”™è¯¯ä¿¡æ¯
DLL load failed: æ‰¾ä¸åˆ°æŒ‡å®šçš„æ¨¡å—
capture_lib.dllæ— æ³•åŠ è½½
DXGIåˆå§‹åŒ–å¤±è´¥
```

**è¯Šæ–­æ­¥éª¤**:
```python
# 1. æ£€æŸ¥DLLæ–‡ä»¶
import os
dll_path = "native_capture/capture_lib.dll"
print(f"DLLå­˜åœ¨: {os.path.exists(dll_path)}")
print(f"DLLå¤§å°: {os.path.getsize(dll_path) if os.path.exists(dll_path) else 'N/A'}")

# 2. æ£€æŸ¥ä¾èµ–åº“
import ctypes
try:
    dll = ctypes.CDLL(dll_path)
    print("DLLåŠ è½½æˆåŠŸ")
except Exception as e:
    print(f"DLLåŠ è½½å¤±è´¥: {e}")

# 3. æ£€æŸ¥DXGIæ”¯æŒ
import subprocess
result = subprocess.run(['dxdiag', '/t', 'dxdiag.txt'], capture_output=True)
print("DXGIè¯Šæ–­ä¿¡æ¯å·²ä¿å­˜åˆ°dxdiag.txt")
```

**è§£å†³æ–¹æ¡ˆ**:
```bash
# 1. é‡æ–°ç¼–è¯‘DLL
cd native_capture
rmdir /s build
build.bat

# 2. å®‰è£…Visual C++ Redistributable
# ä¸‹è½½å®‰è£…: Microsoft Visual C++ 2019-2022 Redistributable (x64)

# 3. æ£€æŸ¥æ˜¾å¡é©±åŠ¨
# æ›´æ–°åˆ°æœ€æ–°ç‰ˆæœ¬çš„æ˜¾å¡é©±åŠ¨

# 4. é™çº§åˆ°MSSå¤‡ç”¨æ–¹æ¡ˆ
# åœ¨ä»£ç ä¸­å¯ç”¨MSSå¤‡ç”¨æ•è·
USE_NATIVE_CAPTURE = False
```

### Q5: å›¾åƒæ£€æµ‹ä¸å‡†ç¡®
```python
# é”™è¯¯ç°è±¡
- æŠ€èƒ½å†·å´æ£€æµ‹é”™è¯¯
- HP/MPç™¾åˆ†æ¯”å¼‚å¸¸
- åæ ‡åç§»é—®é¢˜
```

**è¯Šæ–­å·¥å…·**:
```python
# å›¾åƒè°ƒè¯•å·¥å…·
def debug_image_detection(frame, coords, name):
    """è°ƒè¯•å›¾åƒæ£€æµ‹"""
    import cv2
    x, y, w, h = coords
    roi = frame[y:y+h, x:x+w]
    
    # ä¿å­˜è°ƒè¯•å›¾åƒ
    cv2.imwrite(f"debug_{name}_{int(time.time())}.png", roi)
    
    # æ˜¾ç¤ºé¢œè‰²ä¿¡æ¯
    if roi.size > 0:
        mean_color = np.mean(roi, axis=(0,1))
        print(f"{name} å¹³å‡é¢œè‰² (BGR): {mean_color}")
        
        # HSVè½¬æ¢
        hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        mean_hsv = np.mean(hsv_roi, axis=(0,1))
        print(f"{name} å¹³å‡é¢œè‰² (HSV): {mean_hsv}")

# ä½¿ç”¨ç¤ºä¾‹
frame = border_manager.get_current_frame()
debug_image_detection(frame, [100, 50, 20, 20], "skill_cooldown")
```

**è§£å†³æ–¹æ¡ˆ**:
```json
// 1. è°ƒæ•´æ£€æµ‹åæ ‡
{
  "skills": [
    {
      "name": "æŠ€èƒ½1",
      "cooldown_coords": [100, 50, 20, 20],  // åŸåæ ‡
      "cooldown_coords_debug": [95, 45, 30, 30]  // æ‰©å¤§æ£€æµ‹åŒºåŸŸ
    }
  ]
}
```

```python
# 2. ä¼˜åŒ–æ£€æµ‹ç®—æ³•
def improved_similarity_check(frame, coords, target_color, tolerance=30):
    """æ”¹è¿›çš„ç›¸ä¼¼åº¦æ£€æµ‹"""
    x, y, w, h = coords
    roi = frame[y:y+h, x:x+w]
    
    if roi.size == 0:
        return False
    
    # ä½¿ç”¨ä¸­å¿ƒåŒºåŸŸæ£€æµ‹ï¼Œé¿å…è¾¹ç¼˜å™ªå£°
    center_h, center_w = h//3, w//3
    start_h, start_w = h//3, w//3
    center_roi = roi[start_h:start_h+center_h, start_w:start_w+center_w]
    
    mean_color = np.mean(center_roi, axis=(0,1))
    diff = np.abs(mean_color - target_color)
    
    return np.all(diff < tolerance)
```

---

## âš™ï¸ é…ç½®ä¸åŠŸèƒ½é—®é¢˜

### Q6: æŠ€èƒ½ä¸è§¦å‘æˆ–è§¦å‘å¼‚å¸¸
```json
// é—®é¢˜é…ç½®ç¤ºä¾‹
{
  "name": "æŠ€èƒ½1",
  "key": "1",
  "trigger_mode": 1,
  "cooldown_coords": [],  // ç©ºåæ ‡
  "enabled": true
}
```

**è¯Šæ–­æ¸…å•**:
```python
def diagnose_skill_config(skill_config):
    """è¯Šæ–­æŠ€èƒ½é…ç½®"""
    issues = []
    
    # 1. åŸºç¡€å­—æ®µæ£€æŸ¥
    required_fields = ["name", "key", "trigger_mode", "enabled"]
    for field in required_fields:
        if field not in skill_config:
            issues.append(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field}")
    
    # 2. è§¦å‘æ¨¡å¼ç‰¹å®šæ£€æŸ¥
    if skill_config.get("trigger_mode") == 1:  # å†·å´æ¨¡å¼
        if not skill_config.get("cooldown_coords"):
            issues.append("å†·å´æ¨¡å¼éœ€è¦é…ç½®cooldown_coords")
    
    # 3. åæ ‡æœ‰æ•ˆæ€§æ£€æŸ¥
    coords = skill_config.get("cooldown_coords")
    if coords and len(coords) != 4:
        issues.append("åæ ‡æ ¼å¼é”™è¯¯ï¼Œéœ€è¦[x, y, width, height]")
    
    # 4. æŒ‰é”®åºåˆ—æœ‰æ•ˆæ€§æ£€æŸ¥
    key = skill_config.get("key")
    if not key or len(key) == 0:
        issues.append("æŒ‰é”®é…ç½®ä¸ºç©º")
    else:
        # éªŒè¯åºåˆ—æ ¼å¼
        if ',' in key:
            for key_part in key.split(','):
                key_part = key_part.strip()
                if key_part.startswith('delay'):
                    try:
                        delay_ms = int(key_part[5:])
                        if delay_ms < 0 or delay_ms > 10000:
                            issues.append(f"å»¶è¿Ÿæ—¶é—´è¶…å‡ºèŒƒå›´: {key_part}")
                    except ValueError:
                        issues.append(f"å»¶è¿Ÿæ ¼å¼é”™è¯¯: {key_part}")
    
    # 5. è¾…åŠ©æŒ‰é”®åºåˆ—æ£€æŸ¥
    alt_key = skill_config.get("alt_key")
    if alt_key and ',' in alt_key:
        for key_part in alt_key.split(','):
            key_part = key_part.strip()
            if key_part.startswith('delay'):
                try:
                    delay_ms = int(key_part[5:])
                    if delay_ms < 0 or delay_ms > 10000:
                        issues.append(f"è¾…åŠ©æŒ‰é”®å»¶è¿Ÿæ—¶é—´è¶…å‡ºèŒƒå›´: {key_part}")
                except ValueError:
                    issues.append(f"è¾…åŠ©æŒ‰é”®å»¶è¿Ÿæ ¼å¼é”™è¯¯: {key_part}")
    
    return issues

# ä½¿ç”¨è¯Šæ–­å·¥å…·
for skill in config["skills"]:
    issues = diagnose_skill_config(skill)
    if issues:
        print(f"æŠ€èƒ½ {skill.get('name', 'Unknown')} é…ç½®é—®é¢˜:")
        for issue in issues:
            print(f"  - {issue}")
```

**è§£å†³æ–¹æ¡ˆ**:
```json
// æ­£ç¡®çš„æŠ€èƒ½é…ç½®ï¼ˆåŸºç¡€ç‰ˆï¼‰
{
  "name": "ä¸»è¦æŠ€èƒ½",
  "key": "1",
  "trigger_mode": 1,
  "cooldown_coords": [100, 50, 20, 20],
  "priority": false,
  "enabled": true,
  "execute_condition": 0
}

// æ­£ç¡®çš„æŠ€èƒ½é…ç½®ï¼ˆåºåˆ—ç‰ˆï¼‰
{
  "name": "ç«çƒè¿å‡»",
  "key": "delay50,q",
  "alt_key": "delay100,shift+q",
  "trigger_mode": 0,
  "interval": 2000,
  "priority": false,
  "enabled": true
}
```

### Q6.5: æŒ‰é”®åºåˆ—ä¸ç”Ÿæ•ˆ

**ç—‡çŠ¶**: é…ç½®äº† `delay50,q` ç­‰åºåˆ—ä½†åªæ‰§è¡Œç¬¬ä¸€ä¸ªå…ƒç´ 

**æ’æŸ¥æ­¥éª¤**:
1. **æ£€æŸ¥åºåˆ—æ ¼å¼**
   ```python
   # é”™è¯¯ç¤ºä¾‹
   "key": "delay 50,q"      # ç©ºæ ¼é”™è¯¯
   "key": "delay50, q"      # å¤šä½™ç©ºæ ¼ï¼ˆä¼šè¢«trimæ‰ï¼Œä½†ä¸æ¨èï¼‰
   "key": "delay50;q"       # åˆ†éš”ç¬¦é”™è¯¯
   "key": "delay=50,q"      # ç­‰å·é”™è¯¯ï¼ˆæ­£ç¡®æ ¼å¼æ— ç­‰å·ï¼‰
   
   # æ­£ç¡®ç¤ºä¾‹
   "key": "delay50,q"       # æ ‡å‡†æ ¼å¼
   "key": "q,delay100,w"    # å¤šå…ƒç´ åºåˆ—
   ```

2. **éªŒè¯å»¶è¿Ÿæ—¶é—´èŒƒå›´**
   ```python
   # æœ‰æ•ˆèŒƒå›´ï¼š0-10000ms
   "delay50"    # âœ“ æœ‰æ•ˆ
   "delay-10"   # âœ— è´Ÿæ•°æ— æ•ˆ
   "delay15000" # âœ— è¶…å‡ºèŒƒå›´
   ```

3. **æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€**
   ```python
   # æŸ¥çœ‹è¾“å…¥å¤„ç†å™¨æ—¥å¿—
   LOG_INFO(f"[é˜Ÿåˆ—å¤„ç†å™¨] å¤„ç†æŒ‰é”®åºåˆ—: {key_sequence}")
   LOG_INFO(f"[é˜Ÿåˆ—çŠ¶æ€] å½“å‰é˜Ÿåˆ—é•¿åº¦: {queue_length}")
   ```

**å¸¸è§è§£å†³æ–¹æ¡ˆ**:
- ç¡®ä¿åºåˆ—æ ¼å¼æ­£ç¡®ï¼ˆé€—å·åˆ†éš”ï¼Œæ— å¤šä½™ç©ºæ ¼ï¼‰
- éªŒè¯å»¶è¿Ÿæ—¶é—´åœ¨æœ‰æ•ˆèŒƒå›´å†…
- æ£€æŸ¥ä¼˜å…ˆçº§æŒ‰é”®æ˜¯å¦é˜»æ­¢äº†åºåˆ—æ‰§è¡Œ
- æŸ¥çœ‹é˜Ÿåˆ—æ˜¯å¦å·²æ»¡å¯¼è‡´åºåˆ—è¢«ä¸¢å¼ƒ

### Q7: è¯å‰‚æ£€æµ‹ä¸è§¦å‘
```python
# å¸¸è§é—®é¢˜
- HSVé¢œè‰²é…ç½®ä¸å‡†ç¡®
- æ£€æµ‹åŒºåŸŸè®¾ç½®é”™è¯¯  
- å†…éƒ¨å†·å´æ—¶é—´è¿‡é•¿
- é˜ˆå€¼è®¾ç½®ä¸åˆç†
```

**HSVé¢œè‰²è°ƒè¯•å·¥å…·**:
```python
def hsv_color_picker(image_path, x, y):
    """HSVé¢œè‰²æ‹¾å–å·¥å…·"""
    import cv2
    
    image = cv2.imread(image_path)
    bgr_color = image[y, x]
    
    # è½¬æ¢ä¸ºHSV
    bgr_pixel = np.uint8([[bgr_color]])
    hsv_pixel = cv2.cvtColor(bgr_pixel, cv2.COLOR_BGR2HSV)
    hsv_color = hsv_pixel[0][0]
    
    print(f"åæ ‡ ({x}, {y}):")
    print(f"BGR: {bgr_color}")
    print(f"HSV: {hsv_color}")
    
    # å»ºè®®çš„HSVèŒƒå›´
    h, s, v = hsv_color
    hsv_range = [
        [max(0, h-10), max(0, s-30), max(0, v-30)],
        [min(179, h+10), min(255, s+30), min(255, v+30)]
    ]
    print(f"å»ºè®®HSVèŒƒå›´: {hsv_range}")
    
    return hsv_range

# ä½¿ç”¨æ–¹æ³•
# 1. å…ˆæˆªå›¾ä¿å­˜å½“å‰è¡€æ¡çŠ¶æ€
# 2. ä½¿ç”¨å·¥å…·è·å–HSVå€¼
hsv_range = hsv_color_picker("debug_hp.png", 150, 950)
```

**è¯å‰‚é…ç½®ä¼˜åŒ–**:
```json
{
  "hp_potion": {
    "enabled": true,
    "key": "1",
    "threshold": 70,          // 70%æ—¶è§¦å‘
    "region": [136, 910, 213, 1004],  // HPæ¡åŒºåŸŸ
    "hsv_range": [
      [304, 55, 19],         // HSVä¸‹é™
      [334, 95, 49]          // HSVä¸Šé™
    ],
    "tolerance": [15, 25, 25],  // å¢åŠ å®¹å·®
    "cooldown": 3000,       // å‡å°‘å†·å´æ—¶é—´
    "debug_mode": true      // å¯ç”¨è°ƒè¯•æ¨¡å¼
  }
}
```

### Q8: æ´—ç»ƒåŠŸèƒ½æ— æ³•è¯†åˆ«è¯ç¼€
```python
# OCRç›¸å…³é—®é¢˜
- PaddleOCRåˆå§‹åŒ–å¤±è´¥
- è¯†åˆ«åŒºåŸŸè®¾ç½®é”™è¯¯
- æ–‡å­—æ¸…æ™°åº¦ä¸å¤Ÿ
- è¯ç¼€åŒ¹é…è§„åˆ™é—®é¢˜
```

**OCRè¯Šæ–­å·¥å…·**:
```python
def diagnose_ocr():
    """è¯Šæ–­OCRåŠŸèƒ½"""
    try:
        from paddleocr import PaddleOCR
        
        # æµ‹è¯•OCRåˆå§‹åŒ–
        ocr = PaddleOCR(use_angle_cls=True, lang='ch', show_log=False)
        print("âœ“ PaddleOCRåˆå§‹åŒ–æˆåŠŸ")
        
        # æµ‹è¯•ç®€å•è¯†åˆ«
        test_image = "test_text.png"  # éœ€è¦å‡†å¤‡æµ‹è¯•å›¾ç‰‡
        if os.path.exists(test_image):
            result = ocr.ocr(test_image, cls=True)
            print(f"âœ“ OCRè¯†åˆ«æµ‹è¯•: {result}")
        else:
            print("âš  ç¼ºå°‘æµ‹è¯•å›¾ç‰‡")
            
    except ImportError as e:
        print(f"âœ— PaddleOCRå¯¼å…¥å¤±è´¥: {e}")
    except Exception as e:
        print(f"âœ— OCRåˆå§‹åŒ–å¤±è´¥: {e}")

# å›¾åƒé¢„å¤„ç†æ”¹è¿›
def preprocess_for_ocr(image):
    """OCRå‰å›¾åƒé¢„å¤„ç†"""
    import cv2
    
    # è½¬æ¢ä¸ºç°åº¦å›¾
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image
    
    # å¢å¼ºå¯¹æ¯”åº¦
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    enhanced = clahe.apply(gray)
    
    # å»å™ª
    denoised = cv2.medianBlur(enhanced, 3)
    
    # é”åŒ–
    kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
    sharpened = cv2.filter2D(denoised, -1, kernel)
    
    return sharpened
```

---

## ğŸš€ æ€§èƒ½é—®é¢˜

### Q9: CPUå ç”¨è¿‡é«˜
```python
# å¸¸è§åŸå› 
- æ•è·é¢‘ç‡è¿‡é«˜
- æ£€æµ‹ä»»åŠ¡è¿‡å¤š
- æ—¥å¿—è¾“å‡ºè¿‡é¢‘ç¹
- å†…å­˜æ³„æ¼
```

**æ€§èƒ½åˆ†æå·¥å…·**:
```python
import psutil
import time
from functools import wraps

def performance_monitor(func):
    """æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        # CPUå’Œå†…å­˜ç›‘æ§
        process = psutil.Process()
        cpu_before = process.cpu_percent()
        memory_before = process.memory_info().rss / 1024 / 1024
        
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        cpu_after = process.cpu_percent()
        memory_after = process.memory_info().rss / 1024 / 1024
        
        execution_time = (end_time - start_time) * 1000
        
        if execution_time > 100:  # è¶…è¿‡100msçš„å‡½æ•°è®°å½•
            print(f"æ€§èƒ½è­¦å‘Š {func.__name__}:")
            print(f"  æ‰§è¡Œæ—¶é—´: {execution_time:.2f}ms")
            print(f"  CPUå˜åŒ–: {cpu_before:.1f}% -> {cpu_after:.1f}%")
            print(f"  å†…å­˜å˜åŒ–: {memory_before:.1f}MB -> {memory_after:.1f}MB")
        
        return result
    return wrapper

# ä½¿ç”¨ç¤ºä¾‹
@performance_monitor
def expensive_detection_function():
    # è€—æ—¶çš„æ£€æµ‹æ“ä½œ
    pass
```

**æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ**:
```python
# 1. è°ƒæ•´æ•è·é¢‘ç‡
CAPTURE_INTERVAL = 150  # ä»100msè°ƒæ•´åˆ°150ms

# 2. å‡å°‘å¹¶å‘æ£€æµ‹ä»»åŠ¡
MAX_CONCURRENT_DETECTIONS = 2  # é™åˆ¶å¹¶å‘æ•°

# 3. ä¼˜åŒ–æ—¥å¿—è¾“å‡º
import logging
logging.getLogger('paddleocr').setLevel(logging.WARNING)  # å‡å°‘OCRæ—¥å¿—

# 4. å†…å­˜å®šæœŸæ¸…ç†
import gc
def periodic_cleanup():
    gc.collect()  # å¼ºåˆ¶åƒåœ¾å›æ”¶
    
# æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡æ¸…ç†
scheduler.add_task("memory_cleanup", 60000, periodic_cleanup)
```

### Q10: å†…å­˜æ³„æ¼é—®é¢˜
```python
# å†…å­˜æ³„æ¼æ£€æµ‹
import tracemalloc

def start_memory_trace():
    """å¯åŠ¨å†…å­˜è¿½è¸ª"""
    tracemalloc.start()

def check_memory_growth():
    """æ£€æŸ¥å†…å­˜å¢é•¿"""
    current, peak = tracemalloc.get_traced_memory()
    print(f"å½“å‰å†…å­˜ä½¿ç”¨: {current / 1024 / 1024:.1f}MB")
    print(f"å³°å€¼å†…å­˜ä½¿ç”¨: {peak / 1024 / 1024:.1f}MB")
    
    # è·å–å†…å­˜å¢é•¿æœ€å¿«çš„éƒ¨åˆ†
    snapshot = tracemalloc.take_snapshot()
    top_stats = snapshot.statistics('lineno')
    
    print("å†…å­˜ä½¿ç”¨TOP10:")
    for stat in top_stats[:10]:
        print(f"  {stat}")

# å¸¸è§å†…å­˜æ³„æ¼æº
def fix_memory_leaks():
    """ä¿®å¤å¸¸è§å†…å­˜æ³„æ¼"""
    
    # 1. åŠæ—¶å…³é—­å›¾åƒå¯¹è±¡
    def process_image(image_path):
        from PIL import Image
        with Image.open(image_path) as img:
            # å¤„ç†å›¾åƒ
            result = img.copy()
        return result  # imgè‡ªåŠ¨å…³é—­
    
    # 2. æ¸…ç†numpyæ•°ç»„
    def clear_numpy_cache():
        import numpy as np
        # å¼ºåˆ¶æ¸…ç†numpyç¼“å­˜
        if hasattr(np, 'core') and hasattr(np.core, '_multiarray_umath'):
            np.core._multiarray_umath._reload_guard = False
    
    # 3. å®šæœŸæ¸…ç†ç¼“å­˜
    def clear_all_caches():
        border_manager.clear_cache()
        resource_manager.clear_cache() 
        gc.collect()
```

---

## ğŸ“‹ é—®é¢˜æŠ¥å‘Šæ¨¡æ¿

### æ ‡å‡†é—®é¢˜æŠ¥å‘Šæ ¼å¼
```
## é—®é¢˜æè¿°
ç®€è¦æè¿°é‡åˆ°çš„é—®é¢˜

## ç¯å¢ƒä¿¡æ¯
- æ“ä½œç³»ç»Ÿ: Windows 10/11 ç‰ˆæœ¬å·
- Pythonç‰ˆæœ¬: python --version
- pyahkç‰ˆæœ¬: git commit hash
- æ˜¾å¡å‹å·: 
- å±å¹•åˆ†è¾¨ç‡:

## å¤ç°æ­¥éª¤
1. ç¬¬ä¸€æ­¥
2. ç¬¬äºŒæ­¥  
3. ç¬¬ä¸‰æ­¥

## é¢„æœŸè¡Œä¸º
æè¿°é¢„æœŸåº”è¯¥å‘ç”Ÿä»€ä¹ˆ

## å®é™…è¡Œä¸º
æè¿°å®é™…å‘ç”Ÿäº†ä»€ä¹ˆ

## é”™è¯¯æ—¥å¿—
```
ç²˜è´´ç›¸å…³çš„é”™è¯¯æ—¥å¿—å’Œå †æ ˆè·Ÿè¸ª
```

## é…ç½®æ–‡ä»¶
```json
ç²˜è´´ç›¸å…³çš„é…ç½®æ–‡ä»¶å†…å®¹
```

## é™„åŠ ä¿¡æ¯
- æ˜¯å¦ä»¥ç®¡ç†å‘˜æƒé™è¿è¡Œ
- æ˜¯å¦æœ‰æ€æ¯’è½¯ä»¶/é˜²ç«å¢™é˜»æ‹¦
- å…¶ä»–å¯èƒ½ç›¸å…³çš„ä¿¡æ¯
```

### æ—¥å¿—æ”¶é›†è„šæœ¬
```python
# collect_debug_info.py
import sys
import os
import platform
import subprocess
import json

def collect_debug_info():
    """æ”¶é›†è°ƒè¯•ä¿¡æ¯"""
    info = {
        "system": {
            "platform": platform.platform(),
            "python_version": sys.version,
            "architecture": platform.architecture(),
        },
        "pyahk": {
            "version": get_pyahk_version(),
            "config_files": list_config_files(),
        },
        "dependencies": get_dependency_versions(),
        "logs": get_recent_logs(),
    }
    
    # ä¿å­˜åˆ°æ–‡ä»¶
    with open("debug_info.json", "w", encoding="utf-8") as f:
        json.dump(info, f, ensure_ascii=False, indent=2)
    
    print("è°ƒè¯•ä¿¡æ¯å·²ä¿å­˜åˆ° debug_info.json")
    return info

if __name__ == "__main__":
    collect_debug_info()
```

é€šè¿‡è¿™å¥—å®Œæ•´çš„æ•…éšœæ’æŸ¥ä½“ç³»ï¼Œç”¨æˆ·å¯ä»¥å¿«é€Ÿå®šä½å¹¶è§£å†³pyahkä½¿ç”¨è¿‡ç¨‹ä¸­é‡åˆ°çš„å„ç§é—®é¢˜ï¼Œæé«˜ä½¿ç”¨ä½“éªŒå’Œç³»ç»Ÿç¨³å®šæ€§ã€‚