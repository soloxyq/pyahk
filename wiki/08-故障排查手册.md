# 08 故障排查手册

## 概述

本章提供pyahk常见问题的诊断和解决方案，涵盖安装、运行、配置、性能等各个方面的故障排查方法，帮助用户快速定位并解决问题。

---

## 🚨 快速诊断

### 问题分类检查清单

#### 基础运行问题
- [ ] Python版本是否符合要求 (3.7+)
- [ ] 是否以管理员权限运行
- [ ] 防火墙是否阻止程序
- [ ] 杀毒软件是否误报

#### 依赖问题
- [ ] requirements.txt是否完整安装
- [ ] PaddleOCR是否正确初始化
- [ ] C++运行库是否安装
- [ ] native_capture.dll是否编译成功

#### 配置问题
- [ ] JSON配置文件语法是否正确
- [ ] 坐标配置是否适合当前分辨率
- [ ] 权限设置是否正确
- [ ] 热键是否被其他程序占用

---

## 🔧 安装与启动问题

### Q1: 程序无法启动，提示模块缺失
```bash
# 错误示例
ImportError: No module named 'PySide6'
ModuleNotFoundError: No module named 'cv2'
```

**诊断步骤**:
```bash
# 1. 检查Python环境
python --version
pip --version

# 2. 检查已安装包
pip list | grep -i pyside6
pip list | grep -i opencv

# 3. 重新安装依赖
pip install -r requirements.txt --force-reinstall
```

**解决方案**:
```bash
# 方案1: 清理重装
pip uninstall PySide6 opencv-python
pip install PySide6>=6.5.0 opencv-python>=4.5.0

# 方案2: 使用国内镜像
pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple

# 方案3: 虚拟环境重建
python -m venv fresh_env
fresh_env\Scripts\activate
pip install -r requirements.txt
```

### Q2: 程序启动但热键无效
```bash
# 错误现象
- F8/F7/F9按键无响应
- 日志显示"热键注册失败"
- 其他程序热键正常
```

**诊断步骤**:
```python
# 检查管理员权限
import ctypes
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

print(f"管理员权限: {is_admin()}")
```

**解决方案**:
```bash
# 1. 以管理员权限运行
右键Python图标 -> 以管理员身份运行
# 或右键快捷方式 -> 属性 -> 高级 -> 以管理员身份运行

# 2. 检查热键冲突
# 关闭可能冲突的软件：录屏软件、游戏辅助工具、系统优化软件

# 3. 重置热键注册
# 在代码中添加调试信息
LOG_INFO(f"注册热键 F8: {success}")
```

### Q3: GUI界面卡住或无响应
```python
# 错误现象
- 界面无法点击
- 程序假死状态
- 任务管理器显示"无响应"
```

**诊断工具**:
```python
# 线程监控脚本
import threading
import time

def monitor_threads():
    """监控活跃线程"""
    while True:
        threads = threading.enumerate()
        print(f"活跃线程数: {len(threads)}")
        for t in threads:
            print(f"  {t.name}: {t.is_alive()}")
        time.sleep(5)

# 在主程序中启动监控
threading.Thread(target=monitor_threads, daemon=True).start()
```

**解决方案**:
```python
# 1. 避免主线程阻塞
def long_running_task():
    # 错误：在主线程执行长时间操作
    time.sleep(10)  # 会导致界面卡死

def correct_approach():
    # 正确：使用线程池
    from concurrent.futures import ThreadPoolExecutor
    with ThreadPoolExecutor() as executor:
        future = executor.submit(long_running_task)

# 2. 使用QTimer替代time.sleep
from PySide6.QtCore import QTimer

timer = QTimer()
timer.timeout.connect(periodic_task)
timer.start(1000)  # 每秒执行一次
```

---

## 📸 屏幕捕获问题

### Q4: 零拷贝捕获失败
```bash
# 错误信息
DLL load failed: 找不到指定的模块
capture_lib.dll无法加载
DXGI初始化失败
```

**诊断步骤**:
```python
# 1. 检查DLL文件
import os
dll_path = "native_capture/capture_lib.dll"
print(f"DLL存在: {os.path.exists(dll_path)}")
print(f"DLL大小: {os.path.getsize(dll_path) if os.path.exists(dll_path) else 'N/A'}")

# 2. 检查依赖库
import ctypes
try:
    dll = ctypes.CDLL(dll_path)
    print("DLL加载成功")
except Exception as e:
    print(f"DLL加载失败: {e}")

# 3. 检查DXGI支持
import subprocess
result = subprocess.run(['dxdiag', '/t', 'dxdiag.txt'], capture_output=True)
print("DXGI诊断信息已保存到dxdiag.txt")
```

**解决方案**:
```bash
# 1. 重新编译DLL
cd native_capture
rmdir /s build
build.bat

# 2. 安装Visual C++ Redistributable
# 下载安装: Microsoft Visual C++ 2019-2022 Redistributable (x64)

# 3. 检查显卡驱动
# 更新到最新版本的显卡驱动

# 4. 降级到MSS备用方案
# 在代码中启用MSS备用捕获
USE_NATIVE_CAPTURE = False
```

### Q5: 图像检测不准确
```python
# 错误现象
- 技能冷却检测错误
- HP/MP百分比异常
- 坐标偏移问题
```

**诊断工具**:
```python
# 图像调试工具
def debug_image_detection(frame, coords, name):
    """调试图像检测"""
    import cv2
    x, y, w, h = coords
    roi = frame[y:y+h, x:x+w]
    
    # 保存调试图像
    cv2.imwrite(f"debug_{name}_{int(time.time())}.png", roi)
    
    # 显示颜色信息
    if roi.size > 0:
        mean_color = np.mean(roi, axis=(0,1))
        print(f"{name} 平均颜色 (BGR): {mean_color}")
        
        # HSV转换
        hsv_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
        mean_hsv = np.mean(hsv_roi, axis=(0,1))
        print(f"{name} 平均颜色 (HSV): {mean_hsv}")

# 使用示例
frame = border_manager.get_current_frame()
debug_image_detection(frame, [100, 50, 20, 20], "skill_cooldown")
```

**解决方案**:
```json
// 1. 调整检测坐标
{
  "skills": [
    {
      "name": "技能1",
      "cooldown_coords": [100, 50, 20, 20],  // 原坐标
      "cooldown_coords_debug": [95, 45, 30, 30]  // 扩大检测区域
    }
  ]
}
```

```python
# 2. 优化检测算法
def improved_similarity_check(frame, coords, target_color, tolerance=30):
    """改进的相似度检测"""
    x, y, w, h = coords
    roi = frame[y:y+h, x:x+w]
    
    if roi.size == 0:
        return False
    
    # 使用中心区域检测，避免边缘噪声
    center_h, center_w = h//3, w//3
    start_h, start_w = h//3, w//3
    center_roi = roi[start_h:start_h+center_h, start_w:start_w+center_w]
    
    mean_color = np.mean(center_roi, axis=(0,1))
    diff = np.abs(mean_color - target_color)
    
    return np.all(diff < tolerance)
```

---

## ⚙️ 配置与功能问题

### Q6: 技能不触发或触发异常
```json
// 问题配置示例
{
  "name": "技能1",
  "key": "1",
  "trigger_mode": 1,
  "cooldown_coords": [],  // 空坐标
  "enabled": true
}
```

**诊断清单**:
```python
def diagnose_skill_config(skill_config):
    """诊断技能配置"""
    issues = []
    
    # 1. 基础字段检查
    required_fields = ["name", "key", "trigger_mode", "enabled"]
    for field in required_fields:
        if field not in skill_config:
            issues.append(f"缺少必需字段: {field}")
    
    # 2. 触发模式特定检查
    if skill_config.get("trigger_mode") == 1:  # 冷却模式
        if not skill_config.get("cooldown_coords"):
            issues.append("冷却模式需要配置cooldown_coords")
    
    # 3. 坐标有效性检查
    coords = skill_config.get("cooldown_coords")
    if coords and len(coords) != 4:
        issues.append("坐标格式错误，需要[x, y, width, height]")
    
    # 4. 按键有效性检查
    key = skill_config.get("key")
    if not key or len(key) == 0:
        issues.append("按键配置为空")
    
    return issues

# 使用诊断工具
for skill in config["skills"]:
    issues = diagnose_skill_config(skill)
    if issues:
        print(f"技能 {skill.get('name', 'Unknown')} 配置问题:")
        for issue in issues:
            print(f"  - {issue}")
```

**解决方案**:
```json
// 正确的技能配置
{
  "name": "主要技能",
  "key": "1",
  "trigger_mode": 1,
  "cooldown_coords": [100, 50, 20, 20],
  "priority": false,
  "enabled": true,
  "execute_condition": 0
}
```

### Q7: 药剂检测不触发
```python
# 常见问题
- HSV颜色配置不准确
- 检测区域设置错误  
- 内部冷却时间过长
- 阈值设置不合理
```

**HSV颜色调试工具**:
```python
def hsv_color_picker(image_path, x, y):
    """HSV颜色拾取工具"""
    import cv2
    
    image = cv2.imread(image_path)
    bgr_color = image[y, x]
    
    # 转换为HSV
    bgr_pixel = np.uint8([[bgr_color]])
    hsv_pixel = cv2.cvtColor(bgr_pixel, cv2.COLOR_BGR2HSV)
    hsv_color = hsv_pixel[0][0]
    
    print(f"坐标 ({x}, {y}):")
    print(f"BGR: {bgr_color}")
    print(f"HSV: {hsv_color}")
    
    # 建议的HSV范围
    h, s, v = hsv_color
    hsv_range = [
        [max(0, h-10), max(0, s-30), max(0, v-30)],
        [min(179, h+10), min(255, s+30), min(255, v+30)]
    ]
    print(f"建议HSV范围: {hsv_range}")
    
    return hsv_range

# 使用方法
# 1. 先截图保存当前血条状态
# 2. 使用工具获取HSV值
hsv_range = hsv_color_picker("debug_hp.png", 150, 950)
```

**药剂配置优化**:
```json
{
  "hp_potion": {
    "enabled": true,
    "key": "1",
    "threshold": 70,          // 70%时触发
    "region": [136, 910, 213, 1004],  // HP条区域
    "hsv_range": [
      [304, 55, 19],         // HSV下限
      [334, 95, 49]          // HSV上限
    ],
    "tolerance": [15, 25, 25],  // 增加容差
    "cooldown": 3000,       // 减少冷却时间
    "debug_mode": true      // 启用调试模式
  }
}
```

### Q8: 洗练功能无法识别词缀
```python
# OCR相关问题
- PaddleOCR初始化失败
- 识别区域设置错误
- 文字清晰度不够
- 词缀匹配规则问题
```

**OCR诊断工具**:
```python
def diagnose_ocr():
    """诊断OCR功能"""
    try:
        from paddleocr import PaddleOCR
        
        # 测试OCR初始化
        ocr = PaddleOCR(use_angle_cls=True, lang='ch', show_log=False)
        print("✓ PaddleOCR初始化成功")
        
        # 测试简单识别
        test_image = "test_text.png"  # 需要准备测试图片
        if os.path.exists(test_image):
            result = ocr.ocr(test_image, cls=True)
            print(f"✓ OCR识别测试: {result}")
        else:
            print("⚠ 缺少测试图片")
            
    except ImportError as e:
        print(f"✗ PaddleOCR导入失败: {e}")
    except Exception as e:
        print(f"✗ OCR初始化失败: {e}")

# 图像预处理改进
def preprocess_for_ocr(image):
    """OCR前图像预处理"""
    import cv2
    
    # 转换为灰度图
    if len(image.shape) == 3:
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    else:
        gray = image
    
    # 增强对比度
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    enhanced = clahe.apply(gray)
    
    # 去噪
    denoised = cv2.medianBlur(enhanced, 3)
    
    # 锐化
    kernel = np.array([[-1,-1,-1], [-1,9,-1], [-1,-1,-1]])
    sharpened = cv2.filter2D(denoised, -1, kernel)
    
    return sharpened
```

---

## 🚀 性能问题

### Q9: CPU占用过高
```python
# 常见原因
- 捕获频率过高
- 检测任务过多
- 日志输出过频繁
- 内存泄漏
```

**性能分析工具**:
```python
import psutil
import time
from functools import wraps

def performance_monitor(func):
    """性能监控装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        # CPU和内存监控
        process = psutil.Process()
        cpu_before = process.cpu_percent()
        memory_before = process.memory_info().rss / 1024 / 1024
        
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        
        cpu_after = process.cpu_percent()
        memory_after = process.memory_info().rss / 1024 / 1024
        
        execution_time = (end_time - start_time) * 1000
        
        if execution_time > 100:  # 超过100ms的函数记录
            print(f"性能警告 {func.__name__}:")
            print(f"  执行时间: {execution_time:.2f}ms")
            print(f"  CPU变化: {cpu_before:.1f}% -> {cpu_after:.1f}%")
            print(f"  内存变化: {memory_before:.1f}MB -> {memory_after:.1f}MB")
        
        return result
    return wrapper

# 使用示例
@performance_monitor
def expensive_detection_function():
    # 耗时的检测操作
    pass
```

**性能优化方案**:
```python
# 1. 调整捕获频率
CAPTURE_INTERVAL = 150  # 从100ms调整到150ms

# 2. 减少并发检测任务
MAX_CONCURRENT_DETECTIONS = 2  # 限制并发数

# 3. 优化日志输出
import logging
logging.getLogger('paddleocr').setLevel(logging.WARNING)  # 减少OCR日志

# 4. 内存定期清理
import gc
def periodic_cleanup():
    gc.collect()  # 强制垃圾回收
    
# 每分钟执行一次清理
scheduler.add_task("memory_cleanup", 60000, periodic_cleanup)
```

### Q10: 内存泄漏问题
```python
# 内存泄漏检测
import tracemalloc

def start_memory_trace():
    """启动内存追踪"""
    tracemalloc.start()

def check_memory_growth():
    """检查内存增长"""
    current, peak = tracemalloc.get_traced_memory()
    print(f"当前内存使用: {current / 1024 / 1024:.1f}MB")
    print(f"峰值内存使用: {peak / 1024 / 1024:.1f}MB")
    
    # 获取内存增长最快的部分
    snapshot = tracemalloc.take_snapshot()
    top_stats = snapshot.statistics('lineno')
    
    print("内存使用TOP10:")
    for stat in top_stats[:10]:
        print(f"  {stat}")

# 常见内存泄漏源
def fix_memory_leaks():
    """修复常见内存泄漏"""
    
    # 1. 及时关闭图像对象
    def process_image(image_path):
        from PIL import Image
        with Image.open(image_path) as img:
            # 处理图像
            result = img.copy()
        return result  # img自动关闭
    
    # 2. 清理numpy数组
    def clear_numpy_cache():
        import numpy as np
        # 强制清理numpy缓存
        if hasattr(np, 'core') and hasattr(np.core, '_multiarray_umath'):
            np.core._multiarray_umath._reload_guard = False
    
    # 3. 定期清理缓存
    def clear_all_caches():
        border_manager.clear_cache()
        resource_manager.clear_cache() 
        gc.collect()
```

---

## 📋 问题报告模板

### 标准问题报告格式
```
## 问题描述
简要描述遇到的问题

## 环境信息
- 操作系统: Windows 10/11 版本号
- Python版本: python --version
- pyahk版本: git commit hash
- 显卡型号: 
- 屏幕分辨率:

## 复现步骤
1. 第一步
2. 第二步  
3. 第三步

## 预期行为
描述预期应该发生什么

## 实际行为
描述实际发生了什么

## 错误日志
```
粘贴相关的错误日志和堆栈跟踪
```

## 配置文件
```json
粘贴相关的配置文件内容
```

## 附加信息
- 是否以管理员权限运行
- 是否有杀毒软件/防火墙阻拦
- 其他可能相关的信息
```

### 日志收集脚本
```python
# collect_debug_info.py
import sys
import os
import platform
import subprocess
import json

def collect_debug_info():
    """收集调试信息"""
    info = {
        "system": {
            "platform": platform.platform(),
            "python_version": sys.version,
            "architecture": platform.architecture(),
        },
        "pyahk": {
            "version": get_pyahk_version(),
            "config_files": list_config_files(),
        },
        "dependencies": get_dependency_versions(),
        "logs": get_recent_logs(),
    }
    
    # 保存到文件
    with open("debug_info.json", "w", encoding="utf-8") as f:
        json.dump(info, f, ensure_ascii=False, indent=2)
    
    print("调试信息已保存到 debug_info.json")
    return info

if __name__ == "__main__":
    collect_debug_info()
```

通过这套完整的故障排查体系，用户可以快速定位并解决pyahk使用过程中遇到的各种问题，提高使用体验和系统稳定性。