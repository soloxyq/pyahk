# 02 核心架构设计

## 概述

pyahk采用现代化的分层架构和模块化设计，基于事件驱动模式构建。整个系统围绕**事件总线**进行组件间通信，通过**统一调度器**管理定时任务，使用**零拷贝屏幕捕获**技术实现高性能图像处理。

## 核心架构原则

### 1. 事件驱动架构
- **中央事件总线**：所有组件通过EventBus进行松耦合通信
- **发布/订阅模式**：支持异步事件处理和模块解耦
- **递归事件检测**：防止事件循环和死锁
- **线程安全**：支持多线程环境下的事件传递

### 2. 统一状态管理
- **标准状态机**：STOPPED → READY → RUNNING → PAUSED
- **状态转换控制**：严格的状态转换规则和权限检查
- **模式互斥**：技能模式、洗练模式、寻路模式的互斥执行
- **一致性保证**：所有功能模块遵循统一的状态流转

### 3. 模块化设计
- **单一职责**：每个模块只负责特定功能领域
- **接口标准化**：统一的模块接口和通信协议
- **可插拔架构**：支持模块的动态加载和卸载
- **依赖注入**：通过构造函数注入依赖关系

## 核心组件架构

### MacroEngine - 系统协调中心
```python
class MacroEngine:
    """
    职责：状态管理、资源调度、模式协调
    """
    def __init__(self):
        self._state = MacroState.STOPPED
        self._state_lock = threading.Lock()
        self._transition_lock = threading.Lock()
        
        # 功能模块管理
        self.skill_manager = None
        self.pathfinding_manager = None
        self.reroll_manager = None
        
        # 资源管理
        self.border_manager = None
        self.input_handler = None
        self.resource_manager = None
```

**核心职责**：
- 系统状态管理和转换控制
- 功能模块的生命周期管理
- 根据当前模式调度底层资源
- 热键处理和用户交互响应

### EventBus - 通信中枢
```python
class EventBus:
    """
    职责：事件分发、异步通信、模块解耦
    """
    def __init__(self):
        self.subscribers = defaultdict(list)
        self.subscribers_lock = threading.RLock()
        self._executor = ThreadPoolExecutor(max_workers=6)
        self._call_stack = threading.local()  # 递归检测
        
    def publish(self, event_name, *args, **kwargs):
        # 支持同步/异步事件分发
        
    def subscribe(self, event_name, callback):
        # 事件订阅注册
```

**技术特性**：
- 支持同步和异步事件处理
- 线程池优化的事件执行(6个工作线程)
- 基于threading.local()的递归事件检测和防护
- 性能监控和统计(每120秒记录一次)

### UnifiedScheduler - 任务调度核心
```python
class UnifiedScheduler:
    """
    职责：定时任务管理、精确调度、资源控制
    """
    def __init__(self):
        self._tasks = {}  # task_id -> ScheduledTask
        self._task_heap = []  # 基于heapq的优先级队列
        self._scheduler_thread = None
        self._lock = threading.Lock()
        self._condition = threading.Condition(self._lock)
        
    def _now(self) -> float:
        return time.monotonic()  # 单调时间源
        
    def add_task(self, task_id, interval, callback, **kwargs):
        # 动态任务添加，支持start_immediately参数
```

**技术优势**：
- 基于heapq的高效优先级队列
- time.monotonic()单调时间源，避免系统时钟调整影响
- 支持任务的动态增删改和更新
- 单线程调度避免竞态条件，提供亚毫秒级精度

## 输入系统架构

### 设计目标
- **统一入口**：所有输入通过 `InputHandler` 处理
- **优先级保障**：使用线程安全的PriorityDeque实现紧急操作插队
- **低延迟执行**：最小化阻塞操作，支持节流控制
- **调试友好**：dry_run 模式下完整记录行为轨迹

### 核心组件

| 组件 | 职责 |
|------|------|
| InputHandler | 输入调度与执行；维护PriorityDeque、线程、优先级管理 |
| PriorityDeque | 线程安全的双优先级队列，高优先级队列优先消费 |
| HotkeyManager | 全局热键监听，转换为内部事件 |
| hold_server.ahk | 接收 WM_COPYDATA，执行按住/释放操作 | 
| DebugDisplayManager | 接收 dry_run 动作文本，供 OSD 展示 |

### PriorityDeque 架构
```python
class PriorityDeque:
    """线程安全高/普通优先级双队列"""
    def __init__(self, maxsize: int = 0):
        self._high: Deque[Any] = deque()      # 高优先级队列
        self._normal: Deque[Any] = deque()    # 普通优先级队列
        self._maxsize = maxsize
        self._cond = Condition()
        
    def put(self, item, priority: bool = False):
        # priority=True: 插入高优先级队列
        # priority=False: 插入普通优先级队列
        
    def get(self):
        # 优先从高优先级队列消费，空时消费普通队列
```

### 输入处理流程
```
技能逻辑决定输入需求
    ↓
InputHandler.enqueue_action(action, priority=True/False)
    ↓
PriorityDeque.put(action, priority)
    ↓ 
后台线程: PriorityDeque.get() (高优先级优先)
    ↓
解析动作类型 (key_press/mouse_click/hold_*/etc.)
    ↓
根据dry_run模式决定：真实执行 or 记录调试
    ↓
pynput/AHK服务执行 or DebugDisplayManager记录
```

### Hold(按住)模式架构
```python
# Hold模式状态管理
def _handle_hold_skills_on_running():
    for skill in hold_skills:
        send_hold_command(skill.key)

def _handle_hold_skills_on_stop():
    for active_hold in self._active_holds:
        send_release_command(active_hold)
```

**技术优势**：
- 不占用调度器资源
- 简单稳定的状态管理
- 避免误重复按下
- 支持组合键和复杂按键序列

## 数据流架构

### 屏幕捕获数据流
```
DXGI Desktop Duplication (C++)
    ↓ 零拷贝共享内存
NativeGraphicsCaptureManager (Python ctypes)
    ↓ 帧数据分发
BorderFrameManager (缓存管理)
    ↓ 按需分发到各检测模块
SkillManager/ResourceManager/PathfindingManager
```

### 用户输入数据流
```
用户操作 (GUI/热键)
    ↓ 事件发布
EventBus (事件分发)
    ↓ 状态更新
MacroEngine (状态管理)
    ↓ 模块调度
具体功能模块 (执行操作)
    ↓ PriorityDeque入队
InputHandler (优先级队列管理)
    ↓ 硬件输出
pynput/AHK服务
```

### 配置数据流
```
JSON配置文件
    ↓ 加载解析
ConfigManager (配置管理)
    ↓ 事件通知
EventBus (配置更新事件)
    ↓ 配置同步
各功能模块 (热更新)
```

## 线程模型设计

### 主线程 (GUI线程)
- **职责**：用户界面更新、事件处理
- **特点**：Qt主事件循环，线程安全的UI更新
- **通信**：通过QTimer和信号槽与后台线程通信

### 调度线程 (UnifiedScheduler)
- **职责**：定时任务的精确调度和执行
- **特点**：单线程串行执行，避免竞态条件
- **性能**：高精度计时，低延迟任务分发

### 输入处理线程 (InputHandler)
```python
class InputHandler:
    def __init__(self):
        self._input_queue = PriorityDeque()
        self._processor_thread = threading.Thread(
            target=self._process_input_queue
        )
```

### 功能线程 (独立模块)
```python
# 洗练管理器 - 独立线程
class SimpleAffixRerollManager(threading.Thread):
    def run(self):
        # 独立的洗练逻辑循环
        
# 寻路管理器 - 独立线程  
class PathfindingManager(threading.Thread):
    def run(self):
        # 独立的寻路计算循环
```

### 事件总线线程池
- **ThreadPoolExecutor**: 6个工作线程
- **异步事件处理**: 非阻塞事件分发
- **递归检测**: per-thread调用栈监控

## 内存管理架构

### 图像数据管理
```python
class BorderFrameManager:
    def __init__(self):
        # 统一的图像缓存管理
        self._frame_cache = {}
        self._template_cache = {}
        self._cache_lock = threading.Lock()
        
    def get_cached_frame(self, cache_key):
        # 带过期时间的帧缓存
        
    def update_template_cache(self, region_name, template_data):
        # HSV模板缓存管理
```

### C++层零拷贝管理
```cpp
class DXGICaptureSession {
    // 双缓冲区设计
    std::vector<uint8_t> buffer_a;
    std::vector<uint8_t> buffer_b;
    
    // 原子指针，指向当前可读缓冲区
    std::atomic<uint8_t*> current_read_buffer;
    
    // 写入缓冲区切换标志
    bool writing_to_a = true;
};
```

### 对象生命周期管理
- **懒加载**：按需创建重资源对象（如OCR引擎）
- **对象池**：复用频繁创建的对象
- **引用计数**：自动清理不再使用的资源
- **内存监控**：实时监控内存使用情况

## 性能优化策略

### 输入系统优化
- **批量处理**: 合并连续的同类型操作
- **智能节流**: 根据系统负载动态调整延迟
- **队列监控**: 防止队列积压导致的延迟

### 调度器优化
- **任务合并**: 相近时间的任务合并执行
- **优先级继承**: 防止低优先级任务饿死
- **负载均衡**: 动态调整任务执行频率

### 事件总线优化
- **事件过滤**: 避免不必要的事件传播
- **批量订阅**: 减少锁竞争
- **智能路由**: 基于事件类型的快速分发

## 扩展点设计

### 新功能模块集成
1. 实现标准接口 (`start()`, `stop()`, `pause()`, `resume()`)
2. 订阅必要的事件 (`engine:state_changed`, `config:updated`)
3. 注册到MacroEngine的模块管理器
4. 添加配置字段到JSON schema

### 自定义输入处理器
```python
class CustomInputProcessor:
    def process_action(self, action: dict) -> bool:
        # 自定义输入处理逻辑
        return True
        
# 注册到InputHandler
input_handler.register_processor(CustomInputProcessor())
```

### 事件扩展
```python
# 定义新事件
event_bus.publish("custom:new_event", data=custom_data)

# 订阅处理
def handle_custom_event(data):
    # 处理自定义事件
    pass
    
event_bus.subscribe("custom:new_event", handle_custom_event)
```

这种架构设计确保了系统的可扩展性、可维护性和高性能，为复杂的游戏自动化需求提供了坚实的技术基础。