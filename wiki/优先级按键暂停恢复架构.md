# 优先级按键暂停/恢复架构说明

## 概述

本架构实现了一个高效的"暂停/恢复"机制，当用户按下优先级按键（如空格键、右键等）时，系统会自动暂停 `SkillManager` 的所有调度任务，以避免不必要的 CPU 资源浪费。当优先级按键释放后，系统自动恢复正常调度。

## 核心原理

### 问题背景
- 之前的实现中，当优先级按键被按下时，虽然技能执行被阻塞，但 `UnifiedScheduler` 仍然继续运行
- 这导致 `check_cooldowns`、帧检测、资源检查等耗费 CPU 的任务仍在执行，但结果完全被丢弃
- 造成了"零功效的资源浪费"

### 解决方案
实现了一个基于事件总线的双向通信机制：

1. **InputHandler** 监控优先级按键状态变化
2. 当第一个优先级按键按下时，通过事件总线通知 **SkillManager** 暂停调度
3. 当所有优先级按键释放时，通过事件总线通知 **SkillManager** 恢复调度

## 架构组件

### 1. InputHandler (优先级按键监控)

**文件**: `torchlight_assistant/core/input_handler.py`

**关键方法**:
```python
def _pause_skill_scheduler(self):
    """暂停技能调度器以节省CPU资源"""
    event_bus.publish('scheduler_pause_requested', {
        'reason': 'priority_key_pressed',
        'active_keys': list(self._priority_keys_pressed)
    })

def _resume_skill_scheduler(self):
    """恢复技能调度器"""
    event_bus.publish('scheduler_resume_requested', {
        'reason': 'priority_key_released'
    })
```

**触发时机**:
- `_on_key_press`: 第一个优先级按键按下时触发暂停
- `_on_key_release`: 最后一个优先级按键释放时触发恢复
- `_on_mouse_click`: 鼠标优先级按键的按下/释放

### 2. SkillManager (调度器控制)

**文件**: `torchlight_assistant/core/skill_manager.py`

**事件订阅**:
```python
event_bus.subscribe("scheduler_pause_requested", self._on_scheduler_pause_requested)
event_bus.subscribe("scheduler_resume_requested", self._on_scheduler_resume_requested)
```

**回调方法**:
```python
def _on_scheduler_pause_requested(self, event_data):
    """响应优先级按键按下 - 暂停调度器以节省CPU资源"""
    if self.unified_scheduler.get_status()["running"]:
        self.unified_scheduler.pause()

def _on_scheduler_resume_requested(self, event_data):
    """响应优先级按键释放 - 恢复调度器"""
    if self._is_running and not self._is_paused:
        self.unified_scheduler.resume()
```

### 3. UnifiedScheduler (核心调度器)

**文件**: `torchlight_assistant/core/unified_scheduler.py`

**修复的方法**:
```python
def pause(self) -> bool:
    """暂停所有任务执行"""
    if not self._running or self._paused:
        return False
    self._paused = True
    return True

def resume(self) -> bool:
    """恢复所有任务执行"""
    if not self._running or not self._paused:
        return False
    self._paused = False
    # 重新计算任务执行时间
    current_time = self._now()
    for task in self._tasks.values():
        if task.enabled:
            task.next_run_time = current_time + task.interval
    self._rebuild_heap()
    self._condition.notify()
    return True
```

## 性能优化效果

### CPU 使用优化
- **暂停期间**: 所有调度任务停止执行，CPU 使用率显著降低
- **恢复机制**: 智能重新计算任务执行时间，避免堆积执行

### 资源节约
- 避免无效的帧捕获和像素分析
- 停止冷却时间检查和资源状态更新
- 减少不必要的内存分配和网络访问

### 响应性提升
- 优先级按键响应更加即时
- 系统整体响应性得到改善

## 状态管理

### 暂停状态层级
1. **用户手动暂停** (`_is_paused = True`): 通过 UI 或热键暂停整个系统
2. **优先级按键暂停** (`unified_scheduler.pause()`): 临时性能优化暂停
3. **系统停止** (`_is_running = False`): 完全停止运行

### 恢复逻辑
- 只有在系统运行中（`_is_running = True`）且未被用户手动暂停（`_is_paused = False`）时才会自动恢复
- 确保用户的手动暂停不会被优先级按键的自动恢复机制覆盖

## 事件流程图

```
用户按下空格键
      ↓
InputHandler._on_key_press()
      ↓
_pause_skill_scheduler()
      ↓
event_bus.publish('scheduler_pause_requested')
      ↓
SkillManager._on_scheduler_pause_requested()
      ↓
unified_scheduler.pause()
      ↓
🛑 所有调度任务暂停执行

      ↓ (用户释放空格键)

InputHandler._on_key_release()
      ↓
_resume_skill_scheduler()
      ↓
event_bus.publish('scheduler_resume_requested')
      ↓
SkillManager._on_scheduler_resume_requested()
      ↓
unified_scheduler.resume()
      ↓
▶️ 所有调度任务恢复执行
```

## 测试验证

架构已通过以下测试验证：

1. **调度器暂停/恢复功能测试**: ✅ 通过
2. **事件总线通信测试**: ✅ 通过
3. **多优先级按键处理测试**: ✅ 通过
4. **状态管理逻辑测试**: ✅ 通过

## 优势总结

1. **零资源浪费**: 优先级按键激活期间完全停止不必要的计算
2. **即时响应**: 按键按下后立即暂停，释放后立即恢复
3. **智能状态管理**: 尊重用户的手动暂停状态
4. **线程安全**: 使用事件总线和条件变量确保线程安全
5. **可扩展性**: 架构支持未来添加更多暂停/恢复触发条件

这个架构实现了真正的"按需计算"，只在实际需要时消耗 CPU 资源，显著提升了系统的整体效率。